This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-03T14:32:13.340Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
mosquitto/
  certs/
    ca.crt
    mqtt.example.tld.crt
    pki.example.tld.crl
  mosquitto.conf
pki/
  easy-rsa/
    .github/
      workflows/
        action.yml
    distro/
      windows/
        bin/
          easyrsa-shell-init.sh
        Licensing/
          LICENSE-OpenSSL.txt
          mksh-Win32.txt
        EasyRSA-Start.bat
        README-Windows.txt
      README
    doc/
      EasyRSA-Advanced.md
      EasyRSA-Contributing.md
      EasyRSA-Readme.md
      EasyRSA-Renew-and-Revoke.md
      EasyRSA-Upgrade-Notes.md
      Hacking.md
      Intro-To-PKI.md
      TODO
    easyrsa3/
      x509-types/
        ca
        client
        code-signing
        COMMON
        email
        kdc
        server
        serverClient
      easyrsa
      openssl-easyrsa.cnf
      vars.example
    Licensing/
      gpl-2.0.txt
    pki/
      certs_by_serial/
        967FF89932D79EEA6ABB4114F96CE482.pem
      inline/
        private/
          README.inline.private
        mqtt.example.tld.inline
      issued/
        mqtt.example.tld.crt
      reqs/
        mqtt.example.tld.req
      ca.crt
      crl.pem
      index.txt
      index.txt.attr
      serial
      serial.old
      vars.example
    release-keys/
      README.md
    .gitignore
    ChangeLog
    COPYING.md
    KNOWN_ISSUES
    op-test.sh
    README.md
    README.quickstart.md
    vars
    wop-test.bat
    wop-test.sh
python_client/
  certs/
    ca.crt
  mqtt_pub.py
  mqtt_sub.py
servidor/
  easy-rsa/
    .github/
      workflows/
        action.yml
    distro/
      windows/
        bin/
          easyrsa-shell-init.sh
        Licensing/
          LICENSE-OpenSSL.txt
          mksh-Win32.txt
        EasyRSA-Start.bat
        README-Windows.txt
      README
    doc/
      EasyRSA-Advanced.md
      EasyRSA-Contributing.md
      EasyRSA-Readme.md
      EasyRSA-Renew-and-Revoke.md
      EasyRSA-Upgrade-Notes.md
      Hacking.md
      Intro-To-PKI.md
      TODO
    easyrsa3/
      x509-types/
        ca
        client
        code-signing
        COMMON
        email
        kdc
        server
        serverClient
      easyrsa
      openssl-easyrsa.cnf
      vars.example
    Licensing/
      gpl-2.0.txt
    pki/
      reqs/
        mqtt.example.tld.req
      vars.example
    release-keys/
      README.md
    .gitignore
    ChangeLog
    COPYING.md
    KNOWN_ISSUES
    op-test.sh
    README.md
    README.quickstart.md
    wop-test.bat
    wop-test.sh
.gitignore
.python-version
Justfile
LICENSE
pyproject.toml
README.md
uv.lock

================================================================
Files
================================================================

================
File: mosquitto/certs/ca.crt
================
-----BEGIN CERTIFICATE-----
MIIFWTCCA0GgAwIBAgIUemDZJhnhPitFWMfaWHkWplwheygwDQYJKoZIhvcNAQEL
BQAwGjEYMBYGA1UEAwwPcGtpLmV4YW1wbGUudGxkMCAXDTI1MDIwMzE0MDAwNFoY
DzMwMjQwNjA2MTQwMDA0WjAaMRgwFgYDVQQDDA9wa2kuZXhhbXBsZS50bGQwggIi
MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCrGiIsoJAA7dsliv8w4OnLT3Ue
JN8ukoa++6giI21KYmoswE7JJL7OWT19l62O5giFbw2AadkKw9+SORmmC342eruZ
eQKbUduoG1McrqrTRIbUfCZQlUYttF89gpcOal2UtG0vPOTwBRZkrq6H68wuUVM3
CkWSu/cImP4/9MbyGlJUGv8wvlVzBB+qeViE9Q49EIN5C3gr6LbgyfplBG5V0WK3
IxFE1pWg4Dj1/el3jjF6EDQGMBSngogO56cxgi6ZFzDr5v5csHDLKMtU9fEuHX70
RA5GwyLj6VvUKrMrgYC/MPRI5ggapTWH5QQ62g2CLhvCPwFzm5/lp6KLhQElkn7D
I4QGg1hNFHnuOJhotPcfHNqkAmvA9++x36eb+JmO2fNlUd7HcZrMLnnKAk+FaxAe
PaauBjiiBktm2fwYO4MHvpnzhB3KKvXqL1UiNiCXgFLuq9EpsxkTWj6mAM6iRpUi
ERtzk0XWS24g6gVDOr9LLQZE5yW4YC8cixymkL3921zn/DulIbO0bMYkdtcoTyyM
sL+tiDA0Cl/lglvcHrtCg2H0/o/a6emSmXpZ7s6m/JYZkRkcdCwwBLkfNSB8qkSJ
U+WbzpOAeegcwnPJlEwO8awqh8hMzkG/RK7PSRipJnqI3LYMv9dHuJJbVg53hPSO
N1xby0TzRfTIi1tT9wIDAQABo4GUMIGRMAwGA1UdEwQFMAMBAf8wHQYDVR0OBBYE
FEh1idNahu2pS+Af0egknn1e+4QqMFUGA1UdIwROMEyAFEh1idNahu2pS+Af0egk
nn1e+4QqoR6kHDAaMRgwFgYDVQQDDA9wa2kuZXhhbXBsZS50bGSCFHpg2SYZ4T4r
RVjH2lh5FqZcIXsoMAsGA1UdDwQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAdnOO
lbcXn+0QRRl5nVbBsMisGmvQGEudop5Ypu1v3frBDDsH2Q03lcGIuQGa4qa7Tb/T
xl7wdwj7CdCpAQpUYjVRyWTS1z2nDpCe8W5EG4oEDjMF5eNnvzU9IxLbY1s2vCcY
2VNi4P5rdZvCetz/DZIK6oP+ZGzkwhqnITs25LWw+exx80rXlc4NHpEFGvfeZj9i
cYWzR4SwyUHZHmHsxSZCTm7EUFUayE+Ao7jf6Qhi+qNOTqWt1OnH4Hev6fKH4fiq
EKrnPk3C2YtCqeiC1mLw/fwNZEFyEBo4vbpb+spBhNDpfT/+GZyvGZ7OD4EHttmh
s9fZLf6k23Mcb5ixOqq00x22Hn1INaRTW/GtZ3qcwZem1JUy/rmItGriEZ/+cGjk
1xEEgI9G5cS5qqbWB0Olm8zbE3KKFSAxpK+ZlsnmkoCoJMKfP6oYI/okTVRFEy0z
Ku4N8MGkvXh1ikQcIirJra/n9eTat1n9iceb34hgxV93Srxdmg4fpMdM8GxOkQab
26CSsecBQzWGFxOQt4zQAoXQQSDI2PFITN6jXBNUrYdKoTTQEBrkJ9T9KnBFWoIe
M9BFRNeLJAUZ71gdaYgEzKtYOcZhWG5tfdo+MPxLjdchC7A95xl6wGJFmchabtIG
3RLvEQa6PFIDC1xajQUZDMQdiwWDxxGVldotKos=
-----END CERTIFICATE-----

================
File: mosquitto/certs/mqtt.example.tld.crt
================
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            96:7f:f8:99:32:d7:9e:ea:6a:bb:41:14:f9:6c:e4:82
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=pki.example.tld
        Validity
            Not Before: Feb  3 14:09:09 2025 GMT
            Not After : May  9 14:09:09 2027 GMT
        Subject: CN=mqtt.example.tld
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:a7:81:73:41:ce:6f:64:52:ea:68:c4:96:6b:97:
                    96:31:e1:86:0f:30:26:32:f7:0a:c9:47:53:70:ec:
                    3e:d8:96:f9:99:2d:2e:8d:b4:b3:02:05:0e:40:63:
                    69:44:4f:8e:c6:06:6f:e3:65:b3:4b:ae:14:b3:3b:
                    bf:36:32:48:5d:b4:07:af:b7:11:6b:04:c2:09:8b:
                    8f:64:d1:42:ef:d1:d7:70:08:8e:c7:23:55:ce:3f:
                    ff:6b:a4:be:8d:17:6c:24:e8:8f:06:2f:0c:7f:43:
                    d1:85:e8:e5:54:2d:51:d5:a8:a3:5a:55:d2:4d:2b:
                    04:33:0f:54:93:8a:d4:0e:5b:1b:70:c8:db:a4:d9:
                    cd:4a:17:12:1a:77:87:64:db:53:b3:c2:b7:27:66:
                    84:0a:48:e5:bb:d8:60:f6:c5:32:c3:1f:86:16:9d:
                    09:20:6e:7b:2d:4f:d3:29:c0:f0:36:d5:84:81:ea:
                    59:b2:a7:b8:82:0d:57:49:0a:0a:f7:31:b8:02:51:
                    e6:94:20:37:62:75:df:93:e2:10:ec:8f:a3:f2:a0:
                    44:c7:18:29:34:da:91:a4:f6:5c:03:07:78:59:e3:
                    05:fe:58:6e:3d:e4:41:07:cc:28:7c:d8:90:6b:da:
                    6e:e7:22:1b:ba:d9:8f:13:3b:5a:8b:c2:0c:b9:50:
                    62:57
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Basic Constraints: 
                CA:FALSE
            X509v3 Subject Key Identifier: 
                DE:2B:C6:06:A9:41:45:AD:6A:0E:13:6D:EC:5A:ED:73:72:70:42:E2
            X509v3 Authority Key Identifier: 
                keyid:48:75:89:D3:5A:86:ED:A9:4B:E0:1F:D1:E8:24:9E:7D:5E:FB:84:2A
                DirName:/CN=pki.example.tld
                serial:7A:60:D9:26:19:E1:3E:2B:45:58:C7:DA:58:79:16:A6:5C:21:7B:28
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication
            X509v3 Key Usage: 
                Digital Signature, Key Encipherment
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        09:c8:c7:5f:b9:93:11:08:23:ca:11:20:12:b8:54:6f:35:2b:
        1f:e8:90:ba:dd:ba:d1:0d:51:a1:e4:33:76:fd:95:6a:9b:4c:
        0c:5f:91:9f:94:ee:4c:f5:79:e7:fb:0c:c8:b4:1f:bf:4a:d4:
        bb:b3:ee:b6:12:bc:9a:4a:63:c6:ff:87:2f:e9:dd:6c:8e:ee:
        76:13:cf:c6:29:ca:0f:a6:0d:8a:cd:13:bf:13:06:6e:b0:68:
        c2:ab:8d:3e:af:15:be:2e:c0:a3:4f:5b:50:0c:2f:06:8f:8f:
        42:ab:a0:1b:41:44:4f:29:98:4a:e0:05:52:57:9b:10:0e:b6:
        49:00:6b:46:ef:8c:1d:de:5e:d9:3e:e9:a0:21:b7:b2:2c:e9:
        61:ca:d6:90:e0:d9:ad:c9:7e:0c:8e:9b:c5:70:4f:81:6b:d0:
        6c:a8:6c:eb:f6:fb:06:1e:41:fb:ec:a2:f8:95:c5:8c:71:c9:
        e3:f9:6c:c5:b9:c0:12:1d:72:b9:43:81:16:d2:61:c3:e1:94:
        3b:a3:b2:60:45:da:be:b4:4c:80:3b:13:91:c0:2b:7c:73:15:
        8e:fc:3b:dd:c4:e8:20:fd:82:d9:3e:d8:83:e4:92:68:7c:2d:
        86:8d:a6:3f:9a:0a:4e:a6:77:17:6a:13:de:56:60:f3:7b:19:
        80:2f:69:17:fc:a7:3c:73:e7:3e:a0:6d:4b:cc:74:cb:67:50:
        f7:4d:dd:56:b1:9c:77:16:29:af:62:82:5e:24:ac:fa:af:04:
        9b:c3:6c:4c:bd:2b:93:eb:55:49:0a:31:1f:89:af:1e:30:06:
        14:84:48:ad:fb:20:23:17:37:18:b9:f4:05:26:2b:f6:7b:14:
        df:31:42:72:b4:2c:62:fa:85:b9:73:aa:c4:41:43:04:09:7d:
        b6:db:a9:b3:aa:fe:66:46:cf:cc:50:7b:80:9b:89:e1:58:aa:
        8b:87:1a:5b:0d:d9:ec:c6:00:00:ae:66:14:27:89:fb:f9:9b:
        2e:17:5b:7d:1d:44:bd:a9:08:3a:1a:c2:cd:64:50:8b:fb:7a:
        c2:a0:5f:3c:8f:c7:a8:9f:17:9b:fe:22:e7:27:ec:de:26:95:
        5f:99:cd:0b:7b:9e:92:51:84:c7:32:50:dc:bd:64:cd:8a:20:
        c7:ce:8a:ef:1c:29:cb:c2:b2:76:d8:cd:5a:ab:46:65:a3:3f:
        db:57:e7:ad:68:6e:3a:23:d2:6a:e9:65:3c:ef:81:2a:db:18:
        c7:86:d0:5d:51:cc:3b:db:bb:98:e6:61:9b:fc:f0:9e:62:5f:
        e6:7c:b0:3a:ff:08:a7:45:ab:22:e1:62:22:50:98:0d:d0:c3:
        28:1a:48:b6:2e:b8:d1:6d
-----BEGIN CERTIFICATE-----
MIIEZzCCAk+gAwIBAgIRAJZ/+Jky157qartBFPls5IIwDQYJKoZIhvcNAQELBQAw
GjEYMBYGA1UEAwwPcGtpLmV4YW1wbGUudGxkMB4XDTI1MDIwMzE0MDkwOVoXDTI3
MDUwOTE0MDkwOVowGzEZMBcGA1UEAwwQbXF0dC5leGFtcGxlLnRsZDCCASIwDQYJ
KoZIhvcNAQEBBQADggEPADCCAQoCggEBAKeBc0HOb2RS6mjElmuXljHhhg8wJjL3
CslHU3DsPtiW+ZktLo20swIFDkBjaURPjsYGb+Nls0uuFLM7vzYySF20B6+3EWsE
wgmLj2TRQu/R13AIjscjVc4//2ukvo0XbCTojwYvDH9D0YXo5VQtUdWoo1pV0k0r
BDMPVJOK1A5bG3DI26TZzUoXEhp3h2TbU7PCtydmhApI5bvYYPbFMsMfhhadCSBu
ey1P0ynA8DbVhIHqWbKnuIINV0kKCvcxuAJR5pQgN2J135PiEOyPo/KgRMcYKTTa
kaT2XAMHeFnjBf5Ybj3kQQfMKHzYkGvabuciG7rZjxM7WovCDLlQYlcCAwEAAaOB
pjCBozAJBgNVHRMEAjAAMB0GA1UdDgQWBBTeK8YGqUFFrWoOE23sWu1zcnBC4jBV
BgNVHSMETjBMgBRIdYnTWobtqUvgH9HoJJ59XvuEKqEepBwwGjEYMBYGA1UEAwwP
cGtpLmV4YW1wbGUudGxkghR6YNkmGeE+K0VYx9pYeRamXCF7KDATBgNVHSUEDDAK
BggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAAnIx1+5
kxEII8oRIBK4VG81Kx/okLrdutENUaHkM3b9lWqbTAxfkZ+U7kz1eef7DMi0H79K
1Luz7rYSvJpKY8b/hy/p3WyO7nYTz8Ypyg+mDYrNE78TBm6waMKrjT6vFb4uwKNP
W1AMLwaPj0KroBtBRE8pmErgBVJXmxAOtkkAa0bvjB3eXtk+6aAht7Is6WHK1pDg
2a3JfgyOm8VwT4Fr0GyobOv2+wYeQfvsoviVxYxxyeP5bMW5wBIdcrlDgRbSYcPh
lDujsmBF2r60TIA7E5HAK3xzFY78O93E6CD9gtk+2IPkkmh8LYaNpj+aCk6mdxdq
E95WYPN7GYAvaRf8pzxz5z6gbUvMdMtnUPdN3VaxnHcWKa9igl4krPqvBJvDbEy9
K5PrVUkKMR+Jrx4wBhSESK37ICMXNxi59AUmK/Z7FN8xQnK0LGL6hblzqsRBQwQJ
fbbbqbOq/mZGz8xQe4CbieFYqouHGlsN2ezGAACuZhQnifv5my4XW30dRL2pCDoa
ws1kUIv7esKgXzyPx6ifF5v+Iucn7N4mlV+ZzQt7npJRhMcyUNy9ZM2KIMfOiu8c
KcvCsnbYzVqrRmWjP9tX561objoj0mrpZTzvgSrbGMeG0F1RzDvbu5jmYZv88J5i
X+Z8sDr/CKdFqyLhYiJQmA3QwygaSLYuuNFt
-----END CERTIFICATE-----

================
File: mosquitto/certs/pki.example.tld.crl
================
-----BEGIN X509 CRL-----
MIICvjCBpwIBATANBgkqhkiG9w0BAQsFADAaMRgwFgYDVQQDDA9wa2kuZXhhbXBs
ZS50bGQXDTI1MDIwMzE0MTMzNFoXDTI1MDgwMjE0MTMzNFqgWTBXMFUGA1UdIwRO
MEyAFEh1idNahu2pS+Af0egknn1e+4QqoR6kHDAaMRgwFgYDVQQDDA9wa2kuZXhh
bXBsZS50bGSCFHpg2SYZ4T4rRVjH2lh5FqZcIXsoMA0GCSqGSIb3DQEBCwUAA4IC
AQAyBnda9OlFgGkKC1tQili7p9p9+ckLPafRFClOgIdtAna4PHkvkdQsKT5cxhuq
lTsfakYTcWH3sY2d3ktBXqOGap1v41LwIWe6Pg32P0Km9pG4oWk0iaYUPJGkMXke
0YOHoxqd7hAOCdG+nof0y7qq0wQbIvns+h4loutRKqf81GMTH7Ez/vJejUQRY5IH
zgg6IEPFu3JrErTgi9VH3LQf8srNHBIJqADNmWd4pvNeyvvwO5N5KYE3MZspKF7f
2nu3VrdOjcgZkvfvEDuR9wMFuMJMC0j/CaOtAgMNk57qsXPxAwxyH1vcI9eM2c7z
bzH3QSkIAHLFtHx7lkVsORYT3WbOyOi8QEOGPr/lf/EyxvpMB+McA0X5eGwEmRPV
cxa7GPb7WYLCWbTHT4rfaz27F2IAa2tfApumvPj76yBQrkAHxAcPFD2bcuBEdB1B
/fCockEe5JIg7NCOGCVcQEqg3xIPwq48NKmzS9DthOw2laPRM6SpOjkgju73k/zd
0u/vckFY8CX0hXx+6S/Qo2CemL3IGxqUNyzs2sqSEqp9Qy6fXO0eNMvyiIkR/6x/
YQYeuf3JKLPA51TDif6JrdCbB0/s4Z0TUppobcVHEFDGGsw2uSR3Nd1JfqmiRds9
WOSJXt9R7hbtWbwMrJ5BJHISutxUo5JCzD4iGCnEIvKabA==
-----END X509 CRL-----

================
File: mosquitto/mosquitto.conf
================
# mqtt secure
listener 8883 0.0.0.0
cafile certs/ca.crt
keyfile certs/mqtt.example.tld.key
certfile certs/mqtt.example.tld.crt
crlfile certs/pki.example.tld.crl
allow_anonymous true
require_certificate false

# websockets secure
listener 8884 0.0.0.0
protocol websockets
cafile certs/ca.crt
keyfile certs/mqtt.example.tld.key
certfile certs/mqtt.example.tld.crt
crlfile certs/pki.example.tld.crl
allow_anonymous true
require_certificate false

================
File: pki/easy-rsa/.github/workflows/action.yml
================
# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the action will run.
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  xtest:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    env:
      EASYRSA_BY_TINCANTECH: 1
      EASYRSA_REMOTE_CI: 1
      EASYRSA_NIX: 1
      TERM: xterm-256color
      EASYRSA_SILENT_SSL: 1

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: operational test
        run: sh op-test.sh -vv -sc -o3 -p

      # Runs a set of commands using the runners shell
      # - name: Run a multi-line script
      #    run: |
      #      echo Add other actions to build,
      #      echo test, and deploy your project.
      # This workflow contains a single job called "build"

  xtest_old:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    env:
      EASYRSA_BY_TINCANTECH: 1
      EASYRSA_REMOTE_CI: 1
      EASYRSA_NIX: 1
      TERM: xterm-256color
      EASYRSA_SILENT_SSL: 1
      EASYRSA_FORCE_SAFE_SSL: 1
      EASYRSA_LEGACY_SAFE_SSL: 1
      EASYRSA_VERBOSE: 1

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: operational test
        run: sh op-test.sh -vv -sc -o3 -p

      # Runs a set of commands using the runners shell
      # - name: Run a multi-line script
      #    run: |
      #      echo Add other actions to build,
      #      echo test, and deploy your project.
      # This workflow contains a single job called "build"

  wtest:
    # The type of runner that the job will run on
    runs-on: windows-latest

    env:
      EASYRSA_REMOTE_CI: 1
      EASYRSA_WIN: 1
      TERM: xterm-256color
      EASYRSA_SILENT_SSL: 1

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: cmd /c wop-test.bat

      # Runs a set of commands using the runners shell
      # - name: Run a multi-line script
      #    run: |
      #      echo Add other actions to build,
      #      echo test, and deploy your project.

  mtest:
    # The type of runner that the job will run on
    runs-on: macos-latest

    env:
      EASYRSA_REMOTE_CI: 1
      # Limit run to RSA and EC only, Libre does not do ED
      #LIBRESSL_LIMIT: 1
      EASYRSA_MAC: 1
      TERM: xterm-256color
      EASYRSA_SILENT_SSL: 1

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: sh op-test.sh -v -p

      # Runs a set of commands using the runners shell
      # - name: Run a multi-line script
      #    run: |
      #      echo Add other actions to build,
      #      echo test, and deploy your project.

================
File: pki/easy-rsa/distro/windows/bin/easyrsa-shell-init.sh
================
#!/bin/sh
# shellcheck disable=SC2161,SC1091,SC2028

# This script is a frontend designed to create & launch a POSIX shell
# environment suitable for use with Easy-RSA. mksh/Win32 is used with this
# project; use with other POSIX shells for Windows may require modification to
# this wrapper script.

echo "Easy-RSA starting.."

setup_path="${EASYRSA:-$PWD}"
export PATH="$setup_path;$setup_path/bin;$PATH"
export HOME="$setup_path"

# This prevents reading from a user's .mkshrc if they have one.
# A user who runs mksh for other purposes might have it
export ENV="/disable-env"

# Verify required externals are present
extern_list="which awk cat cp mkdir printf rm"
for f in $extern_list; do
	if ! which "${f}.exe" >/dev/null 2>&1; then
		echo ""
		echo "FATAL: EasyRSA Shell init is missing a required external file:"
		echo "  ${f}.exe"
		echo "  Your installation is incomplete and cannot function without the required"
		echo "  files."
		echo ""
		#shellcheck disable=SC2162
		read -p "Press Enter or CTRL-C to exit."
		exit 1
	fi
done

# Allow options
non_admin=""
while [ "$1" ]; do
	case "$1" in
		/[Nn][Aa]|/no-adm*|--no-adm*)
			non_admin=1
			echo "Using no-admin mode"
		;;
		*)
			echo "Ignoring unknown option: '$1'"
	esac
	shift
done

# Access denied
access_denied() {
	echo "Access error: $1"
	echo "\
To use Easy-RSA in a protected system directory, you must have
full administrator privileges via Windows User Access Control."
	echo ""

	#shellcheck disable=SC2162
	read -p "Press Enter or CTRL-C to exit."
	exit 1
}

# Use home directory/easy-rsa
if [ "$non_admin" ]; then
	[ "${HOMEDRIVE}" ] || \
		access_denied "Undefined: HOMEDRIVE"
	user_home_drv="${HOMEDRIVE}"

	[ "${HOMEPATH}" ] || \
		access_denied "Undefined: HOMEPATH"
	eval "user_home_dir='\\${HOMEPATH}'"

	# shellcheck disable=SC2154 # user_home_dir is not assigned
	user_home="${user_home_drv}${user_home_dir}"

	[ -d "$user_home" ] || \
		access_denied "Missing: $user_home"

	cd "$user_home" 2>/dev/null || \
		access_denied "Access: $user_home"

	if [ ! -d easy-rsa ]; then
		mkdir easy-rsa 2>/dev/null || \
			access_denied "mkdir: easy-rsa"
		# Required test
		[ -d easy-rsa ] || \
			access_denied "Missing: easy-rsa"
	fi

	cd easy-rsa 2>/dev/null || \
		access_denied "Access: easy-rsa"

	export HOME="$PWD"
	export PATH="$HOME;$PATH"
	unset -v user_home_drv user_home_dir user_home
fi

# Check for broken administrator access
# https://github.com/OpenVPN/easy-rsa/issues/1072
[ -d "$HOME" ] || access_denied "-d HOME"
win_tst_d="$HOME"/easyrsa-write-test

# Required tests
mkdir "$win_tst_d" 2>/dev/null || access_denied "mkdir"
[ -d "$win_tst_d" ] || access_denied "-d"
echo 1 >"$win_tst_d"/1 2>/dev/null || access_denied "write"
[ -f "$win_tst_d"/1 ] || access_denied "-f"
rm -rf "$win_tst_d" 2>/dev/null || access_denied "rm"
[ ! -d "$win_tst_d" ] || access_denied "! -d"
unset -v win_tst_d
unset -f access_denied

# set_var is defined as any vars file needs it.
# This is the same as in easyrsa, but we _don't_ export
set_var() {
        var="$1"
        shift
        value="$*"
        eval "$var=\"\${$var-$value}\""
} #=> set_var()

# Check for a usable openssl bin, referencing vars if present
[ -r "vars" ] && EASYRSA_CALLER=1 . "vars" 2>/dev/null
if [ -z "$EASYRSA_OPENSSL" ] && ! which openssl.exe >/dev/null 2>&1; then
	echo "WARNING: openssl isn't in your system PATH. The openssl binary must be"
	echo "  available in the PATH, defined in the 'vars' file, or defined in a"
	echo "  named environment variable. See README-Windows.txt for more info."
fi

[ -f "$setup_path/easyrsa" ] || {
	echo "Missing easyrsa script. Expected to find it at: $setup_path/easyrsa"
	read -p "Press Enter or CTRL-C to exit."
	exit 2
}

# Set prompt and welcome message
export PS1='
EasyRSA Shell
# '
echo ""
echo "Welcome to the EasyRSA 3 Shell for Windows."
echo "Easy-RSA 3 is available under a GNU GPLv2 license."
echo ""
echo "Invoke 'easyrsa' to call the program. Without commands, help is displayed."
echo ""
echo "Using directory: $HOME"
echo ""

# Drop to a shell and await input
sh.exe

================
File: pki/easy-rsa/distro/windows/Licensing/LICENSE-OpenSSL.txt
================
LICENSE ISSUES
  ==============

  The OpenSSL toolkit stays under a double license, i.e. both the conditions of
  the OpenSSL License and the original SSLeay license apply to the toolkit.
  See below for the actual license texts.

  OpenSSL License
  ---------------

/* ====================================================================
 * Copyright (c) 1998-2018 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */

 Original SSLeay License
 -----------------------

/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscape's SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are adhered to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the routines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publicly available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

================
File: pki/easy-rsa/distro/windows/Licensing/mksh-Win32.txt
================
Licence
-------

mksh/Win32 is a derived work of The MirBSD Korn Shell and
recognised by The MirOS Project but realised by an independent
developer with support and legal permit by Scalaris AG.


The shell itself comes under The MirOS Licence:

Copyright (c) 2002-2013
	The MirOS Project
Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
	Thorsten Glaser <tg@mirbsd.org>
Copyright (c) 2010, 2011, 2012, 2013
	Michael Langguth <lan@scalaris.com>

Provided that these terms and disclaimer and all copyright notices
are retained or reproduced in an accompanying document, permission
is granted to deal in this work without restriction, including un-
limited rights to use, publicly perform, distribute, sell, modify,
merge, give away, or sublicence.

This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
the utmost extent permitted by applicable law, neither express nor
implied; without malicious intent or gross negligence. In no event
may a licensor, author or contributor be held liable for indirect,
direct, other damage, loss, or other issues arising in any way out
of dealing in the work, even if advised of the possibility of such
damage or existence of a defect, except proven that it results out
of said person's immediate fault when using the work as intended.


The shell contains strlcpy() under the ISC licence:

Copyright (c) 2006, 2008, 2009
	Thorsten Glaser <tg@mirbsd.org>
Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


This version of the shell contains setmode() under the UCB BSD licence:

Copyright (c) 1989, 1993, 1994
	The Regents of the University of California.  All rights reserved.

This code is derived from software contributed to Berkeley by
Dave Borman at Cray Research, Inc.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the University nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.


The shell includes nedmalloc under the Boost Software License which,
in turn, includes dlmalloc under CC0 (eventually) in its binary.


The "liblan" portability library is covered by The MirOS Licence:

Copyright (c) 1996, 1998, 2003, 2004, 2005, 2010, 2011, 2012, 2013
	Scalaris AG, Author: Michael Langguth <lan@scalaris.com>

Provided that these terms and disclaimer and all copyright notices
are retained or reproduced in an accompanying document, permission
is granted to deal in this work without restriction, including un-
limited rights to use, publicly perform, distribute, sell, modify,
merge, give away, or sublicence.

This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
the utmost extent permitted by applicable law, neither express nor
implied; without malicious intent or gross negligence. In no event
may a licensor, author or contributor be held liable for indirect,
direct, other damage, loss, or other issues arising in any way out
of dealing in the work, even if advised of the possibility of such
damage or existence of a defect, except proven that it results out
of said person's immediate fault when using the work as intended.


It includes an implementation of POSIX directory browsing functions
and types for Win32 under a Historical Permission Notice variant:

Copyright Kevlin Henney, 1997, 2003. All rights reserved.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose is hereby granted without fee, provided
that this copyright and permissions notice appear in all copies and
derivatives.

This software is supplied "as is" without express or implied warranty.

But that said, if there are any problems please get in touch.


The program shortcut (mkshicon1.ico) is an unregistered trademark:

Copyright (c) 2013 Michael Langguth
Copyright (c) 2006 Benny Siegert
Copyright (c) 2005 Thorsten Glaser

This icon may be used to refer to The MirBSD Korn Shell and
its Win32 port. Distribution patches are acceptable as long
as they modify $KSH_VERSION according to the guidelines that
are published on the website; forks and works that are not
derivatives are not allowed to use it.

The BSD daemon is Copyright (c) 1988 by Marshall Kirk McKusick.
All Rights Reserved.  Individuals may use the daemon for their
personal use within the bounds of good taste.  When reasonably
possible, the text shown above is to be included.

The Shilouette daemon is Copyright (c) 2003 by Rick Collette.
The MirOS Project may freely use the former ekkoBSD Logo,
the shilouette Daemon, for MirBSD, on anything the project
leader sees fit, so long as it pertains to MirBSD in some
way and the leader gives credit for the original daemon to
Marshall Kirk McKusick.

================
File: pki/easy-rsa/distro/windows/EasyRSA-Start.bat
================
@echo OFF
bin\sh.exe bin\easyrsa-shell-init.sh %*

================
File: pki/easy-rsa/distro/windows/README-Windows.txt
================
Easy-RSA 3 Windows README

Easy-RSA 3 runs POSIX shell code, so use on Windows has some additional
requirements: an OpenSSL installation, and a usable shell environment.

The Windows packages of EasyRSA 3.0.7+ include an OpenSSL binary and
libraries that will be used by default.  If you want to use a system binary
instead, remove the openssl.exe and the lib*.dll files from the bin
directory.

The Easy-RSA Windows release includes a ready-to-use shell
environment with special thanks to the mksh/Win32 project.

Contents of this file:
  1. OpenSSL
  2. shell environment
  3. Windows paths
  4. Appendix:
   4.1: reference links
   4.2: license of included components
  5. Special Thanks
   5.1: mksh/Win32

1. Getting a POSIX shell

   The binary release of Easy-RSA 3 comes bundled with the mksh/Win32 shell
   environment and a handful of shell utility programs from the unxutils
   project. This is the easiest way to get a usable shell environment.

   (A) Using the mksh/Win32 shell

       With the Windows binary Easy-RSA download, all the necessary utilities
       are already present. Starting a shell environment is accomplished by
       running the `EasyRSA Start.bat` file.

       A basic collection of shell utilities is included, such as ls, cat, mv,
       and so on. Additional programs can be manually installed from the
       unxutils project (link in appendix); this is intentionally a limited set
	   of programs since most Windows users will use native methods to perform
       filesystem manipulation.

   (B) Using a full POSIX environment (Advanced users only)

       An environment such as Cygwin can provide the necessary POSIX environment
       for the Easy-RSA shell code to run. However, Cygwin paths are not usable
       by native Win32 applications. This means that the OpenSSL installation
       used must also understand Cygwin paths or command calls will fail.
       Provided this requirement is met, Cygwin can directly run the easyrsa
       script without any special interpreter or startup wrapper.

2. Windows Paths

   The provided mksh/Win32 shell understands Windows paths. However, you MUST
   either:

   * Use forward slashes instead of single backslashes, or
   * Use double-backslashes.

   This means the following path formats are accepted:

    "C:/Program Files/OpenSSL-Win32/bin/openssl.exe"
    "C:\\Program Files\\OpenSSL-Win32\\bin\\openssl.exe"

   This is primarily to reference a functioning OpenSSL installation (see
   section 1 above) but applies to any other paths used in env-vars, the `vars`
   file, or in shell commands such as ls, cd, and so on.

3. Appendix

 3.1: Reference Links

   * OpenSSL website:
     https://www.openssl.org

   * OpenSSL binary distribution links:
     https://www.openssl.org/related/binaries.html

   * OpenSSL download page, built by "Shining Light Productions"
     http://slproweb.com/products/Win32OpenSSL.html

     NOTE: if using the "Shining Light Productions" version, the "Light"
     download is fine. 32 or 64-bit is also OK (if you have a 64-bit OS.)

   * UnxUtils project:
     http://sourceforge.net/projects/unxutils

 3.2: License of included components

      Text-format copies of these licenses are available in the Licensing/
      directory.

   (A) Easy-RSA 3 is released under a GPLv2 license:
       https://www.gnu.org/licenses/gpl-2.0.html

   (B) mksh/Win32 is under a MirOS license:
       https://www.mirbsd.org/MirOS-Licence.htm

       Additional library components of mksh/Win32 are covered under additional
       licenses. See Licensing/mksh-Win32.txt for details.

   (C) unxutils is released under a GPLv2 license
       The full source for this win32 port can be found here:
       http://sourceforge.net/projects/unxutils/

4. Special Thanks

 4.1: mksh/Win32

    A special thanks is in order to the mksh/Win32 project and its primary
    maintainer, Michael Langguth <mksh-w32@gmx.net>. This shell offers features
    that allow Easy-RSA to run smoothly under Windows; by using mksh/Win32,
    Easy-RSA can deliver the same PKI flexibility to all major platforms.

vim: wrap tw=80 expandtab

================
File: pki/easy-rsa/distro/README
================
This distro/ directory contains distro/platform specific tools.

Components that are not platform neutral end up here, sorted into further dirs
based on the platform.

================
File: pki/easy-rsa/doc/EasyRSA-Advanced.md
================
Easy-RSA Advanced Reference
=============================

This is a technical reference for advanced users familiar with PKI processes. If
you need a more detailed description, see the `EasyRSA-Readme` or `Intro-To-PKI`
docs instead.

Configuration Reference
-----------------------

#### Configuration Sources

  There are 3 possible ways to perform external configuration of Easy-RSA,
  selected in the following order where the first defined result wins:

  1. Command-line option
  2. Environmental variable
  3. 'vars' file, if one is present (see `vars Autodetection` below)
  4. Built-in default

  Note that not every possible config option can be set everywhere, although any
  env-var can be added to the 'vars' file even if it's not shown by default.

#### vars Autodetection

  A 'vars' file is a file named simply `vars` (without an extension) that
  Easy-RSA will source for configuration. This file is specifically designed
  *not* to replace variables that have been set with a higher-priority method
  such as CLI opts or env-vars.

  The following locations are checked, in this order, for a vars file. Only the
  first one found is used:

  1. The file referenced by the `--vars` CLI option
  2. The file referenced by the env-var named `EASYRSA_VARS_FILE`
  3. The directory referenced by the `--pki` CLI option (Recommended)
  4. The directory referenced by the `EASYRSA_PKI` env-var
  5. The directory referenced by the `EASYRSA` env-var
  6. The default PKI directory at `$PWD/pki` (See note below)
  7. The default working directory at `$PWD`

  Defining the env-var `EASYRSA_NO_VARS` will override the sourcing of the vars
  file in all cases, including defining it subsequently as a global option.

  Note: If the vars file `$PWD/pki/vars` is sourced then it is forbidden from
        setting/changing the current PKI, as defined by `EASYRSA_PKI` env-var.

#### Use of `--pki` verses `--vars`

  It is recommended to use option `--pki=DIR` to define your PKI at runtime.
  This method will always auto-load the `vars` file found in defined PKI.

  In a multi-PKI installation, use of `--vars` can potentially lead to
  a vars file that is configured to set a PKI which cannot be verified
  as the expected PKI. Use of `--vars` is not recommended.

#### OpenSSL Config

  Easy-RSA is tightly coupled to the OpenSSL config file (.cnf) for the
  flexibility the script provides. It is required that this file be available,
  yet it is possible to use a different OpenSSL config file for a particular
  PKI, or even change it for a particular invocation.

  The OpenSSL config file is searched for in the following order:

  1. The env-var `EASYRSA_SSL_CONF`
  2. The 'vars' file (see `vars Autodetection` above)
  3. The `EASYRSA_PKI` directory with a filename of `openssl-easyrsa.cnf`
  4. The `EASYRSA` directory with a filename of `openssl-easyrsa.cnf`

Advanced extension handling
---------------------------

Normally the cert extensions are selected by the cert type given on the CLI
during signing; this causes the matching file in the x509-types subdirectory to
be processed for OpenSSL extensions to add. This can be overridden in a
particular PKI by placing another x509-types dir inside the `EASYRSA_PKI` dir
which will be used instead.

The file named `COMMON` in the x509-types dir is appended to every cert type;
this is designed for CDP usage, but can be used for any extension that should
apply to every signed cert.

Additionally, the contents of the env-var `EASYRSA_EXTRA_EXTS` is appended with
its raw text added to the OpenSSL extensions. The contents are appended as-is to
the cert extensions; invalid OpenSSL configs will usually result in failure.

Advanced configuration files
----------------------------

The following files are used by Easy-RSA to configure the SSL library:
* openssl-easyrsa.cnf - Configuration for Certificate Authority [CA]
* x509-types: COMMON, ca, server, serverClient, client, codeSigning, email, kdc.
  Each type is used to define an X509 purpose.

Since Easy-RSA version 3.2.0, these files are created on-demand by each command
that requires them.  However, if these files are found in one of the supported
locations then those files are used instead, no temporary files are created.

The supported locations are listed, in order of preference, as follows:
* `EASYRSA_PKI` - Always preferred.
* `EASYRSA` - For Windows.
* `PWD` - For Windows.
* `easyrsa` script directory - DEPRECATED, will be removed. Only for Windows.
* `/usr/local/share/easy-rsa`
* `/usr/share/easy-rsa`
* `/etc/easy-rsa`

The files above can all be created by using command: `easyrsa write legacy <DIR>`
To OVER-WRITE any existing files use command: `eaysrsa write legacy-hard <DIR>`
`<DIR>` is optional, the default is `EASYRSA_PKI`. This will create the files in
the current PKI or `<DIR>`.  If created then these new files may take priority
over system wide versions of the same files.  See `help write` for further details.

Note, Over-writing files:
Only command `write legacy-hard` will over-write files. All other uses of `write`
will leave an existing file intact, without error. If you want to over-write an
existing file using `write` then you must redirect `>foo` the output manually.

Example command: `easyrsa write vars >vars` - This will over-write `./vars`.

Environmental Variables Reference
---------------------------------

A list of env-vars, any matching global option (CLI) to set/override it, and a
short description is shown below:

 *  `EASYRSA` - should point to the Easy-RSA top-level dir, where the easyrsa
    script is located.
 *  `EASYRSA_OPENSSL` - command to invoke openssl
 *  `EASYRSA_SSL_CONF` - the openssl config file to use
 *  `EASYRSA_PKI` (CLI: `--pki-dir`) - dir to use to hold all PKI-specific
    files, defaults to `$PWD/pki`.
 *  `EASYRSA_VARS_FILE` (CLI: `--vars`) - Set the `vars` file to use
 *  `EASYRSA_DN` (CLI: `--dn-mode`) - set to the string `cn_only` or `org` to
    alter the fields to include in the req DN
 *  `EASYRSA_REQ_COUNTRY` (CLI: `--req-c`) - set the DN country with org mode
 *  `EASYRSA_REQ_PROVINCE` (CLI: `--req-st`) - set the DN state/province with
    org mode
 *  `EASYRSA_REQ_CITY` (CLI: `--req-city`) - set the DN city/locality with org
    mode
 *  `EASYRSA_REQ_ORG` (CLI: `--req-org`) - set the DN organization with org mode
 *  `EASYRSA_REQ_EMAIL` (CLI: `--req-email`) - set the DN email with org mode
 *  `EASYRSA_REQ_OU` (CLI: `--req-ou`) - set the DN organizational unit with org
    mode
 *  `EASYRSA_REQ_SERIAL` (CLI: `--req-serial`) - set the DN serialNumber with
    org mode (OID 2.5.4.5)
 *  `EASYRSA_KEY_SIZE` (CLI: `--keysize`) - set the key size in bits to
    generate
 *  `EASYRSA_ALGO` (CLI: `--use-algo`) - set the crypto alg to use: rsa, ec or
    ed
 *  `EASYRSA_CURVE` (CLI: `--curve`) - define the named EC curve to use
 *  `EASYRSA_CA_EXPIRE` (CLI: `--days`) - set the CA expiration time in days
 *  `EASYRSA_CERT_EXPIRE` (CLI: `--days`) - set the issued cert expiration time
    in days
 *  `EASYRSA_CRL_DAYS` (CLI: `--days`) - set the CRL 'next publish' time in days
 *  `EASYRSA_NS_SUPPORT` (CLI: `--ns-cert`) - string 'yes' or 'no' fields to
    include the **deprecated** Netscape extensions
 *  `EASYRSA_NS_COMMENT` (CLI: `--ns-comment`) - string comment to include when
    using the **deprecated** Netscape extensions
 *  `EASYRSA_REQ_CN` (CLI: `--req-cn`) - default CN, can only be used in BATCH
    mode
 *  `EASYRSA_DIGEST` (CLI: `--digest`) - set a hash digest to use for req/cert
    signing
 *  `EASYRSA_BATCH` (CLI: `--batch`) - enable batch (no-prompt) mode; set
    env-var to non-zero string to enable (CLI takes no options)
 *  `EASYRSA_PASSIN` (CLI: `--passin`) - allows to specify a source for
    password using any openssl password options like pass:1234 or env:var
 *  `EASYRSA_PASSOUT` (CLI: `--passout`) - allows to specify a source for
    password using any openssl password options like pass:1234 or env:var
 *  `EASYRSA_NO_PASS` (CLI: `--nopass`) - disable use of passwords
 *  `EASYRSA_UMASK` - safe umask to use for file creation. Defaults to `077`
 *  `EASYRSA_NO_UMASK` - disable safe umask. Files will be created using the
    system's default
 *  `EASYRSA_TEMP_DIR` (CLI: `--tmp-dir`) - a temp directory to use for temporary files
**NOTE:** the global options must be provided before the commands.

================
File: pki/easy-rsa/doc/EasyRSA-Contributing.md
================
Easy-RSA 3 GitHub Contributions Documentation
=============================================

This document explains how to contribute to Easy-RSA 3.

Please follow these simple steps and make contributing easier.

Intended audience: Everyone.

Contributing Guide
------------------

-   **Do not** edit Easy-RSA `master` branch.

-   **Do not** edit Easy-RSA `master` branch.

    Pull Requests submitted from `master` branch may be squashed or rejected.

### Create a new branch:

-   Select a suitable name for the new branch. eg: `doc-contrib-typo`

    ```
    git checkout -b doc-contrib-typo
    ```

-   Make changes to the new branch.

    Please use tabs to indent the code but only use tabs at the beginning of
    the line.

-   Review the changes:

    ```
    git diff
    ```

-   Stage the changes:

    ```
    git add -A
    ```

-   Show the extent of the changes:

    ```
    git status -v
    ```

-   Commit the changes:

    ```
    git commit -sS
    ```

    Please write a detailed commit message.

    github `help` has details of creating a private key.

    Using github `no-reply` email address is suitable for the `Signed-off-by:`
    line.

-   Push the changes:

    ```
    git push origin doc-contrib-typo
    ```

-   Share the changes:

    ```
    Raise a Pull Request on github.
    ```

Keeping your fork synchronised
-----------------------------

-   Configure the `upstream` remote for your fork:

    ```
    git remote add upstream https://github.com/OpenVPN/easy-rsa.git
    ```

-   Verify the remote sources:

    ```
    git remote -v
    ```

    Remote `origin` will have **your** repository:

    ```
    origin https://github.com/TinCanTech/easy-rsa.git (fetch)
    origin https://github.com/TinCanTech/easy-rsa.git (push)
    ```

    Remote `upstream` will be `Openvpn/easy-rsa`:

    ```
    upstream https://github.com/Openvpn/easy-rsa.git (fetch)
    upstream https://github.com/Openvpn/easy-rsa.git (push)
    ```

### Synchronising your fork:

-   Select `master` branch:

    ```
    git checkout master
    ```

-   Fetch changes in `upstream`:

    ```
    git fetch upstream
    ```

-   Merge changes in `upstream`:

    ```
    git merge upstream/master
    ```

-   Update your fork on github:

    ```
    git push
    ```


    Your fork is now synchronised.

================
File: pki/easy-rsa/doc/EasyRSA-Readme.md
================
Easy-RSA 3 Documentation Readme
===============================

This document explains how Easy-RSA 3 and each of its assorted features work.

If you are looking for a quickstart with less background or detail, an
implementation-specific How-to or Readme may be available in this (the [`doc/`](./))
directory.

Easy-RSA Overview
-----------------

Easy-RSA is a utility for managing X.509 PKI, or Public Key Infrastructure. A
PKI is based on the notion of trusting a particular authority to authenticate a
remote peer; for more background on how PKI works, see the [Intro-To-PKI](Intro-To-PKI.md)
document.

The code is written in platform-neutral POSIX shell, allowing use on a wide
range of host systems. The official Windows release also comes bundled with the
programs necessary to use Easy-RSA. The shell code attempts to limit the number
of external programs it depends on. Crypto-related tasks use openssl as the
functional backend.

Feature Highlights
------------------

Here's a non-exhaustive list of the more notable Easy-RSA features:

 *  Easy-RSA is able to manage multiple PKIs, each with their own independent
    configuration, storage directory, and X.509 extension handling.
 *  Multiple Subject Name (X.509 DN field) formatting options are supported. For
    VPNs, this means a cleaner commonName only setup can be used.
 *  A single backend is used across all supported platforms, ensuring that no
    platform is 'left out' of the rich features. Unix-alikes (BSD, Linux, etc)
    and Windows are all supported.
 *  Easy-RSA's X.509 support includes CRL, CDP, keyUsage/eKu attributes, and
    additional features. The included support can be changed or extended as an
    advanced feature.
 *  Interactive and automated (batch) modes of operation
 *  Flexible configuration: features can be enabled through command-line
    options, environment variables, a config file, or a combination of these.
 *  Built-in defaults allow Easy-RSA to be used without first editing a config
    file.

Obtaining and Using Easy-RSA
----------------------------

#### Download and extraction (installation)

  Easy-RSA's main program is a script, supported by a couple of config files. As
  such, there is no formal "installation" required. Preparing to use Easy-RSA is
  as simple as downloading the compressed package (.tar.gz for Linux/Unix or
  .zip for Windows) and extract it to a location of your choosing. There is no
  compiling or OS-dependent setup required.

  You should install and run Easy-RSA as a non-root (non-Administrator) account
  as root access is not required.

#### Running Easy-RSA

  Invoking Easy-RSA is done through your preferred shell. Under Windows, you
  will use the `EasyRSA Start.bat` program to provide a POSIX-shell environment
  suitable for using Easy-RSA.

  The basic format for running commands is:

    ./easyrsa command [ cmd-opts ]

  where `command` is the name of a command to run, and `cmd-opts` are any
  options to supply to the command. Some commands have mandatory or optional
  cmd-opts. Note the leading `./` component of the command: this is required in
  Unix-like environments and may be a new concept to some Windows users.

  General usage and command help can be shown with:

    ./easyrsa help [ command ]

  When run without any command, general usage and a list of available commands
  are shown; when a command is supplied, detailed help output for that command
  is shown.

Configuring Easy-RSA
--------------------

Easy-RSA 3 no longer needs any configuration file prior to operation, unlike
earlier versions. However, the `vars.example` file contains many commented
options that can be used to control non-default behavior as required. Reading
this file will provide an idea of the basic configuration available. Note that
a vars file must be named just `vars` (without an extension) to actively use it.

Additionally, some options can be defined at runtime with options on the
command-line. A full list can be shown with:

    ./easyrsa help options

Any of these options can appear before the command as required as shown below:

    ./easyrsa [options] command [ cmd-opts ]

For experts, additional configuration with env-vars and custom X.509 extensions
is possible. Consult the [EasyRSA-Advanced](EasyRSA-Advanced.md) documentation for details.

Getting Started: The Basics
---------------------------

Some of the terms used here will be common to those familiar with how PKI works.
Instead of describing PKI basics, please consult the document [Intro-To-PKI](Intro-To-PKI.md) if
you need a more basic description of how a PKI works.

#### Creating an Easy-RSA PKI

  In order to do something useful, Easy-RSA needs to first initialize a
  directory for the PKI. Multiple PKIs can be managed with a single installation
  of Easy-RSA, but the default directory is called simply "pki" unless otherwise
  specified.

  To create or clear out (re-initialize) a new PKI, use the command:

    ./easyrsa init-pki

  which will create a new, blank PKI structure ready to be used. Once created,
  this PKI can be used to make a new CA or generate keypairs.

#### The PKI Directory Structure

  An Easy-RSA PKI contains the following directory structure:

  * `private/` - dir with private keys generated on this host
  * `reqs/` - dir with locally generated certificate requests (for a CA imported
    requests are stored here)

  In a clean PKI no files exist yet, just the bare directories. Commands called
  later will create the necessary files depending on the operation.

  When building a CA, a number of new files are created by a combination of
  Easy-RSA and (indirectly) openssl. The important CA files are:

  * `ca.crt` - This is the CA certificate
  * `index.txt` - This is the "master database" of all issued certs
  * `serial` - Stores the next serial number (serial numbers increment)
  * `private/ca.key` - This is the CA private key (security-critical)
  * `certs_by_serial/` - dir with all CA-signed certs by serial number
  * `issued/` - dir with issued certs by commonName

#### After Creating a PKI

  Once you have created a PKI, the next useful step will be to either create a
  CA, or generate keypairs for a system that needs them. Continue with the
  relevant section below.

Using Easy-RSA as a CA
----------------------

#### Building the CA

  In order to sign requests to produce certificates, you need a CA. To create a
  new CA in the PKI you have created, run:

    ./easyrsa build-ca

  Be sure to use a strong passphrase to protect the CA private key. Note that
  you must supply this passphrase in the future when performing signing
  operations with your CA, so be sure to remember it.

  During the creation process, you will also select a name for the CA called the
  Common Name (CN.) This name is purely for display purposes and can be set as
  you like.

#### Importing requests to the CA

  Once a CA is built, the PKI is intended to be used to import requests from
  external systems that are requesting a signed certificate from this CA. In
  order to sign the request, it must first be imported so Easy-RSA knows about
  it. This request file must be a standard CSR in PKCS#10 format.

  Regardless of the file name to import, Easy-RSA uses a "short name" defined
  during import to refer to this request. Importing works like this:

    ./easyrsa import-req /path/to/request.req nameOfRequest

  The nameOfRequest should normally refer to the system or person making the
  request.

#### Signing a request

  Once Easy-RSA has imported a request, it can be reviewed and signed:

    ./easyrsa sign-req <type> nameOfRequest

  Every certificate needs a `type` which controls what extensions the certificate
  gets.

  Easy-RSA ships with 4 possible "types":

  * `client` - A TLS client, suitable for a VPN user or web browser (web client)
  * `server` - A TLS server, suitable for a VPN or web server
  * `ca` - A intermediate CA, used when chaining multiple CAs together
  * `serverClient` - A TLS server and TLS client

  Additional types of certs may be defined by local sites as needed; see the
  advanced documentation for details.

#### Revoking and publishing Certificate Revocation Lists (CRLs)

  If an issue certificate needs to be revoked, this can be done as follows:

    ./easyrsa revoke nameOfRequest

  To generate a CRL suitable for publishing to systems that use it, run:

    ./easyrsa gen-crl

  Note that this will need to be published or sent to systems that rely on an
  up-to-date CRL as the certificate is still valid otherwise.

Using Easy-RSA to generate keypairs & requests
----------------------------------------------

Easy-RSA can generate a keypair and certificate request in PKCS#10 format. This
request is what a CA needs in order to generate and return a signed certificate.

Ideally you should never generate entity keypairs for a client or server in a
PKI you are using for your CA. It is best to separate this process and generate
keypairs only on the systems you plan to use them.

Easy-RSA can generate a keypair and request with the following command:

    ./easyrsa gen-req nameOfRequest

You will then be given a chance to modify the Subject details of your request.
Easy-RSA uses the short name supplied on the command-line by default, though you
are free to change it if necessary. After providing a passphrase and Subject
details, the keypair and request files will be shown.

In order to obtain a signed certificate, the request file must be sent to the
CA for signing; this step is obviously not required if a single PKI is used as
both the CA and keypair/request generation as the generated request is already
"imported."

================
File: pki/easy-rsa/doc/EasyRSA-Renew-and-Revoke.md
================
Easy-RSA 3 Certificate Renewal and Revocation Documentation
===========================================================

This document explains how the **differing versions** of Easy-RSA 3 work
with regard to Renewal and Revocation of Certificates.

## In summary:

**Easy-RSA Version 3.1.7** provides the most flexible support of renewal.
This includes command `rewind-renew`, which is required to recover certificates
renewed by `renew` command version 1. However, this does **not** include renewing
any supported certificate attributes.

**Easy-RSA Version 3.2.1** is preferred for future support.

----

Reason codes available for revoke commands
------------------------------------------

The follow is an exhaustive list of available `reason` codes, with abbreviations:

- `us | uns* | unspecified`
- `kc | key* | keyCompromise`
- `cc | ca*  | CACompromise`
- `ac | aff* | affiliationChanged`
- `ss | sup* | superseded`
- `co | ces* | cessationOfOperation`
- `ch | cer* | certificateHold`

  `reason` must be one of these abbreviations/codes, otherwise not be used.

----

Easy-RSA version 3.2.x
======================
For **Easy-RSA Version 3.2.0**, command `renew` is NOT supported.

Please upgrade to Easy-RSA Version 3.2.1

For **Easy-RSA Version 3.2.1+**, command `renew` is supported.

The command `renew` has been rewritten and now supports the renewal of
supported attributes. During renewal, the certificate is inspected and all
supported attributes are applied to the renewed certificate, as they were
in the original.

User added attributes from `$EASYRSA_EXTRA_EXTS`, that are not supported,
are dropped.

If the renewed certificate requires unsupported attibutes or changing the
`commonName` then the following process, that of expiry and then signing a
new certificate from the original request file, is required.

The expiry and signing process is as follows:
1. Command `expire <NAME>`

   This will move an existing certificate from `pki/issued` to `pki/expired`,
   so that a new certificate can be signed, using the original request.

   Generally, renewing is required ONLY when a certificate is due to expire.
   This means that certificates moved to `pki/expired` are expected to be expired
   or to expire in the near future, however, this is not a requirement.

2. Command `sign-req <TYPE> <NAME>`

   Sign a new certificate. This allows ALL command line customisations to be used.

3. If required, command `revoke-expired` can be used to revoke an
   expired certificate in the `pki/expired` directory.

This approach allows original certificates, which have been edited during `sign-req`,
to be edited the same way.

----

Easy-RSA version 3.1.x
======================

Command Details: `renew`
------------------------

    easyrsa renew file-name-base [ cmd-opts ]

`renew` is **only** available since Easy-RSA version `3.0.6`

#### `renew` has three different versions:

 *  `renew` **Version 1**: Easy-RSA versions `3.0.6`, `3.0.7` and `3.0.8`.
    - Both certificate and private key are rebuilt.
    - Once a certificate has been renewed it **cannot** be revoked.

 *  `renew` **Version 2**: Easy-RSA versions `3.0.9` and `3.1.0`.
    - Both certificate and private key are rebuilt.
    - Once a certificate has been renewed it **can** be revoked.
    - Use command:

        `revoke-renewed file-name-base [ reason ]`

 *  `renew` **Version 3**: Easy-RSA versions `3.1.1` through `3.1.7`.
    - Only certificate is renewed.
    - The original `renew` command has been renamed to `rebuild`, which
      rebuilds both certificate and private key.

 *  `renew` **Version 4**: Easy-RSA version `3.2.0+`.
    - Only certificate is renewed.
    - Supports standard Easy-RSA X509 extension duplication.


Resolving issues with `renew` version 1
---------------------------------------

#### Upgrade Easy-RSA to version `3.1.1+` is required.

`renew` version 1 **rebuilds** the certificate and private key.

Once a certificate has been renewed by version 1, the files are saved in the
`renewed/` storage area by `serialNumber`. These files must be recovered by
using command:

    easyrsa rewind-renew serialNumber

Command `rewind-renew` is only available in Easy-RSA version `3.1.1` to `3.1.7`.

Once `rewind-renew` has recovered the files, the certificate can be revoked:

    easyrsa revoke-renewed file-name-base [ reason ]


Using `renew` version 2
-----------------------

#### Upgrade Easy-RSA to version `3.1.1+` is required.

`renew` version 2 **rebuilds** the certificate and private key.

Renewed certificate can be revoked:

    easyrsa revoke-renewed file-name-base [ reason ]


Using `renew` version 3
-----------------------

#### Upgrade Easy-RSA to version `3.1.1+` is required.

`renew` version 3 **renews** the certificate only.

Renewed certificate can be revoked:

    easyrsa revoke-renewed file-name-base [ reason ]

This is the preferred method to renew a certificate because the original
private key is still valid.

Using `renew` version 4
-----------------------

#### Upgrade Easy-RSA to version `3.2.0+` is required.

This is the most comprensive version of `renew`, which supports automatic
copying of Easy-RSA X509 extensions.


----

Easy-RSA Reporting tools for certificate status
-----------------------------------------------

Easy-RSA version `3.1.x`, also has the following tools to keep track of
certificate status:

    easyrsa [ --days=# ] show-expire [ file-name-base ]

  `show-expire` shows all certificates which will expire in given `--days`.

    easyrsa show-renew [ file-name-base ]

  `show-renew` shows all certificates which have been renewed, where the old
  certificate has not been revoked.

    easyrsa show-revoke [ file-name-base ]

  `show-revoke` shows all certificates which have been revoked.

----

About command `rebuild`
-----------------------

If `rebuild` is used then the output directory of old certificate, key and
request is also the `renewed` directory.  Use **`revoke-renewed`** to revoke
an old certificate/key pair, which has been _rebuilt_ by command `rebuild`.

----

Renew CA Certificate
====================

Easy-RSA Version `3.2.2+ includes command `renew-ca`, which will create a new
CA certificate using the original CA key.  This new certificate will completely
replace the previous CA certificate.  This command can be safely tested without
disturbing your current PKI. The command requires user confirmation before
installing the new CA certificate.  The old CA certificate is archived to the
file 'pki/expired-ca.list'.


Easy-RSA Version `3.2.1+` supports a simple way to effectively renew a CA Certificate.

**Preamble** - Specifically for use with OpenVPN:

When a CA certificate expires it must be replaced, this is unavoidable.
No matter what method is used to create a new or renewed CA certificate,
that CA certificate must be distributed to all of your servers and clients.

Please consider the method outlined here, which requires very little work:

1. **Before you do anything else -- Make a BACKUP of your current PKI.**

2. Use command `init-pki soft`

   This will reset your current PKI but will keep your `vars` setting file
   and your current Request files [CSR], in the `pki/reqs` directory.

   If you have an Easy-RSA generated TLS key for OpenVPN, that will also be
   preserved. However, it will NOT be used for new `inline` files. The file
   `pki/private/easyrsa-tls.key` will be moved to `pki/easyrsa-keepsafe-tls.key`,
   for safe keeping. Easy-RSA will display a warning that this key is still
   valid and possibly in use, before allowing another TLS key to be generated.

3. Use command `build-ca`

   (With or without password and other preferences)

   This will build a completely new CA Certificate and private key.

   Use option `--days` to extend the lifetime of your new CA.

4. Use command `sign-req <TYPE> <NAME>`

   (With or without other preferences, password is not relevant)

   This will use an existing Request to sign a new Certificate.

   This will NOT generate a new Private Key for each new Certificate.

   This will generate new `inline` files that can be distributed publicly.
   These `inline` files will not contain any security sensitive data.

   This means that you will have a new CA certificate and private key.
   And signed certificates for all of your users, including servers.

5. Distribute the new `inline` files to all members of your PKI/VPN.

   These new `inline` files will not contain the user private key or the
   OpenVPN Pre-shared TLS key.

   These new `inline` files can be used by OpenVPN, examples below:

   * specify: `--config <INLNE-FILE>` in the OpenVPN user config file.
   * Use copy/paste to add the new details to the OpenVPN user config file.
   * Use `cat` to append the `inline` file to the OpenVPN user config file.

   Note:
   `inline` files in the `pki/inline/private` directory include security keys,
   which MUST only be transmitted over a secure connection, such as `https`.

================
File: pki/easy-rsa/doc/EasyRSA-Upgrade-Notes.md
================
Upgrading to Easy-RSA 3 from earlier versions
=========

People upgrading to Easy-RSA 3 from a 2.x version should note some important
changes starting with version 3. For a better overview of version 3 in general,
see the Readme in the doc/ directory.

Easy-RSA 3 comes with an automated upgrade utility to convert an existing 2.x
PKI to version 3. For details, see [this article on the OpenVPN
wiki](https://community.openvpn.net/openvpn/wiki/easyrsa-upgrade).

List of important changes
----

 * nsCertType extensions are no longer included by default. Use of such
   "Netscape" attributes have been deprecated upstream and their use is
   discouraged. Configure `EASYRSA_NS_SUPPORT` in vars if you want to enable
   this legacy behavior.

   Notably, this is important for OpenVPN deployments relying on the
   `--ns-cert-type` directive. Either have OpenVPN use the preferred
   `--remote-cert-tls` option, or enable legacy NS extensions.

 * The default request Subject (or DN, Distinguished Name) includes just the
   commonName. This is more suitable for VPNs and environments that don't wish
   to include info about the Country/State/City/Org/OU in certs. Configure
   `EASYRSA_DN` in vars if you want to enable the legacy behavior.

 * The 3.0 release lacks PKCS#11 (smartcard/token) support. This is anticipated
   to be supported in a future point-release to target each platform's need.

 * The -utf8 option has been added for all supported commands.  This should be
   backwards compatible with ASCII strings.

 * The default private key encryption has been changed from 3des to aes256.


Some new concepts
----

Easy-RSA 3 has some new concepts compared to the prior v2 series.

### Request-Import-Sign workflow

  v3 is now designed to support keypairs generated on the target system where
  they will be used, thus improving security as no keys need to be transferred
  between hosts. The old workflow of generating everything in a single PKI is
  still supported as well.

  The recommended workflow when using Easy-RSA as a CA is to import requests,
  sign them, and return the issued & CA certs. Each requesting system can use
  Easy-RSA without a CA to generate keypairs & requests.

### "Org"-style DN flexibility

  When using Easy-RSA in the "org" DN mode, it is no longer required to match
  some of the field values. This improves flexibility, and enables easier remote
  generation as the requester doesn't need to know the CA's values in advance.

  Previously in v2, the Country, State, and Org values all had to match or a
  request couldn't be signed. If you want the old behavior you can change the
  OpenSSL config to require it or simply look over the DN at signing time.

================
File: pki/easy-rsa/doc/Hacking.md
================
Easy-RSA 3 Hacking Guide
===

This document is aimed at programmers looking to improve on the existing
codebase.

Compatibility
---

The `easyrsa` code is written in POSIX shell (and any cases where it is not is
considered a bug to be fixed.) The only exceptions are the `local` keyword and
the construct `export FOO=baz`, both well-supported.

As such, modifications to the code should also be POSIX; platform-specific code
should be placed under the `distro/` dir and listed by target platform.

Coding conventions
---

While there aren't strict syntax standards associated with the project, please
follow the existing format and flow when possible; however, specific exceptions
can be made if there is a significant reason or benefit.

Do try to:

  * Keep variables locally-scoped when possible
  * Comment sections of code for readability
  * Use the conventions for prefixes on global variables
  * Set editors for tab stops of 8 spaces
  * Use tabs for code indents; use aligned spaces for console text

Keeping code, docs, and examples in sync
---

Changes that adjust, add, or remove features should have relevant docs, help
output, and examples updated at the same time.

Release versioning
---

A point-release bump (eg: 3.0 to 3.1) is required when the frontend interface
changes in a non-backwards compatible way. Always assume someone has an
automated process that relies on the current functionality for official
(non-beta, non-rc) releases. A possible exception exists for bugfixes that do
break backwards-compatibility; caution is to be used in such cases.

The addition of a new command may or may not require a point-release depending
on the significance of the feature; the same holds true for additional optional
arguments to commands.

Project layout
---

The project's files are structured as follows:

  * `easyrsa3/` is the primary project code. On Linux/Unix-alikes, all the core
    code and supporting files are stored here.
  * `Licensing/` is for license docs.
  * `build/` is for build information and scripts.
  * `contrib/` is for externally-contributed files, such as useful external
    scripts or interfaces for other systems/languages.
  * `distro/` is for distro-specific supporting files, such as the Windows
    frontend wrappers. Code components that are not platform-neutral should go
    here.
  * `doc/` is for documentation. Much of this is in Markdown format which can be
    easily converted to HTML for easy viewing under Windows.
  * `release-keys/` list current and former KeyIDs used to sign release packages
    (not necessarily git tags) available for download.
  * The top-level dir includes files for basic project info and reference
    appropriate locations for more detail.

As a brief note, it is actually possible to take just the easyrsa3/ dir and end
up with a functional project; the remaining structure includes docs, build prep,
distro-specific wrappers, and contributed files.

Git conventions
---

As of Easy-RSA 3, the following git conventions should be used. These are mostly
useful for people with repo access in order to keep a standard meaning to commit
messages and merge actions.

### Signed-off-by: and related commit message lines

  Committers with push access should ensure a `Signed-off-by:` line exists at
  the end of the commit message with their name on it. This indicates that the
  committer has reviewed the changes to the commit in question and approve of
  the feature and code in question. It also helps verify the code came from an
  acceptable source that won't cause issues with the license.

  This can be automatically added by git using `git commit -s`.

  Additional references can be included as well. If multiple people reviewed the
  change, the committer may add their names in additional `Signed-off-by:`
  lines; do get permission from that person before using their name, however ;)

  The following references may be useful as well:

  * `Signed-off-by:` -- discussed above, indicates review of the commit
  * `Author:` -- references an author of a particular feature, in full or
    significant part
  * `Changes-by:` -- indicates the listed party contributed changes or
    modifications to a feature
  * `Acked-by:` -- indicates review of the feature, code, and/or functional
    correctness

### Merging from external sources (forks, patches, etc)

  Contributions can come in many forms: GitHub "pull requests" from cloned
  repos, references to external repos, patches to the ML, or others. Those won't
  necessarily have `Signed-off-by:` lines or may contain less info in the commit
  message than is desirable to explain the changes.

  The committing author to this project should make a merge-commit in this case
  with the appropriate details provided there. If additional code changes are
  necessary, this can be done on a local branch prior to merging back into the
  mainline branch.

  This merge-commit should list involved contributors with `Author:` or similar
  lines as required. The individual commits involved in a merge also retain the
  original committer; regardless, the merge-commit message should give a clear
  indication of what the entire set of commits does as a whole.

### Tagging

  Tags should follow the convention:

    vM.m.p

  where `M` is the major version, `m` is the minor "point-release" version, and
  `p` is the patch-level. Suffixes of `-rc#`, `-beta#`, etc can be added for
  pre-release versions as required.

  Currently tags are taken from the mainline development branch in question. The
  ChangeLog should thus be updated prior to tagging. Tags should also be
  annotated with an appropriate commit message and signed-off. This can be done
  as shown below (don't use `-s` unless you intend to use GPG with git.)

    git tag -a v1.2.3

  Corresponding release downloads can be uploaded to release distribution points
  as required.

================
File: pki/easy-rsa/doc/Intro-To-PKI.md
================
Introduction to PKI
===================

This document is designed to give you a brief introduction into how a PKI, or
Public Key Infrastructure, works.

Terminology Used
----------------

To avoid confusion, the following terms will be used throughout the Easy-RSA
documentation. Short forms may be substituted for longer forms as convenient.

 *  **PKI**: Public Key Infrastructure. This describes the collection of files
    and associations between the CA, keypairs, requests, and certificates.
 *  **CA**: Certificate Authority. This is the "master cert" at the root of a
    PKI.
 *  **cert**: Certificate. A certificate is a request that has been signed by a
    CA. The certificate contains the public key, some details describing the
    cert itself, and a digital signature from the CA.
 *  **request**: Certificate Request (optionally 'req'.) This is a request for a
    certificate that is then sent to a CA for signing. A request contains the
    desired cert information along with a digital signature from the private
    key.
 *  **keypair**: A keypair is an asymmetric cryptographic pair of keys. These
    keys are split into two parts: the public and private keys. The public key
    is included in a request and certificate.

The CA
------

The heart of a PKI is the CA, or Certificate Authority, and this is also the
most security-sensitive. The CA private key is used to sign all issued
certificates, so its security is critical in keeping the entire PKI safe. For
this reason, it is highly recommended that the CA PKI structure be kept on a
system dedicated for such secure usage; it is not a great idea to keep the CA
PKI mixed in with one used to generate end-entity certificates, such as clients
or servers (VPN or web servers.)

To start a new PKI, the CA is first created on the secure environment.
Depending on security needs, this could be managed under a locked down account,
dedicated system, or even a completely offline system or using removable media
to improve security (after all, you can't suffer an online break-in if your
system or PKI is not online.) The exact steps to create a CA are described in a
separate section. When creating a new CA, the CA keypair (private and public
keys) are created, as well as the file structure necessary to support signing
issued certificates.

Once a CA has been created, it can receive certificate requests from
end-entities. These entity certificates are issued to consumers of X509
certificates, such as a client or server of a VPN, web, or email system.  The
certificate requests and certificates are not security-sensitive, and can be
transferred in whatever means convenient, such as email, flash drive, etc. For
better security, it is a good idea to verify the received request matches the
sender's copy, such as by verifying the expected checksum against the sender's
original.

Keypairs and requests
---------------------

Individual end-entities do not need a full CA set up and will only need to
create a keypair and associated certificate request. The private key is not used
anywhere except on this entity, and should never leave that system. It is wise
to secure this private key with a strong passphrase, because if lost or stolen
the holder of the private key can make connections appearing as the certificate
holder.

Once a keypair is generated, the certificate request is created and digitally
signed using the private key. This request will be sent to a CA for signing, and
a signed certificate will be returned.

How requests become certificates
--------------------------------

After a CA signs the certificate request, a signed certificate is produced. In
this step, the CA's private key is used to digitally sign the entity's public
key so that any system trusting the CA certificate can implicitly trust the
newly issued certificate. This signed certificate is then sent back to the
requesting entity. The issued certificate is not security-sensitive and can be
sent over plaintext transmission methods.

Verifying an issued certificate
-------------------------------

After 2 entities have created keypairs, sent their requests to the CA, and
received a copy of their signed certificates and the CA's own certificate, they
can mutually authenticate with one-another. This process does not require the 2
entities to have previously exchanged any kind of security information directly.

During a TLS handshake each side of the connection presents their own cert chain
to the remote end. Each side checks the validity of the cert received against
their own copy of the CA cert. By trusting the CA root cert, the peer they are
talking to can be authenticated.

The remote end proves it "really is" the entity identified by the cert by
signing a bit of data using its own private key. Only the holder of the private
key is able to do this, allowing the remote end to verify the authenticity of
the system being connected to.

================
File: pki/easy-rsa/doc/TODO
================
Easy-RSA 3 TODO / wishlist

Feature support:
    * makefile
        * It may be useful to port the Makefile from the 2.x series
        * This may be desirable for building and downstream packaging
    * add pkcs11 support
        * Much of this may be distro-dependent
        * Keep platform-specific tools separate from platform-neutral code
    * add detection for duplicate CN prior to OpenSSL failure
        * This gets tricky if `updatedb` requires a CA passphrase
    * It would help to warn users before OpenSSL throws errors

Longer term wishlist:
    * Support openssl's -password source mechanism:
        * allow for batching currently "unbatchable" operations, like pkcs12
        * support one password input that can apply to multiple operations
        * support a variety of password sources (interactive, pipe, file, etc)

================
File: pki/easy-rsa/easyrsa3/x509-types/ca
================
# X509 extensions for a ca

# Note that basicConstraints will be overridden by Easy-RSA when defining a
# CA_PATH_LEN for CA path length limits. You could also do this here
# manually as in the following example in place of the existing line:
#
# basicConstraints = CA:TRUE, pathlen:1

basicConstraints = CA:TRUE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always
keyUsage = cRLSign, keyCertSign

================
File: pki/easy-rsa/easyrsa3/x509-types/client
================
# X509 extensions for a client

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = clientAuth
keyUsage = digitalSignature

================
File: pki/easy-rsa/easyrsa3/x509-types/code-signing
================
# X509 extensions for a client

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = codeSigning
keyUsage = digitalSignature

================
File: pki/easy-rsa/easyrsa3/x509-types/COMMON
================
# X509 extensions added to every signed cert

# This file is included for every cert signed, and by default does nothing.
# It could be used to add values every cert should have, such as a CDP as
# demonstrated in the following example:

#crlDistributionPoints = URI:http://example.net/pki/my_ca.crl

# The authority information access extension gives details about how to access
# certain information relating to the CA.

#authorityInfoAccess = caIssuers;URI:http://example.net/pki/my_ca.crt

================
File: pki/easy-rsa/easyrsa3/x509-types/email
================
# X509 extensions for email

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = emailProtection
keyUsage = digitalSignature,keyEncipherment,nonRepudiation

================
File: pki/easy-rsa/easyrsa3/x509-types/kdc
================
# X509 extensions for a KDC server certificate

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = 1.3.6.1.5.2.3.5
keyUsage = nonRepudiation,digitalSignature,keyEncipherment,keyAgreement
issuerAltName = issuer:copy
subjectAltName = otherName:1.3.6.1.5.2.2;SEQUENCE:kdc_princ_name

[kdc_princ_name]
realm = EXP:0,GeneralString:${ENV::EASYRSA_KDC_REALM}
principal_name = EXP:1,SEQUENCE:kdc_principal_seq

[kdc_principal_seq]
name_type = EXP:0,INTEGER:1
name_string = EXP:1,SEQUENCE:kdc_principals

[kdc_principals]
princ1 = GeneralString:krbtgt
princ2 = GeneralString:${ENV::EASYRSA_KDC_REALM}

================
File: pki/easy-rsa/easyrsa3/x509-types/server
================
# X509 extensions for a server

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = serverAuth
keyUsage = digitalSignature,keyEncipherment

================
File: pki/easy-rsa/easyrsa3/x509-types/serverClient
================
# X509 extensions for a client/server

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = serverAuth,clientAuth
keyUsage = digitalSignature,keyEncipherment

================
File: pki/easy-rsa/easyrsa3/easyrsa
================
#!/bin/sh

# Easy-RSA 3 -- A Shell-based CA Utility
#
# Copyright (C) 2024 - The Open-Source OpenVPN development community.
# A full list of contributors can be found on Github at:
#   https://github.com/OpenVPN/easy-rsa/graphs/contributors
#
# This code released under version 2 of the GNU GPL; see COPYING
# and the Licensing/ directory of this project for full licensing
# details.

# Help/usage output to stdout
usage() {
	# command help:
	information "
Easy-RSA 3 usage and overview

$easyrsa_help_title

To get detailed usage and help for a command, use:
  ./easyrsa help COMMAND

For a list of global-options, use:
  ./easyrsa help options

For a list of utility commands, use:
  ./easyrsa help util

A list of commands is shown below:
  init-pki [ cmd-opts ]
  self-sign-server <file_name_base> [ cmd-opts ]
  self-sign-client <file_name_base> [ cmd-opts ]
  build-ca [ cmd-opts ]
  gen-dh
  gen-req <file_name_base> [ cmd-opts ]
  sign-req <type> <file_name_base> [ cmd-opts ]
  build-client-full <file_name_base> [ cmd-opts ]
  build-server-full <file_name_base> [ cmd-opts ]
  build-serverClient-full <file_name_base> [ cmd-opts ]
  inline <file_name_base>
  expire <file_name_base>
  renew-ca
  renew <file_name_base>
  revoke <file_name_base> [ cmd-opts ] #(DEPRECATED)
  revoke-issued <file_name_base> [ cmd-opts ] #(REPLACEMENT)
  revoke-expired <file_name_base> [ cmd-opts ]
  revoke-renewed <file_name_base> [ cmd-opts ]
  gen-crl
  update-db
  show-req <file_name_base> [ cmd-opts ]
  show-cert <file_name_base> [ cmd-opts ]
  show-ca [ cmd-opts ]
  show-crl
  verify-cert <file_name_base>
  import-req <request_file_path> <short_name_base>
  export-p1 <file_name_base> [ cmd-opts ]
  export-p7 <file_name_base> [ cmd-opts ]
  export-p8 <file_name_base> [ cmd-opts ]
  export-p12 <file_name_base> [ cmd-opts ]
  set-pass <file_name_base> [ cmd-opts ]
  gen-tls-auth-key / gen-tls-crypt-key
  write <type> [ cmd-opts ]"

	# collect/show dir status:
	text_only=1
	work_dir="${EASYRSA:-undefined}"
	pki_dir="${EASYRSA_PKI:-undefined}"

	# check for vars changing PKI unexpectedly!
	if [ "$invalid_vars" ]; then
		ivmsg="
   *WARNING*: \
Invalid vars setting for EASYRSA and/or EASYRSA_PKI${NL}"
	else
		unset -v ivmsg
	fi

	# Print details
	information "
DIRECTORY STATUS (commands would take effect on these locations)
     EASYRSA: $work_dir
         PKI: $pki_dir
   vars-file: ${EASYRSA_VARS_FILE:-Missing or undefined}${ivmsg}"

	# CA Status
	if verify_ca_init test; then
		if [ -z "$EASYRSA_SILENT" ]; then
			# Show SSL output directly, with easyrsa header
			printf '%s' "   CA status: OK${NL}${NL}    "
			"$EASYRSA_OPENSSL" x509 -in "$EASYRSA_PKI/ca.crt" \
				-noout -subject -nameopt utf8,multiline
			print "" # for a clean line
		fi
	else
		information "   CA status: CA has not been built${NL}"
	fi

	# verbose info
	verbose "ssl-cnf: ${EASYRSA_SSL_CONF:-built-in}"
	verbose "x509-types: ${EASYRSA_EXT_DIR:-built-in}"
	if [ -d "$EASYRSA_TEMP_DIR" ]; then
		verbose "temp-dir: Found: $EASYRSA_TEMP_DIR"
	else
		verbose "temp-dir: Missing: ${EASYRSA_TEMP_DIR:-undefined}"
	fi
} # => usage()

# Detailed command help
# When called with no args, calls usage(),
# otherwise shows help for a command
# Please maintain strict indentation rules.
# Commands are TAB indented, while text is SPACE indented.
# 'case' indentation is minimalistic.
cmd_help() {
	easyrsa_help_title="\
Usage: easyrsa [ OPTIONS.. ] <COMMAND> <TARGET> [ cmd-opts.. ]"
	unset -v text err_text opts text_only

	case "$1" in
	init-pki|clean-all)
		text="
* init-pki [ cmd-opts ]

      Removes & re-initializes the PKI directory for a new PKI"

		opts="
      * hard    - Recursively delete the ENTIRE PKI directory (default).
      * soft    - Keep the named PKI directory and PKI 'vars' file intact.
                  Also keep the current Request files,
                  to be signed by a new CA (Partial CA renewal)."
	;;
	self-sign*)
		text="
* self-sign-server|self-sign-client <file_name_base> [ cmd-opts ]

      Creates a new self-signed server|client key pair"

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')"
	;;
	build-ca)
		text="
* build-ca [ cmd-opts ]

      Creates a new CA"

		opts="
      * raw-ca  - ONLY use SSL binary to input CA password
        raw       (Equivalent to global option '--raw-ca')

      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')

      * subca   - Create an intermediate CA keypair and request
        intca     (default is a root CA)"
	;;
	gen-dh)
		text="
* gen-dh

      Generates DH (Diffie-Hellman) parameters file"
	;;
	gen-req)
		text="
* gen-req <file_name_base> [ cmd-opts ]

      Generate a standalone-private-key and certificate-signing-request

      This request is suitable for sending to a remote CA for signing."

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')
      * text    - Include certificate text in request"
	;;
	sign|sign-req)
		text="
* sign-req <type> <file_name_base> [ cmd-opts ]

      Sign a certificate request of the defined type.

      <type> must be a known type.
      eg: 'client', 'server', 'serverClient', 'ca' or a user-added type.
      All supported types are listed in the x509-types directory.

      This request file must exist in the reqs/ dir and have a .req file
      extension. See 'import-req' for importing from other sources."
		opts="
      * newsubj  - Replace subject. See 'help subject'.
      * preserve - Use the DN-field order of the CSR not the CA."
	;;
	build|build-client-full|build-server-full|build-serverClient-full)
		text="
* build-client-full <file_name_base> [ cmd-opts ]
* build-server-full <file_name_base> [ cmd-opts ]
* build-serverClient-full <file_name_base> [ cmd-opts ]

      Generate a keypair and sign locally.

      This mode uses the <file_name_base> as the X509 commonName."

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')"
	;;
	inline)
		text="
* inline <file_name_base>

      Create inline file for <file_name_base>."
	;;
	revoke*)
		text="
* revoke <file_name_base> [ reason ]

Commmand 'revoke' is DEPRECATED and can ONLY be used in batch mode.
Commmand 'revoke-issued' REPLACES command 'revoke'.

      Revoke a certificate specified by the <file_name_base>,
      with an optional revocation [ reason ].

      Values accepted for option [ reason ]:
         us | uns* | unspecified
         kc | key* | keyCompromise
         cc | ca*  | CACompromise
         ac | aff* | affiliationChanged
         ss | sup* | superseded
         co | ces* | cessationOfOperation
         ch | cer* | certificateHold

      Commands 'revoke-expired' and 'revoke-renewed' are functionally
      equivalent to 'revoke-issued', however, they are used to revoke
      certificates which have been either 'expired' or 'renewed' by
      other EasyRSA commands.

Commmand 'revoke' is DEPRECATED and can ONLY be used in batch mode.
Commmand 'revoke-issued' REPLACES command 'revoke'.

REQUIRED COMMANDS:

* 'revoke-issued' <file_name_base> [ reason ]
  Revoke a current, issued certificate.

* 'revoke-expired' <file_name_base> [ reason ]
  Revoke an old, expired certificate.

* 'revoke-renewed' <file_name_base> [ reason ]
  Revoke an old, renewed certificate."
		opts="
      * [ reason ]${NL}
      Values accepted for option [ reason ]: Details above."
	;;
	expire)
		text="
* expire <file_name_base>

      Move a certificate specified by <file_name_base>
      to the 'pki/expired' directory.

      Allows an existing request to be signed again."
	;;
	renew-ca)
		text="
* renew-ca

      Renew CA certificate.

      This will build a new CA certificate and archive the old one.
      Before changes are made to the current PKI, user confirmation
      is required."
	;;
	renew)
		text="
* renew <file_name_base>

      Renew a certificate specified by <file_name_base>"
	;;
	gen-crl)
		text="
* gen-crl

      Generate a certificate revocation list [CRL]"
	;;
	update-db)
		text="
* update-db

      Update the index.txt database

      This command will use the system time to update the status of
      issued certificates."
	;;
	show-req|show-cert)
		text="
* show-req  <file_name_base> [ cmd-opts ]
* show-cert <file_name_base> [ cmd-opts ]

      Shows details of the req or cert referenced by <file_name_base>

      Human-readable output is shown, including any requested cert
      options when showing a request."

		opts="
      * full    - show full req/cert info, including pubkey/sig data"
	;;
	show-ca)
		text="
* show-ca [ cmd-opts ]

      Shows details of the Certificate Authority [CA] certificate

      Human-readable output is shown."

		opts="
      * full    - show full CA info, including pubkey/sig data"
	;;
	show-crl)
		text="
* show-crl

      Shows details of the current certificate revocation list (CRL)

      Human-readable output is shown."
	;;
	verify|verify-cert)
		text="
* verify-cert <file_name_base> [ cmd-opts ]

      Verify certificate against CA

      Returns the current validity of the certificate."

		opts="
      * batch   - On failure to verify, return error (1) to caller"
	;;
	import-req)
		text="
* import-req <request_file_path> <short_name_base>

      Import a certificate request from a file

      This will copy the specified file into the reqs/ dir in
      preparation for signing.

      The <short_name_base> is the <file_name_base> to create.

      Example usage:
        import-req /some/where/bob_request.req bob"
	;;
	export-p12)
		text="
* export-p12 <file_name_base> [ cmd-opts ]

      Export a PKCS#12 file with the keypair,
      specified by <file_name_base>"

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')
      * noca    - Do not include the ca.crt file in the PKCS12 output
      * nokey   - Do not include the private key in the PKCS12 output
      * nofn    - Do not set 'friendlyName'
                  For more, see: 'easyrsa help friendly'
      * legacy  - Use legacy algorithm: RC2_CBC or 3DES_CBC + MAC: SHA1
                  (Default algorithm: AES-256-CBC + MAC: SHA256)"
	;;
	friendly)
		text_only=1
		text="
* export-p12: Internal file label 'friendlyName'

      The 'friendlyname' is always set to the file-name-base.

      An alternate friendlyName can be configured by using:
      * Global option '--usefn=<friendlyName>'

      Fallback to previous behavior can be configured by using:
      * Command option 'nofn' ('friendlyname' will not be set)"
	;;
	export-p7)
		text="
* export-p7 <file_name_base> [ cmd-opts ]

      Export a PKCS#7 file with the pubkey,
      specified by <file_name_base>"

		opts="
      * noca    - Do not include the ca.crt file in the PKCS7 output"
	;;
	export-p8)
		text="
* export-p8 <file_name_base> [ cmd-opts ]

      Export a PKCS#8 file with the private key,
      specified by <file_name_base>"

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')"
	;;
	export-p1)
		text="
* export-p1 <file_name_base> [ cmd-opts ]

      Export a PKCS#1 (RSA format) file with the pubkey,
      specified by <file_name_base>"

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')"
	;;
	set-pass|set-ed-pass|set-rsa-pass|set-ec-pass)
		text="
* set-pass <file_name_base> [ cmd-opts ]

      Set a new passphrase for the private key specified by <file_name_base>

  DEPRECATED: 'set-rsa-pass' and 'set-ec-pass'"

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')
      * file    - (Advanced) Treat the file as a raw path, not a short-name"
	;;
	write)
		text="
* write <type> [<filename>] ['overwrite']

      Write <type> data to stdout or <filename>

      Types:
      * ssl-cnf  - Write EasyRSA SSL config file.
      * safe-cnf - Write expanded EasyRSA SSL config file for LibreSSL.
      * COMMON|ca|server|serverClient|client|codeSigning|email|kdc
                 - Write x509-type <type> file.
      * legacy   - Write ALL support files (above) to the PKI directory.
                   Will create '\$EASYRSA_PKI/x509-types' directory.
      * legacy-hard
                 - Same as 'legacy' plus OVER-WRITE files.
      * vars     - Write vars.example file."

		opts="
      * filename - If <filename> is specified then it is the output
                   is directed to the named file.
                   Otherwise, the data is sent to stdout
      * overwrite - Overwrite the <filename>.
                   <filename> is always preserved without 'overwrite'."
	;;
	--san|--subject-alt-name|altname|subjectaltname|san)
		text_only=1
		text="
* Global Option: --subject-alt-name=SAN_FORMAT_STRING

      This global option adds a subjectAltName to the request or issued
      certificate. It MUST be in a valid format accepted by openssl or
      req/cert generation will fail. NOTE: --san can be specified more
      than once on the command line.

      The following two command line examples are equivalent:
      1. --san=DNS:server1,DNS:serverA,IP:10.0.0.1
      2. --san=DNS:server1 --san=DNS:serverA --san=IP:10.0.0.1

      Examples of the SAN_FORMAT_STRING shown below:

      * DNS:alternate.example.net
      * DNS:primary.example.net,DNS:alternate.example.net
      * IP:203.0.113.29
      * email:alternate@example.net"
	;;
	--copy-ext|copy-ext|copyext)
		text_only=1
		text="
* Global Option: How to use --copy-ext and --san=<SAN>

    These are the only commands that support --copy-ext and/or --san.

    Command 'gen-req':
      --san: Add SAN extension to the request file.

    Command 'sign-req':
      --copy-ext: Copy all request extensions to the signed certificate.
      --san: Over write the request SAN with option SAN.

    Command 'build-*-full':
      --copy-ext: Always enabled.
      --san: Add SAN extension to the request and signed certificate.

    See 'help san' for option --san full syntax."
	;;
	--days|days)
		text_only=1
		text="
* Global Option: --days=DAYS

      This global option is an alias for one of the following:
      * Expiry days for a new CA.
        eg: '--days=3650 build-ca'
      * Expiry days for new/renewed certificate.
        eg: '--days=1095 renew server'
      * Expiry days for certificate revocation list.
        eg: '--days=180 gen-crl'
      * Cutoff days for command: show-expire.
        eg: '--days=90 show-expire'"
	;;
	--new-subj*|new-subj*|newsubj*|subject)
		text_only=1
		text="
* Global Option: --new-subject=<SUBJECT>

      This global option is used to set the new certificate subject,
      when signing a new certificate

* REQUIRES Command option: 'newsubj', for command 'sign-req'

      Using command 'sign-req', add command option 'newsubj',
      to FORCE the --new-subject to be used.

      Example:
      --new-subject='/CN=foo' sign-req client bar newsubj

      See OpenSSL command 'ca', option -subj, for full details."
	;;
	tool*|util*|more)
		# Test features
		text_only=1
		text="
NOTE:
These commands are safe to test and will NOT effect your PKI.

  Check <SERIAL> number is unique:
    serial|check-serial <SERIAL>

  Display DN of request or certificate: <form> = req|x509
    display-dn <form> <DIR/FILE_NAME>

  Display EKU of certificate:
    show-eku <file_name_base>|<DIR/FILE_NAME>

  Generate random hex:
    rand <decimal_number>

These commands require easyrsa-tools.lib to be installed:

  show-expire <file_name_base> (Optional)
  show-revoke <file_name_base> (Optional)
  show-renew <file_name_base> (Optional)"
	;;
	gen-tls*)
		text_only=1
		text="
Generate TLS keys for use with OpenVPN:

  gen-tls-auth-key    : Generate OpenVPN TLS-AUTH key
  gen-tls-crypt-key   : Generate OpenVPN TLS-CRYPT-V1 key (Preferred)

Only ONE TLS key is allowed to exist. (pki/private/easyrsa-tls.key)
This TLS key will be automatically added to inline files."
	;;
	opts|options)
		opt_usage
		cleanup ok
	;;
	"")
		usage
		cleanup ok
	;;
	*)
		err_text="
  Unknown command: '$1' \
(try without commands for a list of commands)"
		easyrsa_exit_with_error=1
	esac

	if [ "$err_text" ]; then
		print "$easyrsa_help_title"
		print "${err_text}"
	else
		# display the help text
		print "$easyrsa_help_title"
		[ "$text" ] && print "$text"

		if [ "$text_only" ]; then
			: # ok - No opts message required
		else
			print "
    Available command options [ cmd-opts ]:
${opts:-
      * No supported command options}"
		fi
	fi
	print
} # => cmd_help()

# Options usage
opt_usage() {
	text_only=1
	information "
Easy-RSA Global Option Flags

The following global-options may be provided before the command.
Options specified at runtime override env-vars and any 'vars'
file in use.

Unless noted, non-empty values to options are mandatory.

General options:

--version       : Prints EasyRSA version and build information
--batch         : Set automatic (no-prompts when possible) mode
--silent|-s     : Disable all warnings, notices and information
--sbatch        : Combined --silent and --batch operating mode
--silent-ssl|-S : Silence SSL output (Requires batch mode)

--nopass|no-pass: Do not use passwords
                  Can NOT be used with --passin or --passout
--passin=ARG    : Set -passin ARG for openssl (eg: pass:xEasyRSAy)
--passout=ARG   : Set -passout ARG for openssl (eg: pass:xEasyRSAy)
--raw-ca        : Build CA with password via RAW SSL input

--vars=FILE     : Define a specific 'vars' file to use for Easy-RSA config
                  (Default vars file is in the current working directory)
--pki=DIR       : Declare the PKI directory
                  (Default PKI directory is sub-directory 'pki')
                  See Advanced.md for in depth usage.

--ssl-cnf=FILE  : Define a specific OpenSSL config file for Easy-RSA to use
                  (Default config file is in the EasyRSA PKI directory)
--force-safe-ssl: Always generate a safe SSL config file
                  (Default: Generate Safe SSL config once per instance)

--tools=FILE    : Declare the full easyrsa-tools.lib file-name
--tmp-dir=DIR   : Declare the temporary directory
                  (Default temporary directory is the EasyRSA PKI directory)
--keep-tmp=NAME : Keep the original temporary session by name: NAME
                  NAME is a sub-directory of the dir declared by --tmp-dir
                  This option ALWAYS over-writes a sub-dir of the same name.

Certificate & Request options: (these impact cert/req field values)

--notext|no-text: Create certificates without human readable text
--days=#        : Sets the signing validity to the specified number of days
                  Applies to other commands. For details, see: 'help days'
--startdate=DATE: Sets the SSL option '-startdate' (Format 'YYYYMMDDhhmmssZ')
--enddate=DATE  : Sets the SSL option '-enddate' (Format 'YYYYMMDDhhmmssZ')

--digest=ALG    : Digest to use in the requests & certificates
--keysize=#     : Size in bits of keypair to generate (RSA Only)
--use-algo=ALG  : Crypto alg to use: choose rsa (default), ec or ed
--curve=NAME    : For elliptic curve, sets the named curve
                  (Default: algo ec: secp384r1, algo ed: ed25519)

--subca-len=#   : Path length of signed intermediate CA certificates
--copy-ext      : Copy included request X509 extensions (namely subjAltName)
                  For more info, see: 'easyrsa help copyext'

--san|--subject-alt-name=SUBJECT_ALT_NAME
                : Add a subjectAltName. Can be used multiple times.
                  For more info and syntax, see: 'easyrsa help altname'
--auto-san      : Use commonName as subjectAltName: 'DNS:commonName'
                  If commonName is 'n.n.n.n' then set 'IP:commonName'

--san-crit      : Mark X509v3 subjectAltName as critical
--bc-crit       : Add X509 'basicContraints = critical' attribute.
--ku-crit       : Add X509 'keyUsage = critical' attribute.
--eku-crit      : Add X509 'extendedKeyUsage = critical' attribute.

--new-subject='SUBJECT'
                : Specify a new subject field to sign a request with.
                  For more info and syntax, see: 'easyrsa help subject'

--usefn=NAME    : export-p12, set 'friendlyName' to NAME
                  For more, see: 'easyrsa help friendly'

Distinguished Name mode:

--dn-mode=MODE  : Distinguished Name mode to use 'cn_only' (Default) or 'org'

--req-cn=NAME   : Request commonName

  Distinguished Name Organizational options: (only used with '--dn-mode=org')
  --req-c=CC           : Country code (2-letters)
  --req-st=NAME        : State/Province
  --req-city=NAME      : City/Locality
  --req-org=NAME       : Organization
  --req-email=NAME     : Email addresses
  --req-ou=NAME        : Organizational Unit
  --req-serial=VALUE   : Entity serial number (Only used when declared)

Deprecated features:

--ns-cert             : Include deprecated Netscape extensions
--ns-comment=COMMENT  : Include deprecated Netscape comment (may be blank)"
} # => opt_usage()

# Wrapper around printf - clobber print since it's not POSIX anyway
# print() is used internally, so MUST NOT be silenced.
# shellcheck disable=SC1117 # printf format - print()
print() {
	printf '%s\n' "$*"
} # => print()

# Exit fatally with a message to stderr
# present even with EASYRSA_BATCH as these are fatal problems
die() {
	print "
Easy-RSA error:

$*${NL}"

	# error_info is for hard-to-spot errors!
	if [ "$error_info" ]; then
		print "  * $cmd: ${error_info}${NL}"
	fi

	# show host info
	show_host

	# exit to cleanup()
	exit "${2:-1}"
} # => die()

# User errors, less noise than die()
user_error() {
	print "
EasyRSA version $EASYRSA_version

Error
-----
$*${NL}"

	easyrsa_exit_with_error=1
	cleanup
} # => user_error()

# verbose information
verbose() {
	[ "$EASYRSA_VERBOSE" ] || return 0
	print "  # $*"
} # => verbose()

# non-fatal warning output
warn() {
	[ "$EASYRSA_SILENT" ] && return
	print "
WARNING
=======
$*${NL}"
} # => warn()

# informational notices to stdout
notice() {
	[ "$EASYRSA_SILENT" ] && return
	print "
Notice
------
$*${NL}"
} # => notice()

# Helpful information
information() {
	[ "$EASYRSA_SILENT" ] && return
	print "$*"
} # => information()

# intent confirmation helper func
# returns without prompting in EASYRSA_BATCH
confirm() {
	[ "$EASYRSA_BATCH" ] && return
	prompt="$1"
	value="$2"
	msg="$3"
	input=""
	print "\
$msg

Type the word '$value' to continue, or any other input to abort."
	printf %s "  $prompt"
	# shellcheck disable=SC2162 # read without -r - confirm()
	read input
	printf '\n'
	[ "$input" = "$value" ] && return
	easyrsa_exit_with_error=1
	unset -v EASYRSA_SILENT
	notice "Aborting without confirmation."
	cleanup
} # => confirm()

# Generate random hex
easyrsa_random() {
	case "$1" in
		*[!1234567890]*|0*|"")
			die "easyrsa_random - input"
	esac

	if rand_hex="$(
			"$EASYRSA_OPENSSL" rand -hex "$1" 2>/dev/null
		)"
	then
		if [ "$2" ]; then
			force_set_var "$2" "$rand_hex"
		else
			print "$rand_hex"
		fi
		unset -v rand_hex
		return 0
	fi

	die "easyrsa_random failed"
} # => easyrsa_random()

# Create session directory atomically or fail
secure_session() {
	# Session must not be defined
	[ -z "$secured_session" ] || die "session overload"

	# Temporary directory must exist
	[ -d "$EASYRSA_TEMP_DIR" ] || die "\
secure_session - Missing temporary directory:
* $EASYRSA_TEMP_DIR"

	for i in 1 2 3; do
		session=
		easyrsa_random 4 session
		secured_session="${EASYRSA_TEMP_DIR}/${session}"

		# atomic:
		# ONLY effects Windows 11 "broken" mkdir.exe
		# The procedure now is a "poor man's" version
		# of an atomic directory creation call.
		# The "race condition" still exists but is minimized.
		# What remains is equivalent to 32bit hash collision.
		[ -d "$secured_session" ] && continue
		if mkdir "$secured_session"; then
			# Check mkdir.exe has created the directory
			[ -d "$secured_session" ] || \
				die "secure_session - mkdir FAILED"
			[ -f "$secured_session"/temp.0.1 ] && \
				die "secure_session - temp-file EXISTS"

			# New session requires safe-ssl conf
			unset -v session OPENSSL_CONF \
				working_safe_ssl_conf working_safe_org_conf

			easyrsa_err_log="$secured_session/error.log"
			verbose "\
secure_session: CREATED: $secured_session"
			return
		fi
	done
	die "secure_session failed"
} # => secure_session()

# Remove secure session
remove_secure_session() {
	[ -d "$secured_session" ] || return 0
	if rm -rf "$secured_session"; then
		verbose "\
remove_secure_session: DELETED: $secured_session"

		# Restore original EASYRSA_SSL_CONF
		EASYRSA_SSL_CONF="$original_ssl_cnf"

		unset -v secured_session OPENSSL_CONF \
			working_safe_ssl_conf working_safe_org_conf
		return
	fi
	die "remove_secure_session Failed: $secured_session"
} # => remove_secure_session()

# 'mkdir' wrapper, broken by win11, which fails without error
easyrsa_mkdir() {
	[ "$2" ] && die "easyrsa_mkdir - excess input"
	[ "$1" ] || die "easyrsa_mkdir - input"
	[ -d "$1" ] && return
	mkdir "$1" 2>/dev/null
	[ -d "$1" ] && return
	die "easyrsa_mkdir - FAIL: $1"
} # => easyrsa_mkdir()

# Create temp-file atomically or fail
# WARNING: Running easyrsa_openssl in a subshell
# will hide error message and verbose messages
# from easyrsa_mktemp()
easyrsa_mktemp() {
	if [ -z "$1" ] || [ "$2" ]; then
		die "easyrsa_mktemp - input error"
	fi

	# session directory must exist
	[ -d "$secured_session" ] || die "\
easyrsa_mktemp - Temporary session undefined (--tmp-dir)"

	# Force noclobber
	if [ "$easyrsa_host_os" = win ]; then
		set -o noclobber
	else
		set -C
	fi

	# Assign internal temp-file name
	tmp_fname="${secured_session}/temp.${mktemp_counter}"

	# Create shotfile
	for shot_try in x y z; do
		shotfile="${tmp_fname}.${shot_try}"
		if [ -f "$shotfile" ]; then
			verbose "\
easyrsa_mktemp: shotfile EXISTS: $shotfile"
			continue
		else
			printf "" > "$shotfile" || die "\
easyrsa_mktemp: create shotfile failed (1) $1"

			# Create temp-file or die
			# subshells do not update mktemp_counter,
			# which is why this extension is required.
			# Current max required is 1 attempt
			for ext_try in 1 2 3 4 5 6 7 8 9; do
				want_tmp_file="${tmp_fname}.${ext_try}"

				# Warn to error log file for max reached
				if [ "$EASYRSA_MAX_TEMP" -lt "$ext_try" ]; then
					print "\
Max temp-file limit $ext_try, hit for: $1" > "$easyrsa_err_log"
					die "EASYRSA_MAX_TEMP exceeded"
				fi

				if [ -f "$want_tmp_file" ]; then
					verbose "\
easyrsa_mktemp: temp-file EXISTS: $want_tmp_file"
					continue
				else
					# atomic:
					if mv "$shotfile" "$want_tmp_file"; then
						# Assign external temp-file name
						if force_set_var "$1" "$want_tmp_file"
						then
							verbose "\
: easyrsa_mktemp: $1 OK: $want_tmp_file"

							# unset noclobber
							if [ "$easyrsa_host_os" = win ]; then
								set +o noclobber
							else
								set +C
							fi

							# Update counter
							mktemp_counter="$((mktemp_counter+1))"

							unset -v tmp_fname \
								shotfile shot_try \
								want_tmp_file ext_try
							return
						else
							die "\
easyrsa_mktemp - force_set_var $1 failed"
						fi
					fi
				fi
			done
		fi
	done

	# unset noclobber
	if [ "$easyrsa_host_os" = win ]; then
		set +o noclobber
	else
		set +C
	fi

	# In case of subshell abuse, report to error log
	err_msg="\
easyrsa_mktemp - failed for: $1 @ attempt=$ext_try
want_tmp_file: $want_tmp_file"
	print "$err_msg" > "$easyrsa_err_log"
	die "$err_msg"
} # => easyrsa_mktemp()

# remove temp files and do terminal cleanups
cleanup() {
	# In case of subshell abuse, display error log file
	if [ -f "$easyrsa_err_log" ]; then
		print; cat "$easyrsa_err_log"; print
	fi

	# undo changes BEFORE delete temp-dir
	# Remove files when build_full()->sign_req() is interrupted
	[ "$error_build_full_cleanup" ] && \
		rm -f "$crt_out" "$req_out" "$key_out"

	# Restore files when renew is interrupted
	[ "$error_undo_renew_move" ] && renew_restore_move

	# Remove temp-session or create temp-snapshot
	if [ -d "$secured_session" ]; then
		if [ "$EASYRSA_KEEP_TEMP" ]; then
			# skip on black-listed directory names, with a warning
			# Use '-e' for directory or file name
			if [ -e "$EASYRSA_TEMP_DIR/$EASYRSA_KEEP_TEMP" ]
			then
				warn "\
Prohibited value for --keep-tmp: '$EASYRSA_KEEP_TEMP'
Temporary session not preserved."
			else
				# create temp-snapshot
				keep_tmp="$EASYRSA_TEMP_DIR/tmp/$EASYRSA_KEEP_TEMP"
				easyrsa_mkdir "$EASYRSA_TEMP_DIR"/tmp
				easyrsa_mkdir "$keep_tmp"
				rm -rf "$keep_tmp"
				mv -f "$secured_session" "$keep_tmp"
				information "Temp session preserved: $keep_tmp"
				unset -v secured_session
			fi
		fi

		# remove temp-session
		remove_secure_session
		verbose "mktemp_counter: $mktemp_counter uses"
	fi

	# When prompt is disabled then restore prompt
	case "$prompt_restore" in
		0) : ;; # Not required
		1)
			[ -t 1 ] && stty echo
			[ "$EASYRSA_SILENT" ] || print
		;;
		2)
			# shellcheck disable=SC3040 # POSIX set -o
			set -o echo
			[ "$EASYRSA_SILENT" ] || print
		;;
		*) warn "Unknown prompt_restore: '$prompt_restore'"
	esac

	# Clear traps
	trap - 0 1 2 3 6 15

	# Exit: Known errors
	# -> confirm(): aborted
	# -> verify_cert(): verify failed --batch mode
	# -> check_serial_unique(): not unique --batch mode
	# -> user_error(): User errors but not die()
	if [ "$easyrsa_exit_with_error" ]; then
		verbose "Exit: Known errors = true"
		exit 1
	elif [ "$1" = 2 ]; then
		verbose "exit SIGINT = true"
		kill -2 "$$" # Exit: SIGINT
	elif [ "$1" = ok ]; then
		verbose "Exit: Final Success = true"
		exit 0 # Exit: Final Success
	fi

	# if 'cleanup' is called without 'ok' then an error occurred
	verbose "Exit: Final Fail = true"
	exit 1 # Exit: Final Fail, unknown error
} # => cleanup()

# Escape hazardous characters
# Auto-escape hazardous characters:
# '&' - Workaround 'sed' behavior
# '$' - Workaround 'easyrsa' based limitation
# This is required for all SSL libs, otherwise,
# there are unacceptable differences in behavior
escape_hazard() {
	if [ "$EASYRSA_FORCE_SAFE_SSL" ]; then # Always run
		verbose "escape_hazard: FORCED"
	elif [ "$working_safe_org_conf" ]; then # Has run once
		verbose "escape_hazard: BYPASSED"
		return
	else # Run once
		verbose "escape_hazard: RUN-ONCE"
		working_safe_org_conf=1 # Set run once
	fi

	# Assign temp-file
	escape_hazard_tmp=""
	easyrsa_mktemp escape_hazard_tmp || die \
		"escape_hazard - easyrsa_mktemp escape_hazard_tmp"

	# write org fields to org temp-file and escape '&' and '$'
	print "\
export EASYRSA_REQ_COUNTRY=\"$EASYRSA_REQ_COUNTRY\"
export EASYRSA_REQ_PROVINCE=\"$EASYRSA_REQ_PROVINCE\"
export EASYRSA_REQ_CITY=\"$EASYRSA_REQ_CITY\"
export EASYRSA_REQ_ORG=\"$EASYRSA_REQ_ORG\"
export EASYRSA_REQ_OU=\"$EASYRSA_REQ_OU\"
export EASYRSA_REQ_EMAIL=\"$EASYRSA_REQ_EMAIL\"
export EASYRSA_REQ_SERIAL=\"$EASYRSA_REQ_SERIAL\"\
" | sed -e s\`'\&'\`'\\\&'\`g \
		-e s\`'\$'\`'\\\$'\`g > "$escape_hazard_tmp" || \
			die "escape_hazard - Failed to write temp-file"

	# Reload fields from fully escaped temp-file
	# shellcheck disable=1090 # Non-constant source
	. "$escape_hazard_tmp"
	verbose "escape_hazard: COMPLETED"
} # => escape_hazard()

# Replace environment variable names with current value
# and write to temp-file or return error from sed
expand_ssl_config() {
	if [ "$EASYRSA_FORCE_SAFE_SSL" ]; then # Always run
		verbose "expand_ssl_config: FORCED"
	elif [ "$working_safe_ssl_conf" ]; then # Has run once
		verbose "expand_ssl_config: BYPASSED"
		return
	elif [ "$ssl_lib" = libressl ]; then # LibreSSL Always run
		verbose "expand_ssl_config: REQUIRED"
	elif [ "$ssl_lib" = openssl ]; then # OpenSSL not required
		verbose "expand_ssl_config: IGNORED"
		return
	else
		die "expand_ssl_config: EXCEPTION" # do NOT Run
	fi

	# Set run once
	working_safe_ssl_conf=1
	verbose "expand_ssl_config: RUN-ONCE"

	# Assign temp-file
	safe_ssl_cnf_tmp=""
	easyrsa_mktemp safe_ssl_cnf_tmp || die \
		"expand_ssl_config - easyrsa_mktemp safe_ssl_cnf_tmp"

	# Rewrite
	# shellcheck disable=SC2016 # No expand ''
	if sed \
\
-e s\`'$dir'\`\
\""$EASYRSA_PKI"\"\`g \
\
-e s\`'$ENV::EASYRSA_PKI'\`\
\""$EASYRSA_PKI"\"\`g \
\
-e s\`'$ENV::EASYRSA_CERT_EXPIRE'\`\
\""$EASYRSA_CERT_EXPIRE"\"\`g \
\
-e s\`'$ENV::EASYRSA_CRL_DAYS'\`\
\""$EASYRSA_CRL_DAYS"\"\`g \
\
-e s\`'$ENV::EASYRSA_DIGEST'\`\
\""$EASYRSA_DIGEST"\"\`g \
\
-e s\`'$ENV::EASYRSA_KEY_SIZE'\`\
\""$EASYRSA_KEY_SIZE"\"\`g \
\
-e s\`'$ENV::EASYRSA_DN'\`\
\""$EASYRSA_DN"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_CN'\`\
\""$EASYRSA_REQ_CN"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_COUNTRY'\`\
\""$EASYRSA_REQ_COUNTRY"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_PROVINCE'\`\
\""$EASYRSA_REQ_PROVINCE"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_CITY'\`\
\""$EASYRSA_REQ_CITY"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_ORG'\`\
\""$EASYRSA_REQ_ORG"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_OU'\`\
\""$EASYRSA_REQ_OU"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_EMAIL'\`\
\""$EASYRSA_REQ_EMAIL"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_SERIAL'\`\
\""$EASYRSA_REQ_SERIAL"\"\`g \
\
			"$EASYRSA_SSL_CONF" > "$safe_ssl_cnf_tmp"
		then
			verbose "expand_ssl_config: via 'sed' COMPLETED"
		else
			return 1
		fi

	export EASYRSA_SSL_CONF="$safe_ssl_cnf_tmp"
	unset -v safe_ssl_cnf_tmp
	verbose \
		"expand_ssl_config: EASYRSA_SSL_CONF = $EASYRSA_SSL_CONF"
} # => expand_ssl_config()

# Easy-RSA meta-wrapper for SSL
# WARNING: Running easyrsa_openssl in a subshell
# will hide error message and verbose messages
easyrsa_openssl() {
	openssl_command="$1"; shift

	if [ "$EASYRSA_DEBUG" ]; then
		verbose "= easyrsa_openssl - BEGIN $openssl_command $*"
	else
		verbose "= easyrsa_openssl - BEGIN $openssl_command"
	fi

	# Do not allow 'rand' here, see easyrsa_random()
	case "$openssl_command" in
		rand) die "easyrsa_openssl: Illegal SSL command: rand"
	esac

	# Use $EASYRSA_SSL_CONF (local) or $OPENSSL_CONF (global)
	if [ -f "$EASYRSA_SSL_CONF" ]; then
		export OPENSSL_CONF="$EASYRSA_SSL_CONF"
	elif [ -f "$OPENSSL_CONF" ]; then
		export OPENSSL_CONF
	else
		die "easyrsa_openssl - OPENSSL_CONF undefined"
	fi
	verbose "= easyrsa_openssl: OPENSSL_CONF = $OPENSSL_CONF"

	# Exec SSL
	if [ "$EASYRSA_SILENT_SSL" ] && [ "$EASYRSA_BATCH" ]
	then
		if "$EASYRSA_OPENSSL" "$openssl_command" "$@" \
			2>/dev/null
		then
			verbose "= easyrsa_openssl - END $openssl_command"
			return
		fi
	else
		if "$EASYRSA_OPENSSL" "$openssl_command" "$@"
		then
			verbose "= easyrsa_openssl - END $openssl_command"
			return
		fi
	fi

	# Always fail here
	die "\
easyrsa_openssl - Command has failed:
* $EASYRSA_OPENSSL $openssl_command $*"
} # => easyrsa_openssl()

# Verify the SSL library is functional
# and establish version dependencies
verify_ssl_lib() {
	# Run once only
	[ "$verify_ssl_lib_ok" ] && return
	verify_ssl_lib_ok=1
	unset -v openssl_v3

	# redirect std-err, ignore missing ssl/openssl.cnf
	val="$(
			"$EASYRSA_OPENSSL" version 2>/dev/null
		)"
	ssl_version="$val"

	# SSL lib name
	case "${val%% *}" in
		OpenSSL)
			ssl_lib=openssl
			# Honor EASYRSA_FORCE_SAFE_SSL
			if [ "$EASYRSA_FORCE_SAFE_SSL" ]; then
				ssl_cnf_type=safe-cnf
			else
				ssl_cnf_type=ssl-cnf
			fi
			;;
		LibreSSL)
			ssl_lib=libressl
			ssl_cnf_type=safe-cnf
			;;
		*)
			error_msg="$("$EASYRSA_OPENSSL" version 2>&1)"
			user_error "\
* OpenSSL must either exist in your PATH
  or be defined in your vars file.

Invalid SSL output for 'version':

$error_msg"
	esac

	# Set SSL version dependent $no_password option
	osslv_major="${val#* }"
	osslv_major="${osslv_major%%.*}"
	case "$osslv_major" in
		1) no_password='-nodes' ;;
		2) no_password='-nodes' ;;
		3|4)
			case "$ssl_lib" in
				openssl)
					openssl_v3=1
					no_password='-noenc'
					;;
				libressl)
					no_password='-nodes'
					;;
				*) die "Unexpected SSL library: $ssl_lib"
			esac
			;;
		*) die "Unexpected SSL version: $osslv_major"
	esac

	# Message
	verbose "verify_ssl_lib(): $ssl_version ($EASYRSA_OPENSSL)"
} # => verify_ssl_lib()

# Basic sanity-check of PKI init and complain if missing
verify_pki_init() {
	help_note="\
Run easyrsa without commands for usage and command help."

	# Check for defined EASYRSA_PKI
	[ "$EASYRSA_PKI" ] || die "\
EASYRSA_PKI env-var undefined"

	# check that the pki dir exists
	[ -d "$EASYRSA_PKI" ] || user_error "\
EASYRSA_PKI does not exist (perhaps you need to run init-pki)?
Expected to find the EASYRSA_PKI at:
* $EASYRSA_PKI

$help_note"

	# verify expected dirs present:
	for i in private reqs; do
		[ -d "$EASYRSA_PKI/$i" ] || user_error "\
Missing expected directory: $i

(perhaps you need to run init-pki?)

$help_note"
	done
	unset -v help_note
} # => verify_pki_init()

# Verify core CA files present
verify_ca_init() {
	verify_ca_help_note="\
Run easyrsa without commands for usage and command help."

	# Verify expected files are present.
	# Allow files to be regular files (or symlinks),
	# but also pipes, for flexibility with ca.key
	for i in ca.crt private/ca.key index.txt serial; do
		if [ ! -f "$EASYRSA_PKI/$i" ] && \
			[ ! -p "$EASYRSA_PKI/$i" ]
		then
			# Used by usage() and export-p12/p7
			[ "$1" = "test" ] && return 1

			user_error "\
Missing expected CA file: $i

(perhaps you need to run build-ca?)

$verify_ca_help_note"
		fi
	done

	# When operating in 'test' mode, return success.
	# test callers don't care about CA-specific dir structure
	[ "$1" = "test" ] && return 0

	# verify expected CA-specific dirs:
	for i in issued certs_by_serial; do
		[ -d "$EASYRSA_PKI/$i" ] || user_error "\
Missing expected CA dir: $i

(perhaps you need to run build-ca?)

$verify_ca_help_note"
	done
} # => verify_ca_init()

# init-pki backend:
init_pki() {
	# Process command options
	reset="hard"
	while [ "$1" ]; do
		case "$1" in
			hard-reset|hard)
				reset="hard"
				confirm_msg=
			;;
			soft-reset|soft)
				reset="soft"
				confirm_msg='PARTIALLY '
			;;
			*) warn "Ignoring unknown command option: '$1'"
		esac
		shift
	done

	# EasyRSA will NOT do 'rm -rf /'
	case "$EASYRSA_PKI" in
		.|..|./|../|.//*|..//*|/|//*|\\|?:|'')
			user_error "Invalid PKI: $EASYRSA_PKI"
	esac

	# If EASYRSA_PKI exists, confirm before deletion
	if [ -d "$EASYRSA_PKI" ]; then
		confirm "Confirm removal: " "yes" "
WARNING!!!

You are about to ${confirm_msg}remove the EASYRSA_PKI at:
* $EASYRSA_PKI

and initialize a fresh PKI here."

		# now remove it:
		case "$reset" in
		hard)
			# Promote use of 'init-pki soft':
			confirm "
  WARNING: COMPLETELY DESTROY current PKI (NOT recommended) ?

    [yes/NO]: " yes "\
         ******************************************
         * SECOND WARNING - STOP - SECOND WARNING *
         ******************************************

  To keep your current 'pki/vars' settings use 'init-pki soft'.
  To keep your current Request files use 'init-pki soft'
  The Requests can then be signed by a new CA (Partial CA renewal)
  To keep your current Easy-RSA TLS Key use 'init-pki soft'
  This private key file is in use by your current VPN.

       ** USE OF   'init-pki soft'   IS RECOMMENDED **${NL}"

			# # # shellcheck disable=SC2115 # Use "${var:?}"
			rm -rf "$EASYRSA_PKI" || \
				die "init-pki hard reset failed."
		;;
		soft)
		# There is no unit test for a soft reset
		# Save existing TLS key
			tls_key_file="$EASYRSA_PKI"/private/easyrsa-tls.key
			old_tls_key_file="$EASYRSA_PKI"/easyrsa-keepsafe-tls.key

			# If both keys exist then they must be the same
			if [ -f "$old_tls_key_file" ]; then
				if [ -f "$tls_key_file" ]; then
					# Match by hash
					tls_key_hash="$(
						"$EASYRSA_OPENSSL" dgst -sha256 \
							"$tls_key_file")"
					tls_key_hash="${tls_key_hash##* }"
					old_tls_key_hash="$(
						"$EASYRSA_OPENSSL" dgst -sha256 \
							"$old_tls_key_file")"
					old_tls_key_hash="${old_tls_key_hash##* }"
					[ "$tls_key_hash" = "$old_tls_key_hash" ] || \
						user_error "\
Easy-RSA TLS Keys do not match, only ONE of these files is valid:
* $tls_key_file
* $old_tls_key_file

Please delete the key above that is no longer in use."
				fi
			fi

			# Save existing TLS key
			if [ -f "$tls_key_file" ]; then
				tls_key_data="$(cat "$tls_key_file")"
			else
				tls_key_data=
			fi

			# Do NOT remove pki/reqs sub-dir, for "renew ca"
			for i in ca.crt crl.pem \
				issued private inline revoked renewed expired \
				serial serial.old index.txt index.txt.old \
				index.txt.attr index.txt.attr.old certs_by_serial
			do
				# # # shellcheck disable=SC2115 # Use "${var:?}"
				target="$EASYRSA_PKI/$i"
				if [ "${target%/*}" ]; then
					rm -rf "$target" || \
						die "init-pki soft reset(1) failed!"
				else
					die "init-pki soft reset(2) failed!"
				fi
			done
		;;
		*)
			user_error "Unknown reset type: $reset"
		esac
	fi

	# new dirs:
	easyrsa_mkdir "$EASYRSA_PKI"
	for i in issued private reqs; do
		easyrsa_mkdir "${EASYRSA_PKI}/$i"
	done

	# If one existed then recreate old TLS key backup file
	if [ "$tls_key_data" ]; then
		header="# Easy-RSA TLS Key: $(date)${NL}# DO NOT DELETE"
		printf '%s\n\n%s\n' "$header" "$tls_key_data" \
			> "$old_tls_key_file"
		tls_msg="${NL}
Previous Easy-RSA TLS key saved to:
* $old_tls_key_file${NL}"
	else
		# if an OLD TLS key still exists then notify user
		if [ -f "$old_tls_key_file" ]; then
			tls_msg="${NL}
Existing Easy-RSA TLS key preserved:
* $old_tls_key_file${NL}"
		else
			tls_msg=
		fi
	fi

	# write pki/vars.example - no temp-file because no session
	write_legacy_file_v2 \
		vars "$EASYRSA_PKI"/vars.example overwrite || \
			warn "init-pki - Failed to create vars.example"

	# User notice
	notice "\
'init-pki' complete; you may now create a CA or requests.

Your newly created PKI dir is:
* $EASYRSA_PKI"

	# Select and show vars file
	unset -v EASYRSA_VARS_FILE
	select_vars
	information "\
Using Easy-RSA configuration:
* ${EASYRSA_VARS_FILE:-undefined}${tls_msg}"
} # => init_pki()

# Find support files from various sources
# Declare in preferred order, first wins
# beaten by command line.
# If these files are not found here then they
# will be built on-demand by the selected command.
locate_support_files() {
	# Set required sources
	ssl_cnf_file='openssl-easyrsa.cnf'
	x509_types_dir='x509-types'
	easyrsa_tools='easyrsa-tools.lib'

	# Find data-files
	for area in \
		"$EASYRSA_PKI" \
		"$EASYRSA" \
		"$PWD" \
		"${0%/*}" \
		'/usr/local/share/easy-rsa' \
		'/usr/share/easy-rsa' \
		'/etc/easy-rsa' \
		# EOL
	do
		# Find x509-types
		if [ -d "${area}/${x509_types_dir}" ]; then
			set_var EASYRSA_EXT_DIR "${area}/${x509_types_dir}"
		fi

		# Find openssl-easyrsa.cnf
		if [ -f "${area}/${ssl_cnf_file}" ]; then
			set_var EASYRSA_SSL_CONF "${area}/${ssl_cnf_file}"
		fi

		# Find easyrsa-tools.lib
		if [ -f "${area}/${easyrsa_tools}" ]; then
			set_var EASYRSA_TOOLS_LIB "${area}/${easyrsa_tools}"
		fi
	done

	verbose ": EASYRSA_EXT_DIR: ${EASYRSA_EXT_DIR:-built-in}"
	verbose ": EASYRSA_SSL_CONF: ${EASYRSA_SSL_CONF:-built-in}"
	verbose ": EASYRSA_TOOLS_LIB: ${EASYRSA_TOOLS_LIB:-undefined}"
	verbose "locate_support_files: COMPLETED"
} # => locate_support_files()

# Disable terminal echo, if possible, otherwise warn
hide_read_pass() {
	# 3040 - In POSIX sh, set option [name] is undefined
	# 3045 - In POSIX sh, some-command-with-flag is undefined
	# 3061 - In POSIX sh, read without a variable is undefined.
	# shellcheck disable=SC3040,SC3045,SC3061
	if stty -echo 2>/dev/null; then
		prompt_restore=1
		read -r "$@"
		stty echo
	elif (set +o echo 2>/dev/null); then
		prompt_restore=2
		set +o echo
		read -r "$@"
		set -o echo
	elif (echo | read -r -s 2>/dev/null) ; then
		read -r -s "$@"
	else
		warn "\
Could not disable echo. Password will be shown on screen!"
		read -r "$@"
	fi
	prompt_restore=0
} # => hide_read_pass()

# Get passphrase
get_passphrase() {
	t="$1"; shift || die "password malfunction"
	while :; do
		r=""
		printf '\n%s' "$*"
		hide_read_pass r

		if [ "${#r}" -lt 4 ]; then
			printf '\n%s\n' \
				"Passphrase must be at least 4 characters!"
		else
			# shellcheck disable=SC2229 # does not read 't'
			read -r "$t" <<- SECRET
				$r
				SECRET

			unset -v r t
			print
			return 0
		fi
	done
} # => get_passphrase()

# build-ca backend:
build_ca() {
	cipher="-aes256"
	unset -v sub_ca date_stamp x509 error_info \
		ca_password_via_cmdline

	while [ "$1" ]; do
		case "$1" in
			intca|subca)
				sub_ca=1
				;;
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			raw*)
				EASYRSA_RAW_CA=1
				;;
			*) user_error "Unknown command option: '$1'"
		esac
		shift
	done

	out_key="$EASYRSA_PKI/private/ca.key"
	# setup for an intermediate CA
	if [ "$sub_ca" ]; then
		# Generate a CSR
		out_file="$EASYRSA_PKI/reqs/ca.req"
	else
		# Generate a certificate
		out_file="$EASYRSA_PKI/ca.crt"
		date_stamp=1
		x509=1
	fi

	# RAW mode must take priority
	if [ "$EASYRSA_RAW_CA" ]; then
		unset -v EASYRSA_NO_PASS EASYRSA_PASSOUT EASYRSA_PASSIN
		verbose "build-ca: CA password RAW method"
	else
		# If encrypted then create the CA key with AES256 cipher
		if [ "$EASYRSA_NO_PASS" ]; then
			unset -v cipher
		else
			unset -v no_password
		fi
	fi

	# Test for existing CA, and complain if already present
	if verify_ca_init test; then
		user_error "\
Unable to create a CA as you already seem to have one set up.
If you intended to start a new CA, run init-pki first."
	fi

	# If a private key exists, an intermediate ca was created
	# but not signed.
	# Notify user and require a signed ca.crt or a init-pki:
	if [ -f "$out_key" ]; then
		user_error "\
A CA private key exists but no ca.crt is found in your PKI:
* $EASYRSA_PKI

Refusing to create a new CA as this would overwrite your
current CA. To start a new CA, run init-pki first."
	fi

	# create necessary dirs:
	err_msg="\
Unable to create necessary PKI files (permissions?)"

	easyrsa_mkdir "${EASYRSA_PKI}"/certs_by_serial
	easyrsa_mkdir "${EASYRSA_PKI}"/revoked
	easyrsa_mkdir "${EASYRSA_PKI}"/revoked/certs_by_serial
	easyrsa_mkdir "${EASYRSA_PKI}"/revoked/private_by_serial

	# create necessary files:
	printf "" > \
		"$EASYRSA_PKI/index.txt" || die "$err_msg"
	printf '%s\n' "01" \
		> "$EASYRSA_PKI/serial" || die "$err_msg"
	unset -v err_msg

	# If one exists then recreate TLS Key
	tls_key_file="$EASYRSA_PKI"/private/easyrsa-tls.key
	old_tls_key_file="$EASYRSA_PKI"/easyrsa-keepsafe-tls.key
	if [ -f "$old_tls_key_file" ]; then
		confirm "Re-install existing Easy-RSA TLS Key ? " yes "
An Easy-RSA TLS Key, saved by 'init-pki soft', has been found.
This TLS Key is in use by your VPN, it is recommended that you
re-install this TLS Key.

Note:
This is a private key and will NOT be added to new inline files.

To create a new Easy-RSA TLS Key, delete this old TLS Key above."
		cp "$old_tls_key_file" "$tls_key_file" || \
			warn "Failed to install TLS Key!"
		tls_key_msg="${NL}
NOTICE: The previous Easy-RSA TLS Key has been installed:
* $tls_key_file

This TLS Key will NOT be added to new inline files. These new
inline files can then be easily distributed to your servers and
clients. The TLS Key that your servers and clients have previously
received, can be added to the inline file manually.

To re-enable automatically adding this TLS Key to inline files,
simply delete the backup TLS Key at:
* $old_tls_key_file

To create a new Easy-RSA TLS Key, delete both TLS Keys above."
	else
		tls_key_msg="${NL}
Create an OpenVPN TLS-AUTH|TLS-CRYPT-V1 key now: See 'help gen-tls'"
	fi

	# Set ssl batch mode, as required
	[ "$EASYRSA_BATCH" ] && ssl_batch=1

	# Default CA commonName
	if [ "$EASYRSA_REQ_CN" = ChangeMe ]; then
		if [ "$sub_ca" ]; then
			export EASYRSA_REQ_CN="Easy-RSA Sub-CA"
		else
			export EASYRSA_REQ_CN="Easy-RSA CA"
		fi
	fi

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	# Assign cert and key temp files
	out_key_tmp=""
	easyrsa_mktemp out_key_tmp || \
		die "build_ca - easyrsa_mktemp out_key_tmp"
	out_file_tmp=""
	easyrsa_mktemp out_file_tmp || \
		die "build_ca - easyrsa_mktemp out_file_tmp"

	# Get passphrase from user if necessary
	if [ "$EASYRSA_RAW_CA" ]
	then
		# Passphrase will be provided
		confirm "
       Accept ?  " yes "\
Raw CA mode
===========

  CA password must be input THREE times:

    1. Set the password.
    2. Confirm the password.
    3. Use the password. (Create the Root CA)"

	elif [ "$EASYRSA_NO_PASS" ]
	then
		: # No passphrase required

	elif [ "$EASYRSA_PASSOUT" ] && [ "$EASYRSA_PASSIN" ]
	then
		# passphrase defined on command line
		# Both --passout and --passin
		# must be defined for a CA with a password
		ca_password_via_cmdline=1

	else
		# Assign passphrase vars
		# Heed shellcheck SC2154
		p=""
		q=""

		# Get passphrase p
		get_passphrase p \
			"Enter New CA Key Passphrase: "

		# Confirm passphrase q
		get_passphrase q \
			"Confirm New CA Key Passphrase: "

		# Validate passphrase
		if [ "$p" ] && [ "$p" = "$q" ]; then
			# CA password via temp-files
			in_key_pass_tmp=""
			easyrsa_mktemp in_key_pass_tmp || \
				die "build_ca - in_key_pass_tmp"
			out_key_pass_tmp=""
			easyrsa_mktemp out_key_pass_tmp || \
				die "build_ca - out_key_pass_tmp"
			printf "%s" "$p" > "$in_key_pass_tmp" || \
				die "in_key_pass_tmp: write"
			printf "%s" "$p" > "$out_key_pass_tmp" || \
				die "out_key_pass_tmp: write"
			unset -v p q
		else
			unset -v p q
			user_error "Passphrases do not match!"
		fi
	fi

	# Find or create x509 CA file
	if [ -f "$EASYRSA_EXT_DIR/ca" ]; then
		# Use the x509-types/ca file
		x509_type_file="$EASYRSA_EXT_DIR/ca"
	else
		# Use a temp file
		write_x509_type_tmp ca
		x509_type_file="$write_x509_file_tmp"
	fi

	# keyUsage critical
	if [ "$EASYRSA_KU_CRIT" ]; then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "build-ca - easyrsa_mktemp KU crit_tmp"

		add_critical_attrib keyUsage "$x509_type_file" \
			"$crit_tmp" || die "build-ca - KU add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		verbose "build_ca: keyUsage critical OK"
	fi

	# basicConstraints critical
	if [ "$EASYRSA_BC_CRIT" ]; then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "build-ca - easyrsa_mktemp BC crit_tmp"

		add_critical_attrib basicConstraints "$x509_type_file" \
			"$crit_tmp" || die "build-ca - BC add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		verbose "build_ca: basicConstraints critical OK"
	fi

	# Find or create x509 COMMON file
	if [ -f "$EASYRSA_EXT_DIR/COMMON" ]; then
		# Use the x509-types/COMMON file
		x509_COMMON_file="$EASYRSA_EXT_DIR/COMMON"
	else
		# Use a temp file
		write_x509_type_tmp COMMON
		x509_COMMON_file="$write_x509_file_tmp"
	fi

	# Check for insert-marker in ssl config file
	if ! grep -q '^#%CA_X509_TYPES_EXTRA_EXTS%' \
		"$EASYRSA_SSL_CONF"
	then
		die "\
This openssl config file does not support X509-type 'ca'.
* $EASYRSA_SSL_CONF

Please update 'openssl-easyrsa.cnf' to the latest Easy-RSA release."
	fi

	# Assign awkscript to insert EASYRSA_EXTRA_EXTS
	# shellcheck disable=SC2016 # No expand '' - build_ca()
	awkscript='\
{if ( match($0, "^#%CA_X509_TYPES_EXTRA_EXTS%") )
{ while ( getline<"/dev/stdin" ) {print} next }
{print}
}'

	# Assign tmp-file for config
	adjusted_ssl_cnf_tmp=""
	easyrsa_mktemp adjusted_ssl_cnf_tmp || \
		die "build_ca - easyrsa_mktemp adjusted_ssl_cnf_tmp"

	# Insert x509-types COMMON and 'ca' and EASYRSA_EXTRA_EXTS
	{
		# X509 files
		cat "$x509_type_file" "$x509_COMMON_file"

		# User extensions
		[ "$EASYRSA_EXTRA_EXTS" ] && \
			print "$EASYRSA_EXTRA_EXTS"

	} | awk "$awkscript" "$EASYRSA_SSL_CONF" \
			> "$adjusted_ssl_cnf_tmp" || \
				die "Copying X509_TYPES to config file failed"
	verbose "build-ca: insert x509 and extensions OK"

	# Use this new SSL config for the rest of this function
	EASYRSA_SSL_CONF="$adjusted_ssl_cnf_tmp"

	# Generate CA Key
	case "$EASYRSA_ALGO" in
	rsa)
	easyrsa_openssl genpkey \
		-algorithm "$EASYRSA_ALGO" \
		-pkeyopt rsa_keygen_bits:"$EASYRSA_ALGO_PARAMS" \
		-out "$out_key_tmp" \
		${cipher:+ "$cipher"} \
		${EASYRSA_PASSOUT:+ -pass "$EASYRSA_PASSOUT"} \
		${out_key_pass_tmp:+ -pass file:"$out_key_pass_tmp"} \
			|| die "Failed create CA private key"
	;;
	ec)
	easyrsa_openssl genpkey \
		-paramfile "$EASYRSA_ALGO_PARAMS" \
		-out "$out_key_tmp" \
		${cipher:+ "$cipher"} \
		${EASYRSA_PASSOUT:+ -pass "$EASYRSA_PASSOUT"} \
		${out_key_pass_tmp:+ -pass file:"$out_key_pass_tmp"} \
			|| die "Failed create CA private key"
	;;
	ed)
	easyrsa_openssl genpkey \
		-algorithm "$EASYRSA_CURVE" \
		-out "$out_key_tmp" \
		${cipher:+ "$cipher"} \
		${EASYRSA_PASSOUT:+ -pass "$EASYRSA_PASSOUT"} \
		${out_key_pass_tmp:+ -pass file:"$out_key_pass_tmp"} \
			|| die "Failed create CA private key"
	;;
	*) die "Unknown algorithm: $EASYRSA_ALGO"
	esac

	# verbose notice
	if [ "$EASYRSA_RAW_CA" ]; then
		verbose "\
build_ca: CA key password created via RAW"
	else
		if [ "$ca_password_via_cmdline" ]; then
			verbose "\
build_ca: CA key password created via command options"
		else
			if [ "$EASYRSA_NO_PASS" ]; then
				verbose "\
build_ca: CA key has no password"
			else
				verbose "\
build_ca: CA key password created via temp-files"
			fi
		fi
	fi

	# Generate the CA keypair:
	easyrsa_openssl req -utf8 -new \
		-key "$out_key_tmp" \
		-out "$out_file_tmp" \
		${ssl_batch:+ -batch} \
		${x509:+ -x509} \
		${date_stamp:+ -days "$EASYRSA_CA_EXPIRE"} \
		${EASYRSA_DIGEST:+ -"$EASYRSA_DIGEST"} \
		${EASYRSA_NO_PASS:+ "$no_password"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
		${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} \
		${in_key_pass_tmp:+ -passin file:"$in_key_pass_tmp"} \
		${out_key_pass_tmp:+ -passout file:"$out_key_pass_tmp"} \
			|| die "Failed to build the CA keypair"

	# Move temp-files to target-files
	mv "$out_key_tmp" "$out_key" || mv_temp_error=1
	mv "$out_file_tmp" "$out_file" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		rm -f "$out_key" "$out_file"
		die "Failed to move new CA files."
	fi

	# Success messages
	if [ "$sub_ca" ]; then
		notice "\
Your intermediate CA request is at:
* $out_file
  and now must be sent to your parent CA for signing.

Prior to signing operations, place your resulting Sub-CA cert at:
* $EASYRSA_PKI/ca.crt"
	else
		notice "\
CA creation complete. Your new CA certificate is at:
* $out_file${tls_key_msg}

Build-ca completed successfully."
	fi
} # => build_ca()

# Build self signed key pair
self_sign() {
	# Define x509 type
	case "$1" in
		server)
			selfsign_eku=serverAuth
			crt_type=self-signed-server
			;;
		client)
			selfsign_eku=clientAuth
			crt_type=self-signed-client
			;;
		*)
			die "self_sign: Unknown EKU '$1'"
	esac
	shift

	# pull $file_name_base
	[ "$1" ] || user_error "\
Error: didn't find a file base name as the first argument.
Run easyrsa without commands for usage and command help."

	file_name_base="$1"
	shift

	# Prohibit --req-cn
	[ "$EASYRSA_REQ_CN" = ChangeMe ] || user_error "\
Option conflict --req-cn:
* '$cmd' does not support setting an external commonName"

	# Enforce commonName
	export EASYRSA_REQ_CN="$file_name_base"

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	# Refuse option as name
	case "$file_name_base" in
		nopass)
			user_error "Refusing '$file_name_base' as name."
	esac

	# function opts support
	while [ "$1" ]; do
		case "$1" in
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			*)
				user_error "Unknown command option: '$1'"
		esac
		shift
	done

	# Assign output files
	key_out="$EASYRSA_PKI/private/${file_name_base}.key"
	crt_out="$EASYRSA_PKI/issued/${file_name_base}.crt"
	inline_out="$EASYRSA_PKI/inline/${file_name_base}.inline"

	# key file must NOT exist
	[ -f "$key_out" ] && user_error "\
Cannot self-sign this request for '$file_name_base'.
Conflicting key exists at:
* $key_out"

	# Certificate file must NOT exist
	[ -f "$crt_out" ] && user_error "\
Cannot self-sign this request for '$file_name_base'.
Conflicting certificate exists at:
* $crt_out"

	# Check algo and curve
	case "$EASYRSA_ALGO" in
		rsa|ec)
			# Silently use ec instead of rsa
			export EASYRSA_ALGO=ec
			# Selectively set --curve=secp384r1
			set_var EASYRSA_CURVE secp384r1

			# temp-file for params-file
			selfsign_params_file=""
			easyrsa_mktemp selfsign_params_file || \
				die "self_sign - easyrsa_mktemp selfsign_params_file"

			# params-file
			"$EASYRSA_OPENSSL" ecparam \
				-name "$EASYRSA_CURVE" \
				-out "$selfsign_params_file" || \
					die "self_sign - params-file failed"

			newkey_params="$EASYRSA_ALGO":"$selfsign_params_file"
			;;
		ed)
			# Selectively set --curve=ed25519
			set_var EASYRSA_CURVE ed25519
			newkey_params="$EASYRSA_CURVE"
			;;
		*)
			user_error "Unrecognised algorithm: '$EASYRSA_ALGO'"
	esac

	verbose "\
self-sign: Use ALGO:'$EASYRSA_ALGO' / CURVE:'$EASYRSA_CURVE'"

	# Assign tmp-file for config
	adjusted_ssl_cnf_tmp=""
	easyrsa_mktemp adjusted_ssl_cnf_tmp || \
		die "self_sign - easyrsa_mktemp adjusted_ssl_cnf_tmp"

	# Assign awkscript to insert EASYRSA_EXTRA_EXTS
	# shellcheck disable=SC2016 # No expand '' - build_ca()
	awkscript='\
{if ( match($0, "^#%CA_X509_TYPES_EXTRA_EXTS%") )
	{ while ( getline<"/dev/stdin" ) {print} next }
 {print}
}'

	# Find or create x509 selfsign file
	if [ -f "$EASYRSA_EXT_DIR/selfsign" ]; then
		# Use the x509-types/selfsign file
		x509_selfsign_file="$EASYRSA_EXT_DIR/selfsign"
	else
		# Use a temp file
		write_x509_type_tmp selfsign
		x509_selfsign_file="$write_x509_file_tmp"
	fi

	# Find or create x509 COMMON file
	if [ -f "$EASYRSA_EXT_DIR/COMMON" ]; then
		# Use the x509-types/COMMON file
		x509_COMMON_file="$EASYRSA_EXT_DIR/COMMON"
	else
		# Use a temp file
		write_x509_type_tmp COMMON
		x509_COMMON_file="$write_x509_file_tmp"
	fi

	# Insert x509-types COMMON and 'selfsign' and EASYRSA_EXTRA_EXTS
	{
		# X509 files
		cat "$x509_selfsign_file" "$x509_COMMON_file"

		# User extensions
		[ "$EASYRSA_EXTRA_EXTS" ] && \
			print "$EASYRSA_EXTRA_EXTS"

	} | awk "$awkscript" "$EASYRSA_SSL_CONF" \
			> "$adjusted_ssl_cnf_tmp" || \
				die "Copying X509_TYPES to config file failed"
	verbose "self_sign: insert x509 and extensions OK"

	# Use this new SSL config for the rest of this function
	EASYRSA_SSL_CONF="$adjusted_ssl_cnf_tmp"

	# Create temp-files for output
	tmp_key_out=""
	easyrsa_mktemp tmp_key_out || \
		die "self_sign - easyrsa_mktemp tmp_key_out"

	tmp_crt_out=""
	easyrsa_mktemp tmp_crt_out || \
		die "self_sign - easyrsa_mktemp tmp_crt_out"

	# create self-signed key pair
	easyrsa_openssl req -x509 -utf8 -sha256 -text \
		-newkey "$newkey_params" \
		-keyout "$tmp_key_out" \
		-out "$tmp_crt_out" \
		-subj "/CN=$file_name_base" \
		${EASYRSA_NO_PASS:+ "$no_password"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
		${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} \
		${EASYRSA_CERT_EXPIRE:+ -days "$EASYRSA_CERT_EXPIRE"} \
		${EASYRSA_START_DATE:+ -startdate "$EASYRSA_START_DATE"} \
		${EASYRSA_END_DATE:+ -enddate "$EASYRSA_END_DATE"}

	# Move temp-files to target-files
	mv "$tmp_key_out" "$key_out" || mv_temp_error=1
	mv "$tmp_crt_out" "$crt_out" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		rm -f "$key_out" "$crt_out"
		die "Failed to move new key/cert files."
	fi

	# inline key/cert/fingerprint
	inline_file "$file_name_base"

	# User info
	notice "\
Self-signed '$EASYRSA_ALGO/$EASYRSA_CURVE' \
key and certificate created:
* $key_out
* $crt_out"
} # => self_sign()

# gen-dh backend:
gen_dh() {
	out_file="$EASYRSA_PKI/dh.pem"

	# check to see if we already have a dh parameters file
	if [ -f "$out_file" ]; then
		if [ "$EASYRSA_BATCH" ]; then
			# if batch is enabled, die
			user_error "\
DH parameters file already exists
at: $out_file"
		else
			# warn the user, allow to force overwrite
			confirm "Overwrite?  " "yes" "\
DH parameters file already exists
at: $out_file"
		fi
	fi

	# Create a temp file
	# otherwise user abort leaves an incomplete dh.pem
	tmp_dh_file=""
	easyrsa_mktemp tmp_dh_file || \
		die "gen_dh - easyrsa_mktemp tmp_dh_file"

	# Generate dh.pem
	easyrsa_openssl dhparam -out "$tmp_dh_file" \
		"$EASYRSA_KEY_SIZE" || die "Failed to generate DH params"

	# Validate dh.pem
	easyrsa_openssl dhparam -in "$tmp_dh_file" \
		-check -noout || die "Failed to validate DH params"

	# Move temp-files to target-files
	mv "$tmp_dh_file" "$out_file" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		rm -f "$out_file"
		die "Failed to move temp DH file."
	fi

	notice "
DH parameters of size $EASYRSA_KEY_SIZE created at:
* $out_file"
} # => gen_dh()

# gen-req and key backend:
gen_req() {
	# pull filename, use as default interactive CommonName
	[ "$1" ] || user_error "\
Error: gen-req must have a file-name-base as the first argument.
Run easyrsa without commands for usage and commands."

	file_name_base="$1"
	shift # scrape off file-name-base

	# Set ssl batch mode as required
	[ "$EASYRSA_BATCH" ] && ssl_batch=1

	# Set commonName
	if [ "$EASYRSA_REQ_CN" = ChangeMe ]; then
		export EASYRSA_REQ_CN="$file_name_base"
	fi

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	# Output files
	key_out="$EASYRSA_PKI/private/${file_name_base}.key"
	req_out="$EASYRSA_PKI/reqs/${file_name_base}.req"

	# function opts support
	while [ "$1" ]; do
		case "$1" in
			text)
				text=1
				;;
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			# batch flag supports internal caller build_full()
			batch)
				ssl_batch=1
				;;
			*) user_error "Unknown command option: '$1'"
		esac
		shift
	done

	# don't wipe out an existing request without confirmation
	[ -f "$req_out" ] && confirm "Confirm request overwrite: " "yes" "\

WARNING!!!

An existing request file was found at
* $req_out

Continuing with key generation will replace this request."

	# don't wipe out an existing private key without confirmation
	[ -f "$key_out" ] && confirm "Confirm key overwrite: " "yes" "\

WARNING!!!

An existing private key was found at
* $key_out

Continuing with key generation will replace this key."

	# When EASYRSA_EXTRA_EXTS is defined,
	# append it to openssl's [req] section:
	if [ "$EASYRSA_EXTRA_EXTS" ]; then
		# Check for insert-marker in ssl config file
		if ! grep -q '^#%EXTRA_EXTS%' "$EASYRSA_SSL_CONF"
		then
			die "\
This openssl config file does \
does not support EASYRSA_EXTRA_EXTS.
* $EASYRSA_SSL_CONF

Please update 'openssl-easyrsa.cnf' \
to the latest Easy-RSA release."
		fi

		# Setup & insert the extra ext data keyed by magic line
		extra_exts="
req_extensions = req_extra
[ req_extra ]
$EASYRSA_EXTRA_EXTS"
		# shellcheck disable=SC2016 # No expand '' - gen_req()
		awkscript='
{if ( match($0, "^#%EXTRA_EXTS%") )
	{ while ( getline<"/dev/stdin" ) {print} next }
 {print}
}'
		# Assign temp-file for config
		adjusted_ssl_cnf_tmp=""
		easyrsa_mktemp adjusted_ssl_cnf_tmp || \
			die "gen_req - easyrsa_mktemp adjusted_ssl_cnf_tmp"

		# Insert $extra_exts @ %EXTRA_EXTS% in SSL Config
		print "$extra_exts" | \
			awk "$awkscript" "$EASYRSA_SSL_CONF" \
			> "$adjusted_ssl_cnf_tmp" || \
				die "Writing SSL config to temp file failed"

		[ "${EASYRSA_SAN_CRIT}" ] && \
			verbose "gen-req: SAN critical OK"

		# Use this SSL config for the rest of this function
		EASYRSA_SSL_CONF="$adjusted_ssl_cnf_tmp"
	fi

	# Name temp files
	key_out_tmp=""
	easyrsa_mktemp key_out_tmp || \
		die "gen_req - easyrsa_mktemp key_out_tmp"
	req_out_tmp=""
	easyrsa_mktemp req_out_tmp || \
		die "gen_req - easyrsa_mktemp req_out_tmp"

	# Set algorithm options
	algo_opts=""
	case "$EASYRSA_ALGO" in
		rsa|ec)
			# Set elliptic curve parameters-file
			# or RSA bit-length
			algo_opts="$EASYRSA_ALGO:$EASYRSA_ALGO_PARAMS"
			;;
		ed)
			# Set Edwards curve name
			algo_opts="$EASYRSA_CURVE"
			;;
		*)
			die "gen_req - Unknown algorithm: $EASYRSA_ALGO"
	esac

	# Generate request
	if easyrsa_openssl req -utf8 -new -newkey "$algo_opts" \
		-keyout "$key_out_tmp" \
		-out "$req_out_tmp" \
		${EASYRSA_NO_PASS:+ "$no_password"} \
		${text:+ -text} \
		${ssl_batch:+ -batch} \
		${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"}
	then
		: # ok
	else
		die "Failed to generate request"
	fi

	# Move temp-files to target-files
	mv "$key_out_tmp" "$key_out" || mv_temp_error=1
	mv "$req_out_tmp" "$req_out" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		rm -f "$key_out" "$req_out"
		die "Failed to move temp key/req file."
	fi

	# Success messages
	notice "\
Private-Key and Public-Certificate-Request files created.
Your files are:
* req: $req_out
* key: $key_out${do_build_full:+ $NL}"
} # => gen_req()

# common signing backend
sign_req() {
	crt_type="$1"
	file_name_base="$2"

	# Verify $crt_type is valid
	case "$crt_type" in
		ca|server|serverClient|client|codeSigning|email|kdc)
			: # All known types plus CA for sub-ca
		;;
		*)
			warn "\
Unrecognised x509-type: '$crt_type'

In order to sign a custom X509 Type certificate, there must be a
corresponding SSL configuration file in the 'x509-types' folder."
	esac

	# Check argument sanity:
	[ "$file_name_base" ] || user_error "\
Incorrect number of arguments provided to sign-req:
expected 2, got $# (see command help for usage)"

	req_in="$EASYRSA_PKI/reqs/$file_name_base.req"
	crt_out="$EASYRSA_PKI/issued/$file_name_base.crt"
	shift 2

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	# Check optional subject
	force_subj=
	while [ "$1" ]; do
		case "$1" in
			nopass)
				warn "Ignoring option '$1'"
				;;
			newsubj*)
				# verify force_subj opts are used correctly
				[ "$EASYRSA_NEW_SUBJECT" ] || user_error "\
To force a new certificate subject, global option --new-subject
must also be specified."
				force_subj="$EASYRSA_NEW_SUBJECT"
				;;
			preserve*)
				export EASYRSA_PRESERVE_DN=1
				;;
			*)
				user_error "Unknown option '$1'"
		esac
		shift
	done

	# verify force_subj opts are used correctly
	if [ "$EASYRSA_NEW_SUBJECT" ]; then
		[ "$force_subj" ] || user_error "\
To force a new certificate subject, command option 'newsubj'
must also be specified."
	fi

	# Cert type must NOT be COMMON
	[ "$crt_type" = COMMON ] && user_error "\
Invalid certificate type: '$crt_type'"

	# Request file must exist
	[ -f "$req_in" ] || user_error "\
No request found for the input: '$file_name_base'
Expected to find the request at:
* $req_in"

	# Certificate file must NOT exist
	[ -f "$crt_out" ] && user_error "\
Cannot sign this request for '$file_name_base'.
Conflicting certificate exists at:
* $crt_out"

	# Confirm input is a cert req
	verify_file req "$req_in" || user_error "\
The certificate request file is not in a valid X509 format:
* $req_in"

	# Randomize Serial number
	if [ "$EASYRSA_RAND_SN" != no ]; then
		serial=""
		check_serial=""
		unset -v serial_is_unique
		for i in 1 2 3 4 5; do
			easyrsa_random 16 serial

			# Require 128bit serial number
			[ "$serial" = "${serial#00}" ] || continue

			# Check for duplicate serial in CA db
			if check_serial_unique "$serial" batch; then
				serial_is_unique=1
				break
			fi
		done

		# Check for unique_serial
		[ "$serial_is_unique" ] || die "\
sign_req - Randomize Serial number failed:

$check_serial"

		# Print random $serial to pki/serial file
		# for use by SSL config
		print "$serial" > "$EASYRSA_PKI/serial" || \
			die "sign_req - write serial to file"
		unset -v serial check_serial serial_is_unique
	fi

	# When EASYRSA_CP_EXT is defined,
	# adjust openssl's [default_ca] section:
	if [ "$EASYRSA_CP_EXT" ]; then
		# Check for insert-marker in ssl config file
		if ! grep -q '^#%COPY_EXTS%' "$EASYRSA_SSL_CONF"
		then
			die "\
This openssl config file does \
not support option '--copy-ext'.
* $EASYRSA_SSL_CONF

Please update 'openssl-easyrsa.cnf' \
to the latest Easy-RSA release."
		fi

		# Setup & insert the copy_extensions data
		# keyed by a magic line
		copy_exts="copy_extensions = copy"
		# shellcheck disable=SC2016 # No expand '' - sign_req()
		awkscript='
{if ( match($0, "^#%COPY_EXTS%") )
	{ while ( getline<"/dev/stdin" ) {print} next }
 {print}
}'
		# Assign temp-file for config
		adjusted_ssl_cnf_tmp=""
		easyrsa_mktemp adjusted_ssl_cnf_tmp || \
			die "sign_req - easyrsa_mktemp adjusted_ssl_cnf_tmp"

		print "$copy_exts" | \
			awk "$awkscript" "$EASYRSA_SSL_CONF" \
				> "$adjusted_ssl_cnf_tmp" || die "\
Writing 'copy_exts' to SSL config temp-file failed"

		# Use this SSL config for the rest of this function
		EASYRSA_SSL_CONF="$adjusted_ssl_cnf_tmp"
		verbose "sign_req: Using '$copy_exts'"
		verbose "sign_req: EASYRSA_SSL_CONF = $EASYRSA_SSL_CONF"
	fi

	# Find or create x509-type file
	if [ -f "$EASYRSA_EXT_DIR/$crt_type" ]; then
		# Use the x509-types/$crt_type file
		x509_type_file="$EASYRSA_EXT_DIR/$crt_type"
	else
		# Use a temp file
		write_x509_type_tmp "$crt_type"
		x509_type_file="$write_x509_file_tmp"
	fi

	# keyUsage critical
	confirm_ku_crit=
	if [ "$EASYRSA_KU_CRIT" ]; then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "sign-req - easyrsa_mktemp KU crit_tmp"

		add_critical_attrib keyUsage "$x509_type_file" \
			"$crit_tmp" || die "sign-req - KU add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		confirm_ku_crit="  keyUsage:         'critical'${NL}"
		verbose "sign_req: keyUsage critical OK"
	fi

	# basicConstraints critical
	confirm_bc_crit=
	if [ "$EASYRSA_BC_CRIT" ]; then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "sign-req - easyrsa_mktemp BC crit_tmp"

		add_critical_attrib basicConstraints "$x509_type_file" \
			"$crit_tmp" || die "sign-req - BC add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		confirm_bc_crit="  basicConstraints: 'critical'${NL}"
		verbose "sign_req: basicConstraints critical OK"
	fi

	# extendedKeyUsage critical
	confirm_eku_crit=
	if [ "$EASYRSA_EKU_CRIT" ]; then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "sign-req - easyrsa_mktemp EKU crit_tmp"

		add_critical_attrib extendedKeyUsage "$x509_type_file" \
			"$crit_tmp" || die "sign-req - EKU add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		confirm_eku_crit="  extendedKeyUsage: 'critical'${NL}"
		verbose "sign_req: extendedKeyUsage critical OK"
	fi

	# Find or create x509 COMMON file
	if [ -f "$EASYRSA_EXT_DIR/COMMON" ]; then
		# Use the x509-types/COMMON file
		x509_COMMON_file="$EASYRSA_EXT_DIR/COMMON"
	else
		# Use a temp file
		write_x509_type_tmp COMMON
		x509_COMMON_file="$write_x509_file_tmp"
	fi

	# Support a dynamic CA path length when present:
	unset -v basicConstraints confirm_bc_len
	if [ "$crt_type" = "ca" ] && [ "$EASYRSA_SUBCA_LEN" ]
	then
		# Print the last occurrence of basicConstraints in
		# x509-types/ca
		# If basicConstraints is not defined then bail
		# shellcheck disable=SC2016 # No expand '' - sign_req()
		awkscript='\
/^[[:blank:]]*basicConstraints[[:blank:]]*=/ { bC=$0 }
END { if (length(bC) == 0 ) exit 1; print bC }'
		basicConstraints="$(
			awk "$awkscript" "$x509_type_file"
			)" || die "\
basicConstraints is not defined, cannot use 'pathlen'"
		confirm_pathlen="
  Path length:      '$EASYRSA_SUBCA_LEN'${NL}"
		verbose "sign_req: Using basicConstraints pathlen"
	fi

	# Deprecated Netscape extension support
	case "$EASYRSA_NS_SUPPORT" in
	[yY][eE][sS])

		confirm "Confirm use of Netscape extensions: " yes \
			"WARNING: Netscape extensions are DEPRECATED!"

		# Netscape extension
		case "$crt_type" in
			serverClient)
				ns_cert_type="nsCertType = serverClient" ;;
			server)
				ns_cert_type="nsCertType = server" ;;
			client)
				ns_cert_type="nsCertType = client" ;;
			ca)
				ns_cert_type="nsCertType = sslCA" ;;
			*)
				ns_cert_type="nsCertType = $crt_type"
		esac
		verbose "sign_req: Using $ns_cert_type"
		;;
	*)
		# ok No NS support required
		unset -v ns_cert_type
	esac

	# Get request CN
	# EASYRSA_REQ_CN MUST always be set to the CSR CN
	# or use --new-subect
	EASYRSA_REQ_CN="$(
		"$EASYRSA_OPENSSL" req -utf8 -in "$req_in" -noout \
			-subject -nameopt multiline | grep 'commonName'
	)" || warn "sign-req - EASYRSA_REQ_CN FAILED"
	EASYRSA_REQ_CN="${EASYRSA_REQ_CN##*= }"

	# Add auto SAN, if EASYRSA_AUTO_SAN is enabled
	if [ -z "$EASYRSA_SAN" ] && [ "$EASYRSA_AUTO_SAN" ]; then
		# Choose DNS:san or IP:san
		if print "$EASYRSA_REQ_CN" | grep -q \
			'^[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+$'
		then
			EASYRSA_SAN="IP:${EASYRSA_REQ_CN}"
		else
			EASYRSA_SAN="DNS:${EASYRSA_REQ_CN}"
		fi

		# Add auto SAN to EASYRSA_EXTRA_EXTS
		EASYRSA_EXTRA_EXTS="\
$EASYRSA_EXTRA_EXTS
subjectAltName = ${EASYRSA_SAN_CRIT}${EASYRSA_SAN}"
		verbose "sign-req: Auto SAN: ${EASYRSA_SAN}"
	fi

	# confirm SAN critical
	confirm_san_crit=
	if [ "${EASYRSA_SAN_CRIT}" ]; then
		confirm_san_crit="  subjectAltName:   'critical'${NL}"
		verbose "sign-req: SAN critical OK"
	fi

	# Generate the extensions file for this cert:
	ext_tmp=""
	easyrsa_mktemp ext_tmp || \
		die "sign_req - easyrsa_mktemp ext_tmp"

	# Begin output redirect
	{
		# Append $cert-type extensions
		cat "$x509_COMMON_file" "$x509_type_file"

		# Support a dynamic CA path length when present:
		if [ "$basicConstraints" ]; then
			print "$basicConstraints, pathlen:$EASYRSA_SUBCA_LEN"
		fi

		# Deprecated Netscape extension support
		if [ "$ns_cert_type" ]; then
			print "$ns_cert_type"
			print "nsComment = \"$EASYRSA_NS_COMMENT\""
		fi

		# Add user supplied extra extensions
		# and/or SAN extension
		if [ "$EASYRSA_EXTRA_EXTS" ]; then
			print "$EASYRSA_EXTRA_EXTS"
		fi
	} > "$ext_tmp" || die "\
Failed to create temp extension file (bad permissions?) at:
* $ext_tmp"
	verbose "sign_req: Generated extensions file OK"

	# Set confirm CN
	confirm_CN="  Requested CN:     '$EASYRSA_REQ_CN'"

	# Set confirm type
	confirm_type="  Requested type:   '$crt_type'"

	# Set confirm valid_period message
	if [ "$EASYRSA_END_DATE" ]; then
		confirm_period="  Valid until:      '$EASYRSA_END_DATE'"
	else
		confirm_period="  Valid for:        '$EASYRSA_CERT_EXPIRE' days"
	fi

	# Set confirm DN
	if [ "$force_subj" ]; then
		confirm_dn="${NL}* Forced Subject:   '$force_subj'${NL}"
	else
		confirm_dn="${NL}$(display_dn req "$req_in")" || \
			die "sign-req: display_dn"
	fi

	# Set confirm SAN
	# SAN from .req
	if [ "$EASYRSA_CP_EXT" ]; then
		# capture complete CSR
		req_text="$(
			"$EASYRSA_OPENSSL" req -utf8 -in "$req_in" -noout -text
			)" || die "sign-req: openssl: req_text"

		# Check CSR for any requested SAN
		if echo "$req_text" | \
			grep -q 'X509v3 Subject Alternative Name'
		then
			# extract requested SAN
			# 'grep -A' may not be strictly POSIX, die on error
			req_x509_san="$(
				echo "$req_text" | \
					grep -A 1 'X509v3 Subject Alternative Name'
			)" || die "sign-req: req_x509_san: grep -A 1 (POSIX)"
		else
			# No requested SAN
			req_x509_san=
		fi
	fi

	# Set confirm details
	confirm_critical_attribs="
${confirm_bc_crit}${confirm_ku_crit}\
${confirm_eku_crit}${confirm_san_crit}"

	confirm_details="\
${confirm_CN}
${confirm_type}${confirm_pathlen}
${confirm_period}
${confirm_critical_attribs}${confirm_dn}"

	# --san takes priority over req SAN and --copy-ext
	if [ "$EASYRSA_SAN" ]; then
		confirm_san="\
            X509v3 Subject Alternative Name:
                ${EASYRSA_SAN_CRIT}${EASYRSA_SAN}"
	else
		confirm_san="$req_x509_san"
	fi

	# Set confirm SAN
	if [ "$EASYRSA_SAN" ] || [ "$req_x509_san" ]; then
		confirm_details="$confirm_details${NL}${NL}$confirm_san"
	fi

	# Display the request subject in an easy-to-read format
	# Confirm the user wishes to sign this request
	# The foreign_request confirmation is not required
	# for build_full:
	if [ "$local_request" ]; then
		unset -v foreign_request
	else
		foreign_request="\
Please check over the details shown below for accuracy. \
Note that this request
has not been cryptographically verified. Please be sure \
it came from a trusted
source or that you have verified the request checksum \
with the sender.$NL"
	fi

	# Request FINAL user confirmation
	confirm "Confirm requested details: " "yes" "\
${foreign_request}You are about to sign the following certificate:

$confirm_details" # => confirm end

	# Assign temp cert file
	crt_out_tmp=""
	easyrsa_mktemp crt_out_tmp || \
		die "sign_req - easyrsa_mktemp crt_out_tmp"

	# sign request
	easyrsa_openssl ca -utf8 -batch \
		-in "$req_in" -out "$crt_out_tmp" \
		-extfile "$ext_tmp" \
		${EASYRSA_PRESERVE_DN:+ -preserveDN} \
		${force_subj:+ -subj "$force_subj"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
		${EASYRSA_NO_TEXT:+ -notext} \
		${EASYRSA_CERT_EXPIRE:+ -days "$EASYRSA_CERT_EXPIRE"} \
		${EASYRSA_START_DATE:+ -startdate "$EASYRSA_START_DATE"} \
		${EASYRSA_END_DATE:+ -enddate "$EASYRSA_END_DATE"} \
			|| die "\
Signing failed (openssl output above may have more detail)"
	verbose "sign_req: signed cert '$file_name_base' OK"

	# Move temp-files to target-files
	mv "$crt_out_tmp" "$crt_out" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		rm -f "$crt_out"
		die "Failed to move temp certificate file."
	fi

	# inline file
	inline_file "$file_name_base"

	# Success messages
	notice "\
Certificate created at:
* $crt_out"
} # => sign_req()

# Add 'critical' attribute to X509-type file
add_critical_attrib() {
	case "$1" in
		basicConstraints|keyUsage|extendedKeyUsage) : ;; # ok
		*) die "add_critical_attrib - usage: '$1'"
	esac

	[ -f "$2" ] || die "add_critical_attrib - file-2: '$2'"
	[ -f "$3" ] || die "add_critical_attrib - file-3: '$3'"

	sed s/"$1 = "/"$1 = critical,"/g "$2" > "$3"
} # => add_critical_attrib()

# Check serial in db
check_serial_unique() {
	[ "$1" ] || user_error "Serial number required!"
	case "$1" in
		(*[!1234567890abcdef]*)
			user_error "Invalid serial number: '$1'"
	esac

	# Check for openssl -status of serial number
	# Always errors out - Do not capture error
	check_serial="$(
			"$EASYRSA_OPENSSL" ca -status "$1" 2>&1
		)" || :

	# Check for duplicate serial in CA db
	case "$check_serial" in
		(*"not present in db"*)
			unique_serial_true=1
			verbose "check_serial_unique: unique_serial=true"
			;;
		*)
			unique_serial_true=
			verbose "check_serial_unique: unique_serial=false"
	esac

	# In batch mode return result only
	if [ "$2" = batch ] || [ "$EASYRSA_BATCH" ]; then
		if [ "$unique_serial_true" ]; then
			return 0
		else
			return 1
		fi
	fi

	# Otherwise, show result to user
	# and do not return any error code
	print "
check_serial_status RESULT:
========================================

$check_serial

========================================
COMPLETE"
} # => check_serial_unique()

# common build backend
# used to generate+sign in 1 step
build_full() {
	# pull filename base:
	[ "$2" ] || user_error "\
Error: didn't find a file base name as the first argument.
Run easyrsa without commands for usage and commands."

	crt_type="$1"
	name="$2"
	shift 2

	req_out="$EASYRSA_PKI/reqs/$name.req"
	key_out="$EASYRSA_PKI/private/$name.key"
	crt_out="$EASYRSA_PKI/issued/$name.crt"

	# function opts support
	while [ "$1" ]; do
		case "$1" in
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			*) user_error "Unknown command option: '$1'"
		esac
		shift
	done

	# abort on existing req/key/crt files
	err_exists="\
file already exists. Aborting build to avoid overwriting this file.
If you wish to continue, please use a different name.
Conflicting file found at:
*"
	[ -f "$req_out" ] && \
		user_error "Request $err_exists $req_out"
	[ -f "$key_out" ] && \
		user_error "Key $err_exists $key_out"
	[ -f "$crt_out" ] && \
		user_error "Certificate $err_exists $crt_out"
	unset -v err_exists

	# create request
	verbose "build_full: BEGIN gen_req"
	gen_req "$name" batch
	verbose "build_full: END gen_req"

	# Set to modify sign-req confirmation message
	local_request=1

	# Recreate temp-session and
	# drop edits to SSL Conf file
	remove_secure_session
	secure_session
	locate_support_files
	write_global_safe_ssl_cnf_tmp

	# Require --copy-ext
	export EASYRSA_CP_EXT=1

	# Sign it
	verbose "build_full: BEGIN sign_req"
	error_build_full_cleanup=1
	if sign_req "$crt_type" "$name"; then
		unset -v error_build_full_cleanup do_build_full
	else
		die "\
Failed to sign '$name' - \
See error messages above for details."
	fi
	verbose "build_full: END sign_req"
} # => build_full()

# Generate inline file V2
inline_file() {
	# Allow complete disable
	[ "$EASYRSA_DISABLE_INLINE" ] && return

	# definitive source
	[ "$1" ] || die "inline_file - Missing file_name_base"

	# make inline dirs
	easyrsa_mkdir "$EASYRSA_PKI"/inline
	easyrsa_mkdir "$EASYRSA_PKI"/inline/private

	# Source files
	crt_source="${EASYRSA_PKI}/issued/${1}.crt"
	key_source="${EASYRSA_PKI}/private/${1}.key"
	ca_source="$EASYRSA_PKI"/ca.crt
	tls_source="$EASYRSA_PKI"/private/easyrsa-tls.key
	old_tls_key_file="$EASYRSA_PKI"/easyrsa-keepsafe-tls.key

	# output
	inline_out="${EASYRSA_PKI}/inline/${1}.inline"
	print "\
# Inline files in the 'private' directory contain security keys which
# MUST only be transmitted over a secure connection, such as 'scp'." \
		> "$EASYRSA_PKI"/inline/private/README.inline.private
	inline_incomplete=
	inline_private=

	# Generate Inline data
	# Certificate
	if [ -f "$crt_source" ]; then
		crt_data="\
<cert>
$(cat "$crt_source")
</cert>"

		# Calculate decimal value for serial number
		# because openvpn uses decimal serial ?!?
		# for '--crl-verify /path/to/dir dir'
		# For reasons unknown..
		if which bc >/dev/null; then
			crt_serial="$(
				"$EASYRSA_OPENSSL" x509 -in "$crt_source" \
					-noout -serial
				)" || die "inline_file - SSL -serial failed"
			crt_serial="${crt_serial#*=}"
			crt_serial_dec="$(
					echo "ibase=16; $crt_serial" | bc
				)" || die "inline_file - HEX to DEC failed"
		else
			crt_serial_dec="Unavailable"
		fi

		# Generate fingerprint
		crt_fingerprint="$(
			"$EASYRSA_OPENSSL" x509 -in "$crt_source" \
				-noout -sha256 -fingerprint
			)" || die "inline_file - Failed -fingerprint"
		# strip prefix
		crt_fingerprint="${crt_fingerprint#*=}"

		# Certificate type
		if [ -z "$crt_type" ]; then
			ssl_cert_x509v3_eku "$crt_source" crt_type || \
				die "inline_file: Failed to set crt_type"
		fi

		# commonName
		crt_CN="$(
			display_dn x509 "$crt_source" | grep 'commonName'
		)" || die "inline_file: Failed to set crt_CN"
		# strip prefix
		crt_CN="${crt_CN#*= }"
	else
		inline_incomplete=1
		crt_data="\
# When you recieve your signed certificate place it in the
# 'pki/issued' sub-dir of your PKI and use command 'inline'
# to rebuild this inline file with your certificate.
# <cert>
# * Paste your user certificate here *
# </cert>"

		crt_fingerprint=unknown
		crt_type=unknown
		crt_CN=unknown
	fi

	# Private key
	if [ -f "$key_source" ]; then
		inline_private=1
		key_data="\
<key>
$(cat "$key_source")
</key>"
	else
		inline_incomplete=1
		key_data="\
# When you recieve your key place it in the
# 'pki/private' sub-dir of your PKI and use command 'inline'
# to rebuild this inline file with your key.
# <key>
# * Paste your private key here *
# </key>"
	fi

	# CA certificate
	if [ -f "$ca_source" ]; then
		ca_data="\
<ca>
$(cat "$ca_source")
</ca>"
	else
		inline_incomplete=1
		ca_data="\
# When you recieve your CA certificate place it in the
# 'pki' sub-dir of your PKI and use command 'inline'
# to rebuild this inline file with your CA certificate.
# <ca>
# * Paste your CA certificate here *
# </ca>"
	fi

	# TLS KEY - Set TLS auth|crypt key inline label
	if [ -f "$tls_source" ]; then
		tls_key_data="$(cat "$tls_source")"
		case "$tls_key_data" in
			*'TLS-AUTH'*) tls_key_label=tls-auth ;;
			*'TLS-CRYPT'*) tls_key_label=tls-crypt ;;
			*) tls_key_label=
		esac
	fi

	# Do NOT add TLS key if OLD TLS key exists
	# because this PSK has already been shared.
	if [ -f "$old_tls_key_file" ]; then
		tls_data="\
# Add the existing TLS AUTH/CRYPT-V1 Key here:
# <${tls_key_label}>
# * Paste The existing pre-shared TLS key here *
# </${tls_key_label}>"

		# Add --key-direction for TLS-AUTH
		[ "$tls_key_label" = tls-auth ] && \
			tls_data="$tls_data
#
# Add the required 'key-direction 0|1' here:
# key-direction 1"
		unset -v tls_key_data tls_key_label
	else
		# Add standard TLS key details
		if [ -f "$tls_source" ]; then
			inline_private=1
			if [ "$tls_key_label" ]; then
				tls_data="\
<${tls_key_label}>
${tls_key_data}
</${tls_key_label}>"
			else
				inline_incomplete=1
				tls_data="# Easy-RSA TLS Key not recognised!"
			fi
		else
			#inline_incomplete=1
			tls_data="# Easy-RSA TLS Key not found!"
		fi
	fi

	# Only support inline TLS keys for OpenVPN server/client use
	case "$crt_type" in
		server) key_direction="key-direction 0" ;;
		client) key_direction="key-direction 1" ;;
		*)
		verbose "inline: Unsupported certificate type: $crt_type"
		tls_key_label=
		key_direction=
		tls_data="# No TLS Key support for cert-type: $crt_type"
	esac

	# Add --key-direction for TLS-AUTH
	if [ "$tls_key_label" = tls-auth ]; then
		tls_data="${tls_data}${NL}${NL}${key_direction}"
	fi

	# If inline file has keys then redirect to 'private' dir
	[ "$inline_private" ] && \
		inline_out="${EASYRSA_PKI}/inline/private/${1}.inline"

	# Print data
	print "\
# Easy-RSA Inline file
# Certificate type: $crt_type
# commonName: $crt_CN
# SHA256 fingerprint:
# $crt_fingerprint
# Decimal serial number: $crt_serial_dec

$crt_data

$key_data

$ca_data

$tls_data
" > "$inline_out"

	# user info
	if [ "$inline_incomplete" ]; then
		warn "\
INCOMPLETE Inline file created:
* $inline_out"
	else
		notice "\
Inline file created:
* $inline_out"
	fi
} # => inline_file()

# revoke backend
revoke() {
	# Set cert directory (IE. type) to revoke
	cert_dir="$1"
	shift

	# pull filename base:
	[ "$1" ] || user_error "\
Error: didn't find a file base name as the first argument.
Run easyrsa without commands for usage and command help."

	# Assign file_name_base and dust off!
	file_name_base="$1"
	shift

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	in_dir="$EASYRSA_PKI"
	key_in="$in_dir/private/${file_name_base}.key"
	req_in="$in_dir/reqs/${file_name_base}.req"
	inline_pub="$in_dir/inline/${file_name_base}.inline"
	inline_pri="$in_dir/inline/private/${file_name_base}.inline"

	# input cert for revocation: issued, expired or renewed
	crt_in="${in_dir}/${cert_dir}/${file_name_base}.crt"

	# Assign possible "crl_reason"
	if [ "$1" ]; then
		crl_reason="$1"
		shift

		case "$crl_reason" in
			us|uns*) crl_reason=unspecified ;;
			kc|key*) crl_reason=keyCompromise ;;
			cc|[Cc][Aa]*) crl_reason=CACompromise ;;
			ac|aff*) crl_reason=affiliationChanged ;;
			ss|sup*) crl_reason=superseded ;;
			co|ces*) crl_reason=cessationOfOperation ;;
			ch|cer*) crl_reason=certificateHold ;;
			*) user_error "\
Unexpected reason: '$crl_reason'. See 'help revoke' for valid reasons."
		esac
	else
		unset -v crl_reason
	fi

	# Enforce syntax
	if [ "$1" ]; then
		user_error "Syntax error: $1"
	fi

	# referenced cert must exist:
	[ -f "$crt_in" ] || user_error "\
Unable to revoke as no certificate was found.
Certificate was expected at:
* $crt_in"

	# Set conflicting cert files: issued/ VS expired/ renewed/
	crt_iss="$EASYRSA_PKI/issued/${file_name_base}.crt"
	crt_exp="$EASYRSA_PKI/expired/${file_name_base}.crt"
	crt_ren="$EASYRSA_PKI/renewed/issued/${file_name_base}.crt"

	# If the command is 'revoke' then
	# if an issued cert exists then check that the others do not
	# To ensure that 'revoke' is not called accidentally
	if [ "$cmd" = revoke ] && [ -f "$crt_iss" ]; then
		if [ -f "$crt_exp" ] || [ -f "$crt_ren" ]; then
			msg=
			[ -f "$crt_exp" ] && msg="${NL}[Expired] $crt_exp"
			[ -f "$crt_ren" ] && msg="${msg}${NL}[Renewed] $crt_ren"

			# Force user to select revoke type
			[ "$EASYRSA_BATCH" ] || user_error "\
Conflicting file(s) found:${msg}

Please select which type of 'revoke' command is required:
* 'revoke-issued' will revoke a current certificate.
* 'revoke-expired' will revoke an old cert, which has been expired.
* 'revoke-renewed' will revoke an old cert, which has been renewed."
		fi
	fi
	# Clear variables no longer in use
	unset -v crt_iss crt_exp crt_ren

	# Verify certificate
	verify_file x509 "$crt_in" || user_error "\
Unable to revoke as the input-file is not a valid certificate.
Certificate was expected at:
* $crt_in"

	# Forbid self-signed cert from being expired/renewed/revoked
	if forbid_selfsign "$crt_in"; then
		user_error "Cannot $cmd a self-signed certificate."
	fi

	# Verify request
	if [ -f "$req_in" ]; then
		verify_file req "$req_in" || user_error "\
Unable to verify request. The file is not a valid request.
Request was expected at:
* $req_in"
	fi

	# get the serial number of the certificate
	cert_serial=
	ssl_cert_serial "$crt_in" cert_serial || \
		die "$cmd: Failed to get cert serial number!"

	# Set out_dir
	out_dir="$EASYRSA_PKI/revoked"
	crt_out="$out_dir/certs_by_serial/${cert_serial}.crt"
	key_out="$out_dir/private_by_serial/${cert_serial}.key"
	req_out="$out_dir/reqs_by_serial/${cert_serial}.req"

	# NEVER over-write a revoked cert, serial must be unique
	deny_msg="\
Cannot revoke this certificate, a conflicting file exists.
*"
	[ -f "$crt_out" ] && \
		user_error "$deny_msg certificate: $crt_out"
	[ -f "$key_out" ] && \
		user_error "$deny_msg private key: $key_out"
	[ -f "$req_out" ] && \
		user_error "$deny_msg request    : $req_out"
	unset -v deny_msg

	# Check for key and request files
	unset -v if_exist_key_in if_exist_req_in
	if [ "$move_req_and_key" ] && [ -f "$key_in" ]; then
		if_exist_key_in="
* $key_in"
	fi

	if [ "$move_req_and_key" ] && [ -f "$req_in" ]; then
		if_exist_req_in="
* $req_in"
	fi

	# Set confirm DN and serial
	confirm_dn="$(display_dn x509 "$crt_in")" || \
		die "revoke: display_dn"
	confirm_sn="    serial-number             = $cert_serial"

	# confirm operation by displaying DN:
	warn "\
This process is destructive!

These files will be MOVED to the 'revoked' sub-directory:
* $crt_in${if_exist_key_in}${if_exist_req_in}

These files will be DELETED:
All PKCS files for commonName: $file_name_base

The inline credentials files:
* $inline_pub
* $inline_pri"

	# now confirm
	confirm "  Continue with revocation: " "yes" "
Please confirm that you wish to revoke the certificate
with the following subject:

$confirm_dn
$confirm_sn

    Reason: ${crl_reason:-None given}"

	# Revoke certificate
	easyrsa_openssl ca -utf8 -revoke "$crt_in" \
		${crl_reason:+ -crl_reason "$crl_reason"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
			|| die "\
Failed to revoke certificate: revocation command failed."

	# move revoked files
	# so we can reissue certificates with the same name
	revoke_move

	notice "\
                    * IMPORTANT *

Revocation was successful. You must run 'gen-crl' and upload
a new CRL to your infrastructure in order to prevent the revoked
certificate from being accepted."
} # => revoke()

# revoke_move
# moves revoked certificates to the 'revoked' folder
# allows reissuing certificates with the same name
revoke_move() {
	easyrsa_mkdir "$EASYRSA_PKI"/revoked
	easyrsa_mkdir "$EASYRSA_PKI"/revoked/reqs_by_serial
	easyrsa_mkdir "$EASYRSA_PKI"/revoked/certs_by_serial
	easyrsa_mkdir "$EASYRSA_PKI"/revoked/private_by_serial

	# only move the req when revoking an issued cert
	# and if we have the req
	if [ "$move_req_and_key" ] && [ -f "$req_in" ]; then
		mv "$req_in" "$req_out" || warn "Failed to move: $req_in"
	fi

	# move crt to revoked folder
	mv "$crt_in" "$crt_out" || die "Failed to move: $crt_in"

	# only move the key when revoking an issued cert
	# and if we have the key
	if [ "$move_req_and_key" ] && [ -f "$key_in" ]; then
		mv "$key_in" "$key_out" || warn "Failed to move: $key_in"
	fi

	# remove any pkcs files
	for pkcs in p12 p7b p8 p1; do
		if [ -f "$in_dir/issued/$file_name_base.$pkcs" ]; then
			# issued
			rm "$in_dir/issued/$file_name_base.$pkcs" ||
				warn "Failed to remove: $file_name_base.$pkcs"
		fi

		if [ -f "$in_dir/private/$file_name_base.$pkcs" ]; then
			# private
			rm "$in_dir/private/$file_name_base.$pkcs" ||
				warn "Failed to remove: $file_name_base.$pkcs"
		fi
	done

	# remove inline files
	rm -f "$inline_pub" "$inline_pri" || warn \
		"revoke_move - Error trying to remove inline files."
} # => revoke_move()

# Move expired cert out of pki/issued to pki/expired
# to allow renewal
expire_cert() {
	# pull filename base:
	[ "$1" ] || user_error "\
Error: didn't find a file base name as the first argument.
Run easyrsa without commands for usage and command help."

	# Assign file_name_base and dust off!
	file_name_base="$1"
	shift

	# input
	in_dir="$EASYRSA_PKI/issued"
	crt_in="$in_dir/$file_name_base.crt"
	#key_in="$in_dir/private/$file_name_base.key"
	#req_in="$in_dir/reqs/$file_name_base.req"

	# output
	out_dir="$EASYRSA_PKI/expired"
	crt_out="$out_dir/$file_name_base.crt"

	# make output folder
	easyrsa_mkdir "$EASYRSA_PKI"/expired

	# Do not over write existing cert
	if [ -f "$crt_out" ]; then
		user_error "\
Cannot expire this certificate, a conflicting file exists:
* certificate: $crt_out

Use command 'revoke-exired' to revoke this certificate."
	fi

	# deprecate ALL options
	while [ "$1" ]; do
		case "$1" in
			nopass)
				warn "\
Option 'nopass' is not supported by command '$cmd'."
				;;
			*) user_error "Unknown option: $1"
		esac
		shift
	done

	# Verify certificate
	if [ -f "$crt_in" ]; then
		verify_file x509 "$crt_in" || user_error "\
Input file is not a valid certificate:
* $crt_in"
	else
		user_error "\
Missing certificate file:
* $crt_in"
	fi

	# Forbid self-signed cert from being expired/renewed/revoked
	if forbid_selfsign "$crt_in"; then
		user_error "Cannot $cmd a self-signed certificate."
	fi

	# get the serial number of the certificate
	cert_serial=
	ssl_cert_serial "$crt_in" cert_serial || \
		die "$cmd: Failed to get cert serial number!"

	# Set confirm DN and serial
	confirm_dn="$(display_dn x509 "$crt_in")" || \
		die "expire: display_dn"
	confirm_sn="    serial-number             = $cert_serial"

	# date of expiry
	# Equal to: easyrsa-tools.lib - ssl_cert_not_after_date()
	# This is left as a reminder that easyrsa does not handle
	# dates well and they should be avoided, at all cost.
	# This is for confirmation purposes ONLY.
	crt_expire="$(
		"$EASYRSA_OPENSSL" x509 -in "$crt_in" -noout -enddate
		)" || die "expire: enddate"
	confirm_ex="    notAfter date             = ${crt_expire#*=}"

	# confirm
	confirm "  Continue with expiry: " yes "
Please confirm you wish to expire the certificate
with the following subject:

$confirm_dn

$confirm_sn

$confirm_ex" # => End confirm

	# move cert to expired dir
	mv "$crt_in" "$crt_out" || die "failed to move expired: $crt_in"

	# User message
	notice "\
Certificate has been successfully moved to the expired directory.
* $crt_out

This certificate is still valid, until it expires.
It can be revoked with command 'revoke-expired'.

It is now possible to sign a new certificate for '$file_name_base'"
} # => expire_cert()

# Forbid a self-signed cert from being expired/renewed/revoked
# by a CA that has nothing to do with the cert
forbid_selfsign() {
	# cert temp-file
	forbid_selfsign_tmp=
	easyrsa_mktemp forbid_selfsign_tmp || \
		die "easyrsa_mktemp forbid_selfsign_tmp"

	# SSL text
	"$EASYRSA_OPENSSL" x509 -in "$1" -noout -text \
		> "$forbid_selfsign_tmp" || \
			die "forbid_selfsign - ssl text"

	# test for CA:TRUE
	grep -q "^[[:blank:]]*CA:TRUE$" "$forbid_selfsign_tmp"
} # => forbid_selfsign()

# gen-crl backend
gen_crl() {
	out_file="$EASYRSA_PKI/crl.pem"
	out_der="$EASYRSA_PKI/crl.der"

	out_file_tmp=""
	easyrsa_mktemp out_file_tmp || \
		die "gen_crl - easyrsa_mktemp out_file_tmp"

	if [ -r "$out_file" ]; then
		cp -p "$out_file" "$out_file_tmp" || \
			warn "Failed to preserve CRL file permissions."
	fi

	easyrsa_openssl ca -utf8 -gencrl -out "$out_file_tmp" \
		${EASYRSA_CRL_DAYS:+ -crldays "$EASYRSA_CRL_DAYS"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} || \
			die "CRL Generation failed."

	# Move temp-files to target-files
	mv "$out_file_tmp" "$out_file" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		#rm -f "$out_file"
		die "Failed to move temp CRL file."
	fi

	# Copy to DER - As published by OpenSSL
	if "$EASYRSA_OPENSSL" crl -in "$out_file" -out "$out_der" \
		-outform DER
	then
		crl_der_note="An updated CRL DER copy has been created:
* $out_der"
	else
		crl_der_note="Failed to create CRL DER copy!"
	fi

	notice "\
$crl_der_note

An updated CRL has been created:
* $out_file

IMPORTANT: When the CRL expires, an OpenVPN Server which uses a
CRL will reject ALL new connections, until the CRL is replaced."
} # => gen_crl()

# import-req backend
import_req() {
	# pull passed paths
	in_req="$1"
	short_name="$2"
	out_req="$EASYRSA_PKI/reqs/$2.req"

	[ "$short_name" ] || user_error "\
Unable to import: incorrect command syntax.
Run easyrsa without commands for usage and command help."

	# Request file must exist
	[ -f "$in_req" ] || user_error "\
No request found for the input: '$2'
Expected to find the request at:
* $in_req"

	verify_file req "$in_req" || user_error "\
The certificate request file is not in a valid X509 format:
* $in_req"

	# destination must not exist
	[ -f "$out_req" ] && user_error "\
Please choose a different name for your imported request file.
Conflicting file already exists at:
* $out_req"

	# now import it
	cp "$in_req" "$out_req"

	notice "\
Request successfully imported with short-name: $short_name
This request is now ready to be signed."
} # => import_req()

# export pkcs#12, pkcs#7, pkcs#8 or pkcs#1
export_pkcs() {
	pkcs_type="$1"
	shift

	[ "$1" ] || user_error "\
Unable to export '$pkcs_type': incorrect command syntax.
Run easyrsa without commands for usage and command help."

	file_name_base="$1"
	shift

	crt_in="$EASYRSA_PKI/issued/$file_name_base.crt"
	key_in="$EASYRSA_PKI/private/$file_name_base.key"
	crt_ca="$EASYRSA_PKI/ca.crt"

	# Always set a friendly_name
	set_var EASYRSA_P12_FR_NAME "$file_name_base"
	friendly_name="$EASYRSA_P12_FR_NAME"

	# opts support
	cipher=-aes256
	want_ca=1
	want_key=1
	unset -v nokeys legacy

	# Under OpenSSL 1.1, use the PBE/MAC algorithms OpenSSL 3.0 uses,
	# unless "legacy" is set.  This makes the .p12 files readable by
	# OpenSSL 3.0 without needing '-legacy'.
	if [ "$openssl_v3" ]; then
		# No cipher opts required
		p12_cipher_opts=""
	else
		# Upgrade PBE & MAC opts - Reset by option 'legacy'
		p12_cipher_opts="-keypbe AES-256-CBC -certpbe AES-256-CBC"
		p12_cipher_opts="${p12_cipher_opts} -macalg sha256"
	fi

	while [ "$1" ]; do
		case "$1" in
			noca)
				want_ca=""
				;;
			nokey)
				want_key=""
				# Undocumented OpenSSL feature: option
				# -nokeys will ignore missing -inkey file
				# No doubt, the reason for the extra -inkey
				nokeys=-nokeys
				;;
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			nofn)
				friendly_name=""
				;;
			legacy)
				if [ "$openssl_v3" ]; then
					legacy=-legacy
				else
					# Downgrade PBE & MAC opts
					p12_cipher_opts=""
				fi
				;;
			*)
				user_error "Unknown command option: '$1'"
		esac
		shift
	done

	# Required options - PKCS, rhymes with mess
	case "$pkcs_type" in
		p12|p7)
			: # ok
			;;
		p8|p1)
			want_key=1
			;;
		*) die "Unknown PKCS type: $pkcs_type"
	esac

	# Check for CA, if required
	if [ "$want_ca" ]; then
		case "$pkcs_type" in
		p12|p7)
			# verify_ca_init() here, otherwise not required
			if verify_ca_init test; then
				: # ok
			else
				warn "\
Missing CA Certificate, expected at:
* $crt_ca"
				confirm "
  Continue without CA Certificate (EG: option 'noca') ? " yes "
Your PKI does not include a CA Certificate.
You can export your User Certificate to a $pkcs_type file
but the CA Certificate will not be included."

				# --batch mode does not allow
				# on-the-fly command changes
				if [ "$EASYRSA_BATCH" ]; then
					die "export-$pkcs_type: Missing CA"
				fi
				want_ca=""
			fi
			;;
		p8|p1)
			: # Not required
			;;
		*) die "Unknown PKCS type: $pkcs_type"
		esac
	fi

	# Check for key, if required
	if [ "$want_key" ]; then
		if [ -f "$key_in" ]; then
			: #ok
		else
			case "$pkcs_type" in
			p12)
				warn "\
Missing Private Key, expected at:
* $key_in"
				confirm "
  Continue without Private Key (EG: option 'nokey') ? " yes "
Your PKI does not include a Private Key for '$file_name_base'.
You can export your User Certificate to a '$pkcs_type' file
but the Private Key will not be included."

				# --batch mode does not allow
				# on-the-fly command changes
				if [ "$EASYRSA_BATCH" ]; then
					die "export-$pkcs_type: Missing key"
				fi
				nokeys=-nokeys
				;;
			p8|p1)
				user_error "\
Missing Private Key, expected at:
* $key_in"
				;;
			p7)
				: # Not required
				;;
			*) die "Unknown PKCS type: $pkcs_type"
			esac
		fi
	fi

	# Check for certificate, if required
	if [ -f "$crt_in" ]; then
		: # ok
	else
		case "$pkcs_type" in
		p12|p7)
			user_error "\
Missing User Certificate, expected at:
* $crt_in"
			;;
		p8|p1)
			: # Not required
			;;
		*) die "Unknown PKCS type: $pkcs_type"
		esac
	fi

	# For 'nopass' PKCS requires an explicit empty password
	if [ "$EASYRSA_NO_PASS" ]; then
		EASYRSA_PASSIN=pass:
		EASYRSA_PASSOUT=pass:
		unset -v cipher # pkcs#1 only
	fi

	# Complete export
	inline_out=
	inline_msg=
	case "$pkcs_type" in
	p12)
		pkcs_out="$EASYRSA_PKI/private/$file_name_base.p12"
		inline_out="$EASYRSA_PKI/inline/$file_name_base-p12.inline"

		[ "$legacy" ] && \
			error_info="SSL library may not support -legacy mode"

		# export the p12:
		# shellcheck disable=2086 # Double quote p12_cipher_opts
		easyrsa_openssl pkcs12 -export \
			-in "$crt_in" \
			-out "$pkcs_out" \
			-inkey "$key_in" \
			${nokeys} \
			${legacy} \
			${p12_cipher_opts} \
			${friendly_name:+ -name "$friendly_name"} \
			${want_ca:+ -certfile "$crt_ca"} \
			${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
			${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} \
				|| die "Failed to export PKCS#12"

		# Inline .p12 only
		# Get cert CN
		inline_CN="$(
			"$EASYRSA_OPENSSL" x509 -in "$crt_in" -noout -subject \
				-nameopt multiline,-esc_msb | grep 'commonName'
		)" || die "export_pkcs - inline_CN FAILED"
		inline_CN="${inline_CN##*= }"

		# BASE64 encode pkcs12
		inline_tmp=
		easyrsa_mktemp inline_tmp || die "export_pkcs - inline_tmp"
		if "$EASYRSA_OPENSSL" enc -a -in "$pkcs_out" > "$inline_tmp"
		then
			# make inline file
			{
				print "\
# Easy-RSA inline file: pkcs12
# commonName: ${inline_CN}${NL}"
				print "<pkcs12>"
				cat "$inline_tmp"
				print "</pkcs12>"
			} > "$inline_out" || die "export_pkcs - make inline"

			inline_msg="\
A BASE64 encoded inline file has also been created at:
* ${inline_out}${NL}"
		else
			inline_msg="\
Failed to create a BASE64 encoded inline file${NL}"
		fi
		;;
	p7)
		pkcs_out="$EASYRSA_PKI/issued/$file_name_base.p7b"

		# export the p7:
		easyrsa_openssl crl2pkcs7 -nocrl \
			-certfile "$crt_in" \
			-out "$pkcs_out" \
			${want_ca:+ -certfile "$crt_ca"} \
				|| die "Failed to export PKCS#7"
		;;
	p8)
		pkcs_out="$EASYRSA_PKI/private/$file_name_base.p8"

		# export the p8:
		easyrsa_openssl pkcs8 -topk8 \
			-in "$key_in" \
			-out "$pkcs_out" \
			${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
			${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} \
				|| die "Failed to export PKCS#8"
		;;
	p1)
		pkcs_out="$EASYRSA_PKI/private/$file_name_base.p1"

		# OpenSSLv3 requires -traditional for PKCS#1
		# Otherwise, OpenSSLv3 outputs PKCS#8
		[ "$verify_ssl_lib_ok" ] || \
			die "export_pkcs.p1: verify_ssl_lib_ok FAIL"

		if [ "$openssl_v3" ]; then
			traditional=-traditional
		else
			unset -v traditional
		fi

		# export the p1:
		easyrsa_openssl rsa \
			-in "$key_in" \
			-out "$pkcs_out" \
			${traditional} \
			${cipher} \
			${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
			${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} \
				|| die "Failed to export PKCS#1"
	;;
	*) die "Unknown PKCS type: $pkcs_type"
	esac

	# User messages
	notice "\
Successful export of $pkcs_type file. Your exported file is at:
* $pkcs_out"
	[ "$inline_msg" ] && print "$inline_msg"

	return 0
} # => export_pkcs()

# set-pass backend
set_pass() {
	# values supplied by the user:
	raw_file="$1"
	file="$EASYRSA_PKI/private/$raw_file.key"

	if [ "$raw_file" ]; then
		shift
	else
		user_error "\
Missing argument: no name/file supplied."
	fi

	# parse command options
	cipher="-aes256"
	while [ "$1" ]; do
		case "$1" in
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			file)
				file="$raw_file"
				;;
			*) user_error "Unknown command option: '$1'"
		esac
		shift
	done

	# If nopass then do not encrypt else encrypt with password.
	if [ "$EASYRSA_NO_PASS" ]; then
		unset -v cipher
	fi

	[ -f "$file" ] || user_error "\
Missing private key: expected to find the private key file at:
* $file"

	notice "\
If the key is encrypted then you must supply the current password.
${cipher:+You will then enter a new password for this key.$NL}"

	# Set password
	out_key_tmp=""
	easyrsa_mktemp out_key_tmp || \
		die "set_pass - easyrsa_mktemp out_key_tmp"

	easyrsa_openssl pkey -in "$file" -out "$out_key_tmp" \
		${cipher:+ "$cipher"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
		${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} || \
			die "Failed to change the private key passphrase."

	# Move old key-file out of the way
	mv "$file" "${file}.tmp" || \
		die "Failed to move the old-key file."

	# Move new key-file into place
	if mv "$out_key_tmp" "$file"; then
		rm -f "${file}.tmp"
	else
		mv -f "${file}.tmp" "$file"
		die "Failed to update the private key file."
	fi

	key_update=changed
	[ "$EASYRSA_NO_PASS" ] && key_update=removed
	notice "Key passphrase successfully $key_update"
} # => set_pass()

# Verify OpenVPN binary
verify_openvpn() {
	# Try to find openvpn
	set_var EASYRSA_OPENVPN "$(which openvpn)"
	if [ -f "$EASYRSA_OPENVPN" ]; then
		verbose \
			"verify_openvpn - EASYRSA_OPENVPN='$EASYRSA_OPENVPN'"
	else
		user_error "Cannot find an OpenVPN binary."
	fi
} # => verify_openvpn()

# OpenVPN TLS Auth/Crypt Key
tls_key_gen() {
	case "$1" in
		tls-crypt-v2)
			print "Unavailable."
			cleanup
		;;
		tls-crypt) tls_key_type=TLS-CRYPT ;;
		tls-auth) tls_key_type=TLS-AUTH ;;
		*) die "Unknown key type: '$1'"
	esac

	# Over write error message
	tls_key_error_msg="
If this file is changed then it MUST be redistributed to ALL servers
AND clients, to be in effect. Do NOT change this existing file."

	# Assign possible TLS key sources
	tls_key_file="$EASYRSA_PKI"/private/easyrsa-tls.key
	old_tls_key_file="$EASYRSA_PKI"/easyrsa-keepsafe-tls.key

	# Forbid overwrite - default TLS key
	if [ -f "$tls_key_file" ]; then
		tls_key_data="$(cat "$tls_key_file")"
		case "$tls_key_data" in
			*'TLS-CRYPT'*) tls_key_type=TLS-CRYPT ;;
			*'TLS-AUTH'*) tls_key_type=TLS-AUTH ;;
			*) tls_key_type=UNKNOWN
		esac

		user_error "\
Cannot overwrite existing $tls_key_type Key:
* $tls_key_file
$tls_key_error_msg"
	fi

	# Forbid overwrite - Old TLS key
	if [ -f "$old_tls_key_file" ]; then
		old_tls_key_data="$(cat "$old_tls_key_file")"
		case "$old_tls_key_data" in
			*'TLS-CRYPT'*) tls_key_type=TLS-CRYPT ;;
			*'TLS-AUTH'*) tls_key_type=TLS-AUTH ;;
			*) tls_key_type=UNKNOWN
		esac

		user_error "\
Cannot overwrite existing $tls_key_type Key:
* $old_tls_key_file
$tls_key_error_msg"
	fi

	verify_openvpn

	tls_key_tmp=
	easyrsa_mktemp tls_key_tmp || \
		die "tls_key_gen - easyrsa_mktemp tls_key_tmp"

	# Generate TLS Key
	"$EASYRSA_OPENVPN" --genkey "$1" "$tls_key_tmp" || \
		die "tls_key_gen - --genkey $tls_key_type FAIL"

	# Insert type label
	{
		print "# Easy-RSA $tls_key_type Key"
		cat "$tls_key_tmp"
	} > "$tls_key_file" || \
			die "tls_key_gen - Insert type label FAIL"

	notice "\
$tls_key_type Key generated at:
* $tls_key_file
$tls_key_error_msg"
	verbose "tls_key_gen: openvpn --genkey $tls_key_type OK"
} # => tls_key_gen()

# Get certificate start date
# shellcheck disable=2317 # Unreach - ssl_cert_not_before_date()
ssl_cert_not_before_date() {
	verbose "DEPRECATED: ssl_cert_not_before_date()"
	[ "$#" = 2 ] || die "\
ssl_cert_not_before_date - input error"
	[ -f "$1" ] || die "\
ssl_cert_not_before_date - missing cert"

	fn_ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout -startdate
		)" || die "\
ssl_cert_not_before_date - failed: -startdate"

	fn_ssl_out="${fn_ssl_out#*=}"

	force_set_var "$2" "$fn_ssl_out" || die "\
ssl_cert_not_before_date - failed to set var '$*'"

	unset -v fn_ssl_out
} # => ssl_cert_not_before_date()

# Get certificate end date
ssl_cert_not_after_date() {
	verbose "DEPRECATED: ssl_cert_not_after_date()"
	[ "$#" = 2 ] || die "\
ssl_cert_not_after_date - input error"
	[ -f "$1" ] || die "\
ssl_cert_not_after_date - missing cert"

	fn_ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout -enddate
		)" || die "\
ssl_cert_not_after_date - failed: -enddate"

	fn_ssl_out="${fn_ssl_out#*=}"

	force_set_var "$2" "$fn_ssl_out" || die "\
ssl_cert_not_after_date - failed to set var '$*'"

	unset -v fn_ssl_out
} # => ssl_cert_not_after_date()

# SSL -- v3 -- startdate iso_8601
# shellcheck disable=2317 # Unreach - iso_8601_cert_startdate()
iso_8601_cert_startdate() {
	verbose "NEW: iso_8601_cert_startdate"
	[ "$#" = 2 ] || die "\
iso_8601_cert_startdate: input error"
	[ -f "$1" ] || die "\
iso_8601_cert_startdate: missing cert"

	# On error return, let the caller decide what to do
	if fn_ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout \
			-startdate -dateopt iso_8601
		)"
	then
		: # ok
	else
		# The caller MUST assess this error
		verbose "\
iso_8601_cert_startdate: GENERATED ERROR"
		return 1
	fi

	fn_ssl_out="${fn_ssl_out#*=}"

	force_set_var "$2" "$fn_ssl_out" || die "\
iso_8601_cert_startdate: failed to set var '$*'"

	unset -v fn_ssl_out
} # => iso_8601_cert_startdate()

# SSL -- v3 -- enddate iso_8601
iso_8601_cert_enddate() {
	verbose "NEW: iso_8601_cert_enddate"
	[ "$#" = 2 ] || die "\
iso_8601_cert_enddate: input error"
	[ -f "$1" ] || die "\
iso_8601_cert_enddate: missing cert"

	# On error return, let the caller decide what to do
	if fn_ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout \
			-enddate -dateopt iso_8601
		)"
	then
		: # ok
	else
		# The caller MUST assess this error
		verbose "\
iso_8601_cert_enddate: GENERATED ERROR"
		return 1
	fi

	fn_ssl_out="${fn_ssl_out#*=}"

	force_set_var "$2" "$fn_ssl_out" || die "\
iso_8601_cert_enddate: failed to set var '$*'"

	unset -v fn_ssl_out
} # => iso_8601_cert_enddate()

# Certificate expiry
will_cert_be_valid() {
	# Verify file exists and is a valid cert
	[ -f "$1" ] || \
		die "will_cert_be_valid - Missing file: $1"
	verify_file x509 "$1" || \
		die "will_cert_be_valid - Invalid file: $1"

	# Verify --days
	case "$2" in
		0) : ;; # ok
		''|*[!1234567890]*|0*)
			die "will_cert_be_valid - Non-decimal value: $2"
	esac

	# is the cert still valid at this future date
	ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout \
			-checkend "$2"
	)"

	# analyse SSL output
	case "$ssl_out" in
		'Certificate will not expire') return 0 ;;
		'Certificate will expire') return 1 ;;
		*) die "will_cert_be_valid - Failure"
	esac
} # => will_cert_be_valid()

# Read db
# shellcheck disable=SC2295 # nested expand - read_db()
read_db() {
	TCT='	' # tab character
	db_in="$EASYRSA_PKI/index.txt"
	pki_r_issued="$EASYRSA_PKI/renewed/issued"
	pki_r_by_sno="$EASYRSA_PKI/renewed/certs_by_serial"
	unset -v target_found

	while read -r db_status db_notAfter db_record; do

		verbose "***** Read next record *****"

		# Recreate temp-session and
		# drop edits to SSL Conf file
		remove_secure_session
		secure_session
		locate_support_files
		write_global_safe_ssl_cnf_tmp

		# Interpret the db/certificate record
		unset -v db_serial db_cn db_revoke_date db_reason
		case "$db_status" in
		V|E)
			# Valid
			db_serial="${db_record%%${TCT}*}"
			db_record="${db_record#*${TCT}}"
			db_cn="${db_record#*/CN=}"; db_cn="${db_cn%%/*}"
			cert_issued="$EASYRSA_PKI/issued/$db_cn.crt"
			cert_r_issued="$pki_r_issued/$db_cn.crt"
			cert_r_by_sno="$pki_r_by_sno/$db_serial.crt"
		;;
		R)
			# Revoked
			db_revoke_date="${db_record%%${TCT}*}"
			db_reason="${db_revoke_date#*,}"
			if [ "$db_reason" = "$db_revoke_date" ]; then
				db_reason="None given"
			else
				db_revoke_date="${db_revoke_date%,*}"
			fi
			db_record="${db_record#*${TCT}}"

			db_serial="${db_record%%${TCT}*}"
			db_record="${db_record#*${TCT}}"
			db_cn="${db_record#*/CN=}"; db_cn="${db_cn%%/*}"
		;;
		*) die "Unexpected status: $db_status"
		esac

		# Output selected status report for this record
		case "$report" in
		expire)
		# Certs which expire before EASYRSA_PRE_EXPIRY_WINDOW days
			case "$db_status" in
			V|E)
				case "$target" in
				'') expire_status_v2 "$cert_issued" ;;
				*)
					if [ "$target" = "$db_cn" ]; then
						expire_status_v2 "$cert_issued"
					fi
				esac
			;;
			*)
				: # Ignore ok
			esac
		;;
		revoke)
		# Certs which have been revoked
			case "$db_status" in
			R)
				case "$target" in
				'') revoke_status ;;
				*)
					if [ "$target" = "$db_cn" ]; then
						revoke_status
					fi
				esac
			;;
			*)
				: # Ignore ok
			esac
		;;
		renew)
		# Certs which have been renewed but not revoked
			case "$db_status" in
			V|E)
				case "$target" in
				'') renew_status ;;
				*)
					if [ "$target" = "$db_cn" ]; then
						renew_status
					fi
				esac
			;;
			*)
				: # Ignore ok
			esac
		;;
		*) die "Unrecognised report: $report"
		esac

		# Is db record for target found
		if [ "$target" = "$db_cn" ]; then
			target_found=1
		fi

	done < "$db_in"

	# Add CA to show-expire
	case  "$report" in
	expire)
		# Extract -endate
		ca_enddate="$(
			"$EASYRSA_OPENSSL" x509 -in "$EASYRSA_PKI"/ca.crt \
				-noout -enddate
		)"
		ca_enddate="${ca_enddate#*=}"

		# Check CA for expiry
		if will_cert_be_valid "$EASYRSA_PKI"/ca.crt \
			"$pre_expire_window_s"
		then
			: # cert will still be valid by expiry window
		else
			# Print CA expiry date
			printf '\n%s\n\n' \
				"CA certificate will expire on $ca_enddate"
		fi
	esac

	# Check for target found/valid commonName, if given
	if [ "$target" ]; then
		[ "$target_found" ] || \
			warn "Certificate for $target was not found"
	fi
} # => read_db()

# Expire status
expire_status_v2() {
	# expiry seconds
	pre_expire_window_s="$((
		EASYRSA_PRE_EXPIRY_WINDOW * 60*60*24
		))"

	# The certificate for CN should exist but may not
	if [ -f "$1" ]; then
		verbose "expire_status: cert exists"

		# Check if cert will be valid else print details
		if will_cert_be_valid "$1" "$pre_expire_window_s"
		then
			verbose "cert will still be valid by expiry window"
		else
			# cert expiry date
			if [ "$openssl_v3" ]; then
				# ISO8601 date - OpenSSL v3 only
				iso_8601_cert_enddate "$1" cert_not_after_date
			else
				# Standard date - OpenSSL v1
				ssl_cert_not_after_date "$1" cert_not_after_date
			fi

			# show expiring cert details
			printf '%s%s\n' \
				"$db_status | Serial: $db_serial | " \
				"$cert_not_after_date | CN: $db_cn"
		fi
	else
		verbose "issued cert does not exist, ignore other certs"
	fi
} # => expire_status_v2()

# Revoke status
revoke_status() {
	# Translate db date to usable date
	cert_revoke_date=
	db_date_to_iso_8601_date "$db_revoke_date" cert_revoke_date

	printf '%s%s%s\n' \
		"$db_status | Serial: $db_serial | " \
		"Revoked: $cert_revoke_date | " \
		"Reason: $db_reason | CN: $db_cn"
} # => revoke_status()

# Renewed status
# renewed certs only remain in the renewed folder until revoked
# Only ONE renewed cert with unique CN can exist in renewed folder
renew_status() {
	# Does a Renewed cert exist ?
	# files in issued are file name, or in serial are SerialNumber
	unset -v \
		cert_file_in cert_is_issued cert_is_serial renew_is_old

	# Find renewed/issued/CN
	if [ -f "$cert_r_issued" ]; then
		cert_file_in="$cert_r_issued"
		cert_is_issued=1
	fi

	# Find renewed/cert_by_serial/SN
	if [ -f "$cert_r_by_sno" ]; then
		cert_file_in="$cert_r_by_sno"
		cert_is_serial=1
		renew_is_old=1
	fi

	# Both should not exist
	if [ "$cert_is_issued" ] && [ "$cert_is_serial" ]; then
		die "Too many certs"
	fi

	# If a renewed cert exists
	if [ "$cert_file_in" ]; then
		# get the serial number of the certificate
		ssl_cert_serial "$cert_file_in" cert_serial

		# db serial must match certificate serial, otherwise
		# this is an issued cert that replaces a renewed cert
		if [ "$db_serial" != "$cert_serial" ]; then
			information "\
serial mismatch:
  db_serial:    $db_serial
  cert_serial:  $cert_serial
  cert_file_in: $cert_file_in"
			return 0
		fi

		# Use cert date
		# Assigns cert_not_after_date
		ssl_cert_not_after_date \
			"$cert_file_in" cert_not_after_date

		# Highlight renewed/cert_by_serial
		if [ "$renew_is_old" ]; then
			printf '%s%s\n' \
				"*** $db_status | Serial: $db_serial | " \
				"Expires: $cert_not_after_date | CN: $db_cn"
		else
			printf '%s%s\n' \
				"$db_status | Serial: $db_serial | " \
				"Expires: $cert_not_after_date | CN: $db_cn"
		fi

	else
		# Cert is valid but not renewed
		: # ok - ignore
	fi
} # => renew_status()

# cert status reports
status() {
	[ "$#" -gt 0 ] || die "status - input error"
	report="$1"
	target="$2"

	# test fix: https://github.com/OpenVPN/easy-rsa/issues/819
	export LC_TIME=C.UTF-8

	# If no target file then add Notice
	if [ -z "$target" ]; then
		# Select correct Notice
		case "$report" in
		expire)
			notice "\
* Showing certificates which expire in less than \
$EASYRSA_PRE_EXPIRY_WINDOW days (--days):"
		;;
		revoke)
			notice "\
* Showing certificates which are revoked:"
		;;
		renew)
			notice "\
* Showing certificates which have been renewed but NOT revoked:

*** Marks those which require 'rewind-renew' \
before they can be revoked."
		;;
		*) warn "Unrecognised report: $report"
		esac
	fi

	# Create report
	read_db
} # => status()

# renew backend
renew() {
	# pull filename base:
	[ "$1" ] || user_error "\
Error: didn't find a file base name as the first argument.
Run easyrsa without commands for usage and command help."

	# Assign file_name_base and dust off!
	file_name_base="$1"
	shift

	# Assign input files
	in_dir="$EASYRSA_PKI"
	crt_in="$in_dir/issued/${file_name_base}.crt"
	key_in="$in_dir/private/${file_name_base}.key"
	req_in="$in_dir/reqs/${file_name_base}.req"
	inline_pub="$in_dir/inline/${file_name_base}.inline"
	inline_pri="$in_dir/inline/private/${file_name_base}.inline"

	# deprecate ALL options
	while [ "$1" ]; do
		case "$1" in
			nopass)
				warn "\
Option 'nopass' is not supported by command 'renew'."
			;;
			*) user_error "Unknown option: $1"
		esac
		shift
	done

	# Verify certificate
	if [ -f "$crt_in" ]; then
		verify_file x509 "$crt_in" || user_error "\
Input file is not a valid certificate:
* $crt_in"
	else
		user_error "\
Missing certificate file:
* $crt_in"
	fi

	# Forbid self-signed cert from being expired/renewed/revoked
	if forbid_selfsign "$crt_in"; then
		user_error "Cannot $cmd a self-signed certificate."
	fi

	# Verify request
	if [ -f "$req_in" ]; then
		verify_file req "$req_in" || user_error "\
Input file is not a valid request:
* $req_in"
	else
		user_error "\
Missing request file:
* $req_in"
	fi

	# Get cert commonName
	cert_CN="$(
			display_dn x509 "$crt_in" | grep 'commonName'
		)" || die "renew - display_dn of cert failed"

	# Get req commonName
	req_CN="$(
			display_dn req "$req_in" | grep 'commonName'
		)" || die "renew - display_dn of req failed"

	# For renew, cert_CN must match req_CN
	[ "$cert_CN" = "$req_CN" ] || user_error \
		"Certificate cannot be renewed due to commonName mismatch"
	verbose "renew - cert_CN MATCH req_CN"

	# get the serial number of the certificate
	ssl_cert_serial "$crt_in" cert_serial || \
		die "$cmd: Failed to get cert serial number!"

	# Duplicate cert by serial file
	dup_dir="$EASYRSA_PKI/certs_by_serial"
	dup_crt_by_serial="$dup_dir/${cert_serial}.pem"

	# Set out_dir
	out_dir="$EASYRSA_PKI/renewed"
	crt_out="$out_dir/issued/${file_name_base}.crt"

	# NEVER over-write a renewed cert, revoke it first
	if [ -f "$crt_out" ]; then
		user_error "\
Cannot renew this certificate, a conflicting file exists:
* certificate: $crt_out

Use command 'revoke-renewed' to revoke this certificate."
	fi

	# Extract certificate usage from old cert
	ssl_cert_x509v3_eku "$crt_in" cert_type

	# create temp-file for full cert text
	full_crt_tmp=
	easyrsa_mktemp full_crt_tmp || \
		die "easyrsa_mktemp full_crt_tmp"

	# write full cert text tempfile data
	"$EASYRSA_OPENSSL" x509 -in "$crt_in" \
		-noout -text > "$full_crt_tmp" || \
			die "write full cert text"

	# Use SAN from old cert ONLY
	if grep -q 'X509v3 Subject Alternative Name' \
		"$full_crt_tmp"
	then
		EASYRSA_SAN="$(
			grep -A 1 'X509v3 Subject Alternative Name' \
				"$full_crt_tmp" | \
					sed -e s/'^\ *'// \
						-e /'X509v3 Subject Alternative Name'/d \
						-e s/'IP Address:'/'IP:'/g
		)" || die "renew - EASYRSA_SAN: easyrsa_openssl subshell"
		verbose "renew: EASYRSA_SAN: ${EASYRSA_SAN}"

		# --san-crit
		unset -v EASYRSA_SAN_CRIT
		if grep -q 'X509v3 Subject Alternative Name: critical' \
			"$full_crt_tmp"
		then
			export EASYRSA_SAN_CRIT='critical,'
			verbose "renew: --san-crit ENABLED"
		fi

		export EASYRSA_EXTRA_EXTS="\
$EASYRSA_EXTRA_EXTS
subjectAltName = ${EASYRSA_SAN_CRIT}${EASYRSA_SAN}"
		verbose "renew: EASYRSA_EXTRA_EXTS: ${EASYRSA_EXTRA_EXTS}"
	fi

	# --bc-crit
	if grep -q 'X509v3 Basic Constraints: critical' \
		"$full_crt_tmp"
	then
		export EASYRSA_BC_CRIT=1
		verbose "renew: --bc-crit ENABLED"
	fi

	# --ku-crit
	if grep -q 'X509v3 Key Usage: critical' \
		"$full_crt_tmp"
	then
		export EASYRSA_KU_CRIT=1
		verbose "renew: --ku-crit ENABLED"
	fi

	# --eku-crit
	if grep -q 'X509v3 Extended Key Usage: critical' \
		"$full_crt_tmp"
	then
		export EASYRSA_EKU_CRIT=1
		verbose "renew: --eku-crit ENABLED"
	fi

	# Disable options not supported by renew
	unset -v EASYRSA_AUTO_SAN EASYRSA_NEW_SUBJECT

	# confirm operation by displaying Warning
	confirm "Continue with 'renew' ? " yes "\
WARNING: This process is destructive!

These files will be MOVED to the 'renewed' sub-directory:
* $crt_in

These files will be DELETED:
All PKCS files for commonName: $file_name_base

The inline credentials files:
* $inline_pub
* $inline_pri"

	# move renewed files
	# so we can reissue certificate with the same name
	renew_move
	error_undo_renew_move=1

	# Set to modify sign-req confirmation message
	local_request=1

	# renew certificate
	# EASYRSA_BATCH=1
	if sign_req "$cert_type" "$file_name_base"
	then
		unset -v error_undo_renew_move
	else
		# If renew failed then restore cert.
		# Otherwise, issue a warning
		renew_restore_move
		die "Renewal has failed to build a new certificate."
	fi

	# Success messages
	notice "\
Renew was successful.

                    * IMPORTANT *

Renew has created a new certificate, to replace the old one.

To revoke the old certificate, once the new one has been deployed,
use command 'revoke-renewed $file_name_base'"
} # => renew()

# Restore files on failure to renew
renew_restore_move() {
	# restore crt file to PKI folders
	rrm_err=
	if mv "$restore_crt_out" "$restore_crt_in"; then
		: # ok
	else
		warn "Failed to restore: $restore_crt_in"
		rrm_err=1
	fi

	# messages
	if [ "$rrm_err" ]; then
		warn "Failed to restore renewed files."
	else
		notice "\
Renew FAILED but files have been successfully restored."
	fi
} # => renew_restore_move()

# renew_move
# moves renewed certificates to the 'renewed' folder
# allows reissuing certificates with the same name
renew_move() {
	# make sure renewed dirs exist
	easyrsa_mkdir "$out_dir"
	easyrsa_mkdir "$out_dir"/issued

	# move crt to renewed folders
	# After this point, renew is possible!
	restore_crt_in="$crt_in"
	restore_crt_out="$crt_out"
	mv "$crt_in" "$crt_out" || \
		die "Failed to move: $crt_in"

	# Remove files that can be recreated:
	# remove any pkcs files
	for pkcs in p12 p7b p8 p1; do
		# issued
		rm -f "$in_dir/issued/$file_name_base.$pkcs"
		# private
		rm -f "$in_dir/private/$file_name_base.$pkcs"
	done

	# remove inline files
	rm -f "$inline_pub" "$inline_pri" || warn \
		"renew_move - Error trying to remove inline files."
} # => renew_move()

# Verify certificate against CA
verify_cert() {
	# pull filename base:
	[ "$1" ] || user_error "\
Error: didn't find a <file-name-base> as the first argument.
Run easyrsa without commands for usage and command help."

	# Assign file_name_base and dust off!
	file_name_base="$1"
	shift

	# function opts support
	while [ "$1" ]; do
		case "$1" in
			# batch flag, return status [0/1] to calling
			# program.  Otherwise, exit 0 on completion.
			batch) EASYRSA_BATCH=1 ;;
			*) warn "Ignoring unknown command option: '$1'"
		esac
		shift
	done

	in_dir="$EASYRSA_PKI"
	ca_crt="$in_dir/ca.crt"
	crt_in="$in_dir/issued/$file_name_base.crt"

	# Cert file must exist
	[ -f "$crt_in" ] || user_error "\
No certificate found for the input:
* '$crt_in'"

	# Verify file is a valid cert
	verify_file x509 "$crt_in" || user_error "\
Input is not a valid certificate:
* $crt_in"

	# Silent SSL or not
	if [ "$EASYRSA_SILENT_SSL" ]; then
		# Test SSL out
		# openssl direct call because error is expected
		if "$EASYRSA_OPENSSL" verify \
			-CAfile "$ca_crt" "$crt_in" >/dev/null
		then
			verify_cert_ok=1
		else
			unset -v verify_cert_ok
		fi
	else
		if "$EASYRSA_OPENSSL" verify \
			-CAfile "$ca_crt" "$crt_in"
		then
			verify_cert_ok=1
		else
			unset -v verify_cert_ok
		fi
	fi

	# Return cert status
	if [ "$verify_cert_ok" ]; then
		notice "\
  Certificate name:    $file_name_base
  Verification status: GOOD"
	else
		notice "\
  Certificate name:    $file_name_base
  Verification status: FAILED"

		# Exit with error (batch mode)
		if [ "$EASYRSA_BATCH" ]; then
			# exit with error at cleanup
			easyrsa_exit_with_error=1
			# Return error for internal callers
			return 1
		fi
	fi
} # => verify_cert()

# Renew CA certificate
renew_ca_cert() {
	# dirs and files
	ca_key_file="$EASYRSA_PKI"/private/ca.key
	ca_cert_file="$EASYRSA_PKI"/ca.crt
	exp_ca_cert_list="$EASYRSA_PKI"/expired-ca.list

	# Set fixed variables
	x509=1
	date_stamp=1
	f_name="renew_ca_cert()"

	# Set default CA commonName
	[ "$EASYRSA_REQ_CN" = ChangeMe ] || \
		warn "\
$cmd does not support setting an external commonName."

	# Copy Old CA commonName as default
	export EASYRSA_REQ_CN="$(
		"$EASYRSA_OPENSSL" x509 -in "$ca_cert_file" \
		-noout -subject -nameopt utf8,multiline | \
			grep 'commonName' | sed -e \
			s\`^[[:blank:]]*commonName[[:blank:]]*=[[:blank:]]\`\`
	)"

	# Set ssl batch mode, as required
	[ "$EASYRSA_BATCH" ] && ssl_batch=1

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	# Assign new cert temp-file
	out_cert_tmp=
	easyrsa_mktemp out_cert_tmp || \
		die "$f_name easyrsa_mktemp out_cert_tmp"

	# Assign old cert temp-file
	old_cert_tmp=
	easyrsa_mktemp old_cert_tmp || \
		die "$f_name easyrsa_mktemp old_cert_tmp"

	# Write complete CA cert to old cert temp-file
	"$EASYRSA_OPENSSL" x509 -in "$ca_cert_file" \
		-text > "$old_cert_tmp" || \
			die "$f_name Write CA cert to temp-file"

	# Find or create x509 CA file
	if [ -f "$EASYRSA_EXT_DIR/ca" ]; then
		# Use the x509-types/ca file
		x509_type_file="$EASYRSA_EXT_DIR/ca"
	else
		# Use a temp file
		write_x509_type_tmp ca
		x509_type_file="$write_x509_file_tmp"
	fi

	# basicConstraints critical
	if grep -q 'Basic Constraints: critical' "$old_cert_tmp"
	then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "$f_name easyrsa_mktemp BC crit_tmp"

		add_critical_attrib basicConstraints "$x509_type_file" \
			"$crit_tmp" || die "$f_name BC add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		verbose "renew_ca_cert: basicConstraints critical OK"
	fi

	# keyUsage critical
	if grep -q 'Key Usage: critical' "$old_cert_tmp"
	then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "$f_name easyrsa_mktemp KU crit_tmp"

		add_critical_attrib keyUsage "$x509_type_file" \
			"$crit_tmp" || die "$f_name KU add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		verbose "renew_ca_cert: keyUsage critical OK"
	fi

	# Find or create x509 COMMON file
	if [ -f "$EASYRSA_EXT_DIR/COMMON" ]; then
		# Use the x509-types/COMMON file
		x509_COMMON_file="$EASYRSA_EXT_DIR/COMMON"
	else
		# Use a temp file
		write_x509_type_tmp COMMON
		x509_COMMON_file="$write_x509_file_tmp"
	fi

	# Check for insert-marker in ssl config file
	if ! grep -q '^#%CA_X509_TYPES_EXTRA_EXTS%' \
		"$EASYRSA_SSL_CONF"
	then
		die "\
This openssl config file does not support X509-type 'ca'.
* $EASYRSA_SSL_CONF

Please update 'openssl-easyrsa.cnf' to the latest Easy-RSA release."
	fi

	# Assign awkscript to insert EASYRSA_EXTRA_EXTS
	# shellcheck disable=SC2016 # No expand '' - build_ca()
	awkscript='\
{if ( match($0, "^#%CA_X509_TYPES_EXTRA_EXTS%") )
{ while ( getline<"/dev/stdin" ) {print} next }
{print} }'

	# Assign tmp-file for config
	adjusted_ssl_cnf_tmp=""
	easyrsa_mktemp adjusted_ssl_cnf_tmp || \
		die "$f_name easyrsa_mktemp adjusted_ssl_cnf_tmp"

	# Insert x509-types COMMON and 'ca' and EASYRSA_EXTRA_EXTS
	{
		# X509 files
		cat "$x509_type_file" "$x509_COMMON_file"

		# User extensions
		[ "$EASYRSA_EXTRA_EXTS" ] && \
			print "$EASYRSA_EXTRA_EXTS"

	} | awk "$awkscript" "$EASYRSA_SSL_CONF" \
			> "$adjusted_ssl_cnf_tmp" || \
				die "$f_name Copy X509_TYPES to config failed"
	verbose "$f_name insert x509 and extensions OK"

	# Use this new SSL config for the rest of this function
	EASYRSA_SSL_CONF="$adjusted_ssl_cnf_tmp"

	# Generate new CA cert:
	easyrsa_openssl req -utf8 -new \
		-key "$ca_key_file" \
		-out "$out_cert_tmp" \
		${ssl_batch:+ -batch} \
		${x509:+ -x509} \
		${date_stamp:+ -days "$EASYRSA_CA_EXPIRE"} \
		${EASYRSA_DIGEST:+ -"$EASYRSA_DIGEST"} \
		${EASYRSA_NO_PASS:+ "$no_password"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
		# EOL

	# Collect New CA text
	new_ca_text="$(
		"$EASYRSA_OPENSSL" x509 -in "$out_cert_tmp" -noout -text
	)"

	# Confirm renewed certificate installation
	confirm "Install the new CA certificate ? " yes "
NEW CA CERTIFICATE:

$new_ca_text

WARNING !!!

Your CA certificate is ready to be renewed. (Details above)

This new CA certificate will completely replace the old one.
The old CA will be archived to the 'expired-ca.list' file.

Please check the details above are correct, before continuing."

	# Prepare header file for updated old CA list
	header_tmp=
	easyrsa_mktemp header_tmp || \
		die "$f_name easyrsa_mktemp header_tmp"

	# header and separator text
	hdr='# Easy-RSA expired CA certificate list:'
	spr='# ====================================='

	# make full header temp-file
	printf '%s\n%s\n\n' "$hdr" "$spr" > "$header_tmp" || \
		die "$f_name printf header to header-temp"

	# Prepare old cert list
	if [ -f "$exp_ca_cert_list" ]; then
		# Assign old cert list temp file
		exp_cert_list_tmp=
		easyrsa_mktemp exp_cert_list_tmp || \
			die "$f_name easyrsa_mktemp exp_cert_list_tmp"

		# write list to temp-fie, remove header not separators
		sed -e s/"^${hdr}$"// \
			"$exp_ca_cert_list" > "$exp_cert_list_tmp" || \
				die "$f_name sed exp_ca_cert_list"
	fi

	# Add full old CA Cert to old CA Cert list file
	if [ -f "$exp_cert_list_tmp" ]; then
		cat "$header_tmp" "$old_cert_tmp" "$exp_cert_list_tmp" \
			> "$exp_ca_cert_list" || \
				die "$f_name cat exp_cert_list_tmp"
	else
		cat "$header_tmp" "$old_cert_tmp" \
			> "$exp_ca_cert_list" || \
				die "$f_name cat old_cert_tmp"
	fi

	# Install renewed CA Cert temp-file as current CA cert
	mv -f "$out_cert_tmp" "$ca_cert_file" || \
		die "Failed to install renewed CA temp-file!"

	notice "\
CA certificate has been successfully renewed.

Your old CA cerificate has been added to the expired CA list at:
* $exp_ca_cert_list

Your renewed CA cerificate is at:
* $ca_cert_file"
} # => renew_ca_cert()

# update-db backend
update_db() {
	easyrsa_openssl ca -utf8 -updatedb \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} || \
			die "Failed to perform update-db."
} # => update_db()

# display cert DN info on a req/X509, passed by full pathname
display_dn() {
	[ "$#" = 2 ] || die "\
display_dn - input error"

	format="$1"
	path="$2"
	shift 2

	# Display DN
	"$EASYRSA_OPENSSL" "$format" -in "$path" -noout -subject \
	-nameopt utf8,sep_multiline,space_eq,lname,align
} # => display_dn()

# verify a file seems to be a valid req/X509
verify_file() {
	format="$1"
	path="$2"
	"$EASYRSA_OPENSSL" "$format" -in "$path" -noout 2>/dev/null
} # => verify_file()

# show-* command backend
# Prints req/cert details in a readable format
show() {
	type="$1"
	name="$2"
	in_file=""
	format=""
	[ "$name" ] || user_error "\
Missing expected <file_name_base> argument.
Run easyrsa without commands for usage help."
	shift 2

	# opts support
	type_opts="-${type}opt"
	out_opts="no_pubkey,no_sigdump"
	name_opts="utf8,sep_multiline,space_eq,lname,align"
	while [ "$1" ]; do
		case "$1" in
			full) out_opts= ;;
			*) warn "Ignoring unknown command option: '$1'"
		esac
		shift
	done

	# Determine cert/req type (v2)
	case "$type" in
	cert)
		in_file="$EASYRSA_PKI/issued/$name.crt"
		format="x509"
		;;
	req)
		in_file="$EASYRSA_PKI/reqs/$name.req"
		format="req"
		;;
	crl)
		in_file="$EASYRSA_PKI/$name.pem"
		format="crl"
		unset -v type_opts out_opts name_opts
		;;
	*) die "Unrecognised type: $type"
	esac

	# Verify file exists and is of the correct type
	[ -f "$in_file" ] || user_error "\
No such '$type' type file with a <file_name_base> of '$name'.
Expected to find this file at:
* $in_file"

	verify_file "$format" "$in_file" || user_error "\
This file is not a valid $type file:
* $in_file"

	notice "\
Showing '$type' details for: '$name'

This file is stored at:
* $in_file${NL}"

	easyrsa_openssl "$format" -in "$in_file" -noout -text \
		${type_opts:+ "$type_opts" "$out_opts"} \
		${name_opts:+ -nameopt "$name_opts"} || \
			die "OpenSSL failure to process the input"
} # => show()

# show-ca command backend
# Prints CA cert details in a readable format
show_ca() {
	# opts support
	out_opts="no_pubkey,no_sigdump"
	name_opts="utf8,sep_multiline,space_eq,lname,align"
	while [ "$1" ]; do
		case "$1" in
			full) out_opts= ;;
			*) warn "Ignoring unknown command option: '$1'"
		esac
		shift
	done

	in_file="$EASYRSA_PKI/ca.crt"
	format="x509"

	# Verify file exists and is of the correct type
	[ -f "$in_file" ] || user_error "\
No such $type file with a basename of '$name' is present.
Expected to find this file at:
$in_file"

	verify_file "$format" "$in_file" || user_error "\
This file is not a valid $type file:
$in_file"

	notice "\
Showing details for CA certificate, at:
* $in_file${NL}"

	easyrsa_openssl "$format" -in "$in_file" -noout -text \
		-nameopt "$name_opts" -certopt "$out_opts" || \
			die "OpenSSL failure to process the input"
} # => show_ca()

# Certificate X509v3 Extended Key Usage
ssl_cert_x509v3_eku() {
	[ "$1" ] || die "ssl_cert_x509v3_eku - Missing input"

	# check input file name
	if [ -f "$1" ]; then
		__crt="$1"
	else
		__crt="${EASYRSA_PKI}/issued/${1}.crt"
		[ -f "$__crt" ] || \
			die "ssl_cert_x509v3_eku - Missing cert '$__crt'"
	fi

	# Set output variable
	__var="$2"
	shift "$#"

	# required variables
	__pattern="X509v3 Extended Key Usage:"
	__cli="TLS Web Client Authentication"
	__srv="TLS Web Server Authentication"
	__srv_cli="${__srv}, ${__cli}"
	__codeSign="Code Signing"
	unset -v __known

	# Extract certificate Extended Key Usage
	if [ "$ssl_lib" = libressl ]; then
		__eku="$(
			"$EASYRSA_OPENSSL" x509 -in "${__crt}" -noout -text | \
				sed -n "/${__pattern}/{n;s/^ *//g;p;}"
			)"
	else
		__eku="$(
			"$EASYRSA_OPENSSL" x509 -in "${__crt}" -noout \
				-ext extendedKeyUsage | \
					sed -e /"${__pattern}"/d -e s/^\ *//
			)"
	fi

	# Match EKU with supported usage
	case "$__eku" in
		"$__srv_cli")
			__known=1
			__type=serverClient
			;;
		"$__cli")
			__known=1
			__type=client
			;;
		"$__srv")
			__known=1
			__type=server
			;;
		"$__codeSign")
			__known=1
			__type=codeSign
			;;
		'')
			__type=undefined
			;;
		*)
			__type="'$__eku'"
	esac

	# Check for self-sign
	if "$EASYRSA_OPENSSL" x509 -in "$__crt" -noout -text | \
		grep -q 'CA:TRUE'
	then
		__type="self-signed-$__type"
	fi

	# Set variable to return
	if [ "$__var" ]; then
		verbose "ssl_cert_x509v3_eku - EKU: $__type"
		force_set_var "$__var" "$__type"
	elif [ "$__known" ]; then
		information "
* Known X509v3 Extended Key Usage: $__type"
	else
		information "
* Unknown X509v3 Extended Key Usage: $__type"
	fi

	unset -v __crt __var __pattern __srv_cli __cli __srv \
		__codeSign __eku __type

	if [ "$__known" ]; then
		unset -v __known
		return
	fi

	# Also, catch errors from SSL x509 command
	# for '__eku' subshell+pipe
	return 1
} # => ssl_cert_x509v3_eku()

# get the serial number of the certificate -> serial=XXXX
ssl_cert_serial() {
	[ "$#" = 2 ] || die "ssl_cert_serial - input error"
	[ -f "$1" ] || die "ssl_cert_serial - missing cert"

	fn_ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout -serial
		)" || die "ssl_cert_serial - failed: -serial"
	# remove the serial= part -> we only need the XXXX part
	fn_ssl_out="${fn_ssl_out##*=}"

	force_set_var "$2" "$fn_ssl_out" || \
		die "ssl_cert_serial - failed to set var '$*'"

	unset -v fn_ssl_out
} # => ssl_cert_serial()

# Identify host OS
detect_host() {
	unset -v \
		easyrsa_ver_test easyrsa_host_os easyrsa_host_test \
			easyrsa_win_git_bash

	# Detect Windows
	[ "${OS}" ] && easyrsa_host_test="${OS}"

	# shellcheck disable=SC2016 # No expand '' - detect_host()
	easyrsa_ksh=\
'@(#)MIRBSD KSH R39-w32-beta14 $Date: 2013/06/28 21:28:57 $'

	[ "${KSH_VERSION}" = "${easyrsa_ksh}" ] && \
		easyrsa_host_test="${easyrsa_ksh}"
	unset -v easyrsa_ksh

	# If not Windows then nix
	if [ "${easyrsa_host_test}" ]; then
		easyrsa_host_os=win
		easyrsa_uname="${easyrsa_host_test}"
		easyrsa_shell="$SHELL"
		# Detect Windows git/bash
		if [ "${EXEPATH}" ]; then
			easyrsa_shell="$SHELL (Git)"
			easyrsa_win_git_bash="${EXEPATH}"
			# If found then set openssl NOW!
			#[ -e /usr/bin/openssl ] && \
			#	set_var EASYRSA_OPENSSL /usr/bin/openssl
		fi
	else
		easyrsa_host_os=nix
		easyrsa_uname="$(uname 2>/dev/null)"
		easyrsa_shell="${SHELL:-undefined}"
	fi

	easyrsa_ver_test="${EASYRSA_version%%~*}"
	if [ "$easyrsa_ver_test" ]; then
		host_out="Host: $EASYRSA_version"
	else
		host_out="Host: dev"
	fi

	host_out="\
$host_out | $easyrsa_host_os | $easyrsa_uname | $easyrsa_shell"
	host_out="\
${host_out}${easyrsa_win_git_bash+ | "$easyrsa_win_git_bash"}"
	unset -v easyrsa_ver_test easyrsa_host_test
} # => detect_host()

# Extra diagnostics
show_host() {
	[ "$EASYRSA_SILENT" ] && return
	print_version
	print "$host_out"
	[ "$EASYRSA_DEBUG" ] || return 0
	case "$easyrsa_host_os" in
		win) set ;;
		nix) env ;;
		*) print "Unknown host OS: $easyrsa_host_os"
	esac
} # => show_host()

# Verify the selected algorithm parameters
verify_algo_params() {
	case "$EASYRSA_ALGO" in
	rsa)
		# Set RSA key size
		EASYRSA_ALGO_PARAMS="$EASYRSA_KEY_SIZE"
		;;
	ec)
		# Verify Elliptic curve
		EASYRSA_ALGO_PARAMS=""
		easyrsa_mktemp EASYRSA_ALGO_PARAMS || \
			die "\
verify_algo_params - easyrsa_mktemp EASYRSA_ALGO_PARAMS"

		# Create the required ecparams file, temp-file
		# call openssl directly because error is expected
			"$EASYRSA_OPENSSL" ecparam \
				-name "$EASYRSA_CURVE" \
				-out "$EASYRSA_ALGO_PARAMS" \
				>/dev/null 2>&1 || user_error "\
Failed to generate ecparam file for curve '$EASYRSA_CURVE'"
		;;
	ed)
		# Verify Edwards curve
		# call openssl directly because error is expected
			"$EASYRSA_OPENSSL" genpkey \
				-algorithm "$EASYRSA_CURVE" \
				>/dev/null 2>&1 || user_error "\
Edwards Curve '$EASYRSA_CURVE' not found."
		;;
	*) user_error "\
Unknown algorithm '$EASYRSA_ALGO': Must be 'rsa', 'ec' or 'ed'"
	esac
	verbose "\
verify_algo_params: Params verified for algo '$EASYRSA_ALGO' OK"
} # => verify_algo_params()

# Check for conflicting input options
mutual_exclusions() {
	# --nopass cannot be used with --passout
	if [ "$EASYRSA_PASSOUT" ]; then
		# --passout MUST take priority over --nopass
		[ "$EASYRSA_NO_PASS" ] && warn "\
Option --passout cannot be used with --nopass|nopass."
		unset -v EASYRSA_NO_PASS
		prohibit_no_pass=1
	fi

	# Restrict --days=0 to 'show-expire'
	if [ "$alias_days" = 0 ]; then
		case "$cmd" in
			show-expire) : ;; # ok
			*) user_error "Cannot use --days=0 for command $cmd"
		esac
	fi

	# --silent-ssl requires --batch
	if [ "$EASYRSA_SILENT_SSL" ]; then
		[ "$EASYRSA_BATCH" ] || warn "\
Option --silent-ssl requires batch mode --batch."
	fi

	# --startdate requires --enddate
	# otherwise, --days counts from now
	if [ "$EASYRSA_START_DATE" ]; then
		[ "$EASYRSA_END_DATE" ] || user_error "\
Use of --startdate requires use of --enddate."
	fi

	# --enddate may over-rule EASYRSA_CERT_EXPIRE
	if [ "$EASYRSA_END_DATE" ]; then
		case "$cmd" in
			sign-req|build-*-full|renew)
				# User specified alias_days IS over-ruled
				if [ "$alias_days" ]; then
					warn "\
Option --days is over-ruled by option --enddate."
				fi
				unset -v EASYRSA_CERT_EXPIRE alias_days
				;;
			*)
				warn "\
EasyRSA '$cmd' does not support --startdate or --enddate"
				unset -v EASYRSA_START_DATE EASYRSA_END_DATE
		esac
	fi

	# Insecure Windows directory
	if [ "$easyrsa_host_os" = win ]; then
		if echo "$PWD" | grep -q '/Prog.*/OpenVPN/easy-rsa'
		then
			verbose "\
Using Windows-System-Folders for your PKI is NOT SECURE!
Your Easy-RSA PKI CA Private Key is WORLD readable.

To correct this problem, it is recommended that you either:
* Copy Easy-RSA to your User folders and run it from there, OR
* Define your PKI to be in your User folders. EG:
  'easyrsa --pki-dir=\"C:/Users/<your-user-name>/easy-rsa/pki\"\
 <command>'"
		fi
	fi

	verbose "mutual_exclusions: COMPLETED"
} # => mutual_exclusions()

# Select vars in order preference:
# Here sourcing of 'vars' if present occurs.
# If not present, defaults are used to support
# running without a sourced config format.
select_vars() {
	# User specified vars file will be used ONLY
	if [ "$EASYRSA_VARS_FILE" ]; then
		# Takes priority, nothing to do
		verbose "select_vars: EASYRSA_VARS_FILE"

	# This is where auto-load goes bananas
	else

		# User specified PKI; if vars exists, use it ONLY
		if [ "$EASYRSA_PKI" ]; then
			if [ -f "$EASYRSA_PKI/vars" ]; then
				verbose "select_vars: source EASYRSA_PKI/vars"
				set_var EASYRSA_VARS_FILE "$EASYRSA_PKI/vars"
			fi
		fi

		# User specified EASYRSA; if vars exists, use it ONLY
		if [ "$EASYRSA" ]; then
			if [ -f "$EASYRSA/vars" ]; then
				verbose "select_vars: EASYRSA/vars"
				set_var EASYRSA_VARS_FILE "$EASYRSA/vars"
			fi
		fi

		# Default PKI; if vars exists, use it ONLY
		if [ -f "$PWD/pki/vars" ] && \
			[ -z "$EASYRSA_PKI" ] && \
			[ -z "$EASYRSA" ]
		then
			# Prevent vars from changing expected PKI.
			# A vars in the PKI MUST always imply EASYRSA_PKI
			# This is NOT backward compatible
			# Use expected value comparison for v3.1.7
			if [ -z "$EASYRSA_VARS_FILE" ]; then
				expected_EASYRSA="$PWD"
				expected_EASYRSA_PKI="$PWD/pki"
			fi

			# Use this for v3.2.0
			# If the pki/vars sets a different PKI then
			# there will be no PKI in the default /pki
			#set_var EASYRSA "$PWD"
			#set_var EASYRSA_PKI "$EASYRSA/pki"

			verbose "select_vars: PWD/pki/vars"
			set_var EASYRSA_VARS_FILE "$PWD/pki/vars"
		fi

		# Default working dir; if vars exists, use it ONLY
		if [ -f "$PWD/vars" ]; then
			verbose "select_vars: PWD/vars"
			set_var EASYRSA_VARS_FILE "$PWD/vars"
		fi
	fi

	# if select_vars failed to find a vars file
	if [ -z "$EASYRSA_VARS_FILE" ]; then
		verbose "select_vars: No vars"
		return 1
	fi
} # => select_vars()

# Source a vars file
source_vars() {
	# File to be sourced
	target_file="$1"

	# 'vars' MUST not be a directory
	[ -d "$target_file" ] && user_error "\
Missing vars file:
* $target_file"

	# 'vars' now MUST exist
	[ -f "$target_file" ] || user_error "\
Missing vars file:
* $target_file"

	# Sanitize vars
	if grep -q \
		-e 'EASYRSA_PASSIN' -e 'EASYRSA_PASSOUT' \
		-e '[^(]`[^)]' \
		-e 'export ' \
		-e 'unset ' \
			"$target_file"
	then
		# here we go ..
		err_msg="\
These problems have been found in your 'vars' settings:${NL}"

		# No passwords!
		if grep -q \
			-e 'EASYRSA_PASSIN' -e 'EASYRSA_PASSOUT' \
			"$target_file"
		then
			err_msg="${err_msg}
  Use of 'EASYRSA_PASSIN' or 'EASYRSA_PASSOUT':
  Storing password information in the 'vars' file is not permitted."
		fi

		# No backticks
		if grep -q \
			-e '[^(]`[^)]' \
			"$target_file"
		then
			err_msg="${err_msg}
  Use of unsupported characters:
  These characters are not supported: \` backtick"
		fi

		# No export
		if grep -q \
			-e 'export ' \
			"$target_file"
		then
			err_msg="${err_msg}
  Use of 'export':
  Remove 'export' or replace it with 'set_var'."
		fi

		# No unset
		if grep -q \
			-e 'unset ' \
			"$target_file"
		then
			err_msg="${err_msg}
  Use of 'unset':
  Remove 'unset' ('force_set_var' may also work)."
		fi

		# Fatal error
		user_error "${err_msg}${NL}
Please, correct these errors and try again."

	else
		verbose "source_vars: CLEAN '$target_file'"
	fi

	# Enable sourcing 'vars'
	# shellcheck disable=SC2034 # appears unused - source_vars()
	EASYRSA_CALLER=1
	easyrsa_path="$PATH"
	# shellcheck disable=SC2123 # PATH is - source_vars()
	PATH=./

	# Test sourcing 'vars' in a subshell
	# shellcheck disable=1090 # can't follow - source_vars()
	if ( . "$target_file" ); then
		# Source 'vars' now
		# shellcheck disable=1090 # can't follow - source_vars()
		. "$target_file" || \
			die "Failed to source the '$target_file' file."
	else
		PATH="$easyrsa_path"
		die "Failed to dry-run the '$target_file' file."
	fi

	PATH="$easyrsa_path"
	verbose "source_vars: sourced OK '$target_file'"
	unset -v EASYRSA_CALLER easyrsa_path target_file
} # => source_vars()

# Set defaults
default_vars() {
	# Set defaults, preferring existing env-vars if present
	set_var EASYRSA					"$PWD"
	set_var EASYRSA_OPENSSL			openssl
	set_var EASYRSA_PKI				"$EASYRSA/pki"
	set_var EASYRSA_DN				cn_only
	set_var EASYRSA_REQ_COUNTRY		"US"
	set_var EASYRSA_REQ_PROVINCE	"California"
	set_var EASYRSA_REQ_CITY		"San Francisco"
	set_var EASYRSA_REQ_ORG			"Copyleft Certificate Co"
	set_var EASYRSA_REQ_EMAIL		me@example.net
	set_var EASYRSA_REQ_OU			"My Organizational Unit"
	set_var EASYRSA_REQ_SERIAL		""
	set_var EASYRSA_ALGO			rsa
	set_var EASYRSA_KEY_SIZE		2048

	case "$EASYRSA_ALGO" in
		rsa)
			: # ok
			# default EASYRSA_KEY_SIZE must always be set
			# it must NOT be set selectively because it is
			# present in the SSL config file
			;;
		ec)
			set_var EASYRSA_CURVE		secp384r1
			;;
		ed)
			set_var EASYRSA_CURVE		ed25519
			;;
		*) user_error "\
Algorithm '$EASYRSA_ALGO' is invalid: Must be 'rsa', 'ec' or 'ed'"
	esac

	set_var EASYRSA_CA_EXPIRE		3650
	set_var EASYRSA_CERT_EXPIRE		825
	set_var \
		EASYRSA_PRE_EXPIRY_WINDOW	90
	set_var EASYRSA_CRL_DAYS		180
	set_var EASYRSA_NS_SUPPORT		no
	set_var EASYRSA_NS_COMMENT		\
		"Easy-RSA (~VER~) Generated Certificate"

	set_var EASYRSA_TEMP_DIR		"$EASYRSA_PKI"
	set_var EASYRSA_REQ_CN			ChangeMe
	set_var EASYRSA_DIGEST			sha256

	set_var EASYRSA_KDC_REALM		"CHANGEME.EXAMPLE.COM"

	set_var EASYRSA_MAX_TEMP		1
} # => default_vars()

# Validate expected values for EASYRSA and EASYRSA_PKI
validate_default_vars() {
	unset -v unexpected_error

	# Keep checks separate
	# EASYRSA
	if [ "$expected_EASYRSA" ]; then
		[ "$expected_EASYRSA" = "$EASYRSA" ] || \
			unexpected_error="\
       EASYRSA: $EASYRSA
      Expected: $expected_EASYRSA"
	fi

	# EASYRSA_PKI
	if [ "$expected_EASYRSA_PKI" ]; then
		if [ "$expected_EASYRSA_PKI" = "$EASYRSA_PKI" ]; then
			: # ok
		else
			if [ "$unexpected_error" ]; then
				# Add a new-line Extra separator, for clarity
				unexpected_error="${unexpected_error}${NL}${NL}"
			fi
			unexpected_error="${unexpected_error}\
   EASYRSA_PKI: $EASYRSA_PKI
      Expected: $expected_EASYRSA_PKI"
		fi
	fi

	# Return no error
	[ -z "$unexpected_error" ] && return

	# This is an almost unacceptable error
	invalid_vars=1
	[ "$quiet_vars" ] || user_error "\
The values in the vars file have unexpectedly changed the values for
EASYRSA and/or EASYRSA_PKI. The default pki/vars file is forbidden to
change these values.

     vars-file: $EASYRSA_VARS_FILE

${unexpected_error}"
} # => validate_default_vars()

# Verify working environment
verify_working_env() {
	verbose "verify_working_env: BEGIN"
	# For commands which 'require a PKI' and PKI exists
	if [ "$require_pki" ]; then
		# Verify PKI is initialised
		verify_pki_init

		# Temp dir session
		secure_session

		# global safe ssl cnf temp
		write_global_safe_ssl_cnf_tmp

		# Verify selected algorithm and parameters
		verify_algo_params

		# Verify CA is initialised
		if [ "$require_ca" ]; then
			verify_ca_init
		fi
	else
		# For commands that do not require a PKI
		# but do require a temp-dir, eg. 'write'
		# If there is a valid temp-dir:
		# Create temp-session and openssl-easyrsa.cnf (Temp) now
		if [ -d "$EASYRSA_TEMP_DIR" ]; then
			# Temp dir session
			secure_session

			# global safe ssl cnf temp
			write_global_safe_ssl_cnf_tmp
		fi
	fi

	# Find x509-types, openssl-easyrsa.cnf
	# and easyrsa-tools.lib
	locate_support_files

	# Save original EASYRSA_SSL_CONF
	original_ssl_cnf="$EASYRSA_SSL_CONF"

	verbose "verify_working_env: COMPLETED Handover-to: $cmd"
} # => verify_working_env()

# variable assignment by indirection.
# Sets '$1' as the value contained in '$2'
# and exports (may be blank)
set_var() {
	[ -z "$*" ] && return
	[ -z "$3" ] || \
		user_error "set_var - excess input '$*'"
	case "$1" in
		*=*) user_error "set_var - var '$1'"
	esac
	eval "export \"$1\"=\"\${$1-$2}\"" && return
	die "set_var - eval '$*'"
} # => set_var()

# sanitize and set var
# nix.sh/win.sh/busybox.sh never return error from unset
# when an invalid variable name 'a=b' is used with a value
# to set, eg. 'c'; This causes EasyRSA to execute:
# eval "export a=b=c". 'set_var EASYRSA_PKI=pki' results in
# $EASYRSA_PKI being set to 'pki=pki-', without error!
# Guard against this possible user error with 'case'.
force_set_var() {
	[ -z "$3" ] || \
		user_error "force_set_var - excess input '$*'"
	case "$1" in
		*=*) user_error "force_set_var - var '$1'"
	esac
	# force unsetting $1; Guard unset with '|| die', just in case
	unset -v "$1" || die "force_set_var - unset '$1'"
	# Allow empty value to unset variable by returning
	[ "$2" ] || return 0
	set_var "$1" "$2" && return
	die "force_set_var - set_var '$*'"
} # => force_set_var()

# global Safe SSL conf file, for use by any SSL lib
write_global_safe_ssl_cnf_tmp() {
	global_safe_ssl_cnf_tmp=
	easyrsa_mktemp global_safe_ssl_cnf_tmp || die "\
verify_working_env - easyrsa_mktemp global_safe_ssl_cnf_tmp"

	write_legacy_file_v2 safe-cnf "$global_safe_ssl_cnf_tmp" || \
		die "verify_working_env - write safe-cnf"

	export OPENSSL_CONF="$global_safe_ssl_cnf_tmp"
	verbose "GLOBAL - OPENSSL_CONF = $OPENSSL_CONF"
} # => write_global_safe_ssl_cnf_tmp()

# Create as needed: $EASYRSA_SSL_CONF pki/openssl-easyrsa.cnf
# If the existing file has a known hash then use temp-file.
# Otherwise, use the file in place.
write_easyrsa_ssl_cnf_tmp() {
	# If EASYRSA_SSL_CONF is undefined then use default
	[ "$EASYRSA_SSL_CONF" ] || set_var \
		EASYRSA_SSL_CONF "$EASYRSA_PKI"/openssl-easyrsa.cnf

	if [ -f "$EASYRSA_SSL_CONF" ]; then
		verbose "write_easyrsa_ssl_cnf_tmp: SSL config EXISTS"

		# Set known hashes
		# 3.1.7 -> Current
		known_file_317="\
13ca05f031d58c5e2912652b33099ce9\
ac05f49595e5d5fe96367229e3ce070c"

		# 3.1.5 -> 3.1.6
		known_file_315="\
87d51ca0db1cc0ac3cc2634792fc5576\
e0034ebf9d546de11674b897514f3afb"

		# 3.1.0 -> 3.1.4
		known_file_310="\
5455947df40f01f845bf79c1e89f102c\
628faaa65d71a6512d0e17bdd183feb0"

		# 3.0.8 -> 3.0.9
		known_file_308="\
1cc6a1de93ca357b5c364aa0fa2c4bea\
f97425686fa1976d436fa31f550641aa"

		# Built-in here-doc 3.2.0
		known_heredoc_320="\
82439f1860838e28f6270d5d06b17717\
56db777861e19bf9edc21222f86a310d"

		# Get file hash
		file_hash="$(
			"$EASYRSA_OPENSSL" dgst -sha256 -r \
				"$EASYRSA_SSL_CONF" 2>/dev/null
		)" || die "write_easyrsa_ssl_cnf_tmp - hash malfunction!"

		# Strip excess SSL info
		file_hash="${file_hash%% *}"

		# Compare SSL output
		case "$file_hash" in
		*[!1234567890abcdef]*|'')
			die "write_easyrsa_ssl_cnf_tmp - hash failure!"
		esac

		# Check file hash against known hash
		hash_is_unknown=""

		case "$file_hash" in
			"$known_file_317") ;;
			"$known_file_315") ;;
			"$known_file_310") ;;
			"$known_file_308") ;;
			"$known_heredoc_320") ;;

			*)
				# File is unknown or has been changed
				# leave in place
				hash_is_unknown=1
		esac

		# Cleanup
		unset -v file_hash known_heredoc_320 \
				known_file_317 \
				known_file_315 \
				known_file_310 \
				known_file_308

		# Use the existing file ONLY
		if [ "$hash_is_unknown" ] || [ "$EASYRSA_FORCE_SAFE_SSL" ]
		then
			unset -v hash_is_unknown
			verbose "write_easyrsa_ssl_cnf_tmp: SSL config UNKNOWN!"

			# Auto-escape hazardous characters
			escape_hazard || \
				die "easyrsa_openssl - escape_hazard failed"

			# Rewrite SSL config
			expand_ssl_config || \
				die "easyrsa_openssl - expand_ssl_config failed"

			return 0
		fi

		# Ignore existing file, prefer to use a temp-file
		verbose "write_easyrsa_ssl_cnf_tmp: SSL config KNOWN"
	fi

	# SET and USE temp-file from here-doc Now
	# Create temp-file
	ssl_cnf_tmp=
	easyrsa_mktemp ssl_cnf_tmp || die "\
write_easyrsa_ssl_cnf_tmp - easyrsa_mktemp"

	# Write SSL cnf to temp-file
	write_legacy_file_v2 "$ssl_cnf_type" "$ssl_cnf_tmp" || die "\
write_easyrsa_ssl_cnf_tmp - write $ssl_cnf_type: $ssl_cnf_tmp"

	# export SSL cnf tmp
	export EASYRSA_SSL_CONF="$ssl_cnf_tmp"
	verbose "\
write_easyrsa_ssl_cnf_tmp: $ssl_cnf_type \
- EASYRSA_SSL_CONF = $EASYRSA_SSL_CONF"

	export OPENSSL_CONF="$EASYRSA_SSL_CONF"
	verbose "LOCAL - OPENSSL_CONF = $OPENSSL_CONF"
} # => write_easyrsa_ssl_cnf_tmp()

# Write x509 type file to a temp file
write_x509_type_tmp() {
	# Verify x509-type before redirect
	case "$1" in
		COMMON|ca|server|serverClient|client|email| \
		codeSigning|kdc|selfsign)
			: # ok
		;;
	*)
		die "write_x509_type_tmp - unknown type '$1'"
	esac

	write_x509_file_tmp=""
	easyrsa_mktemp write_x509_file_tmp || \
		die "write_x509_type_tmp - easyrsa_mktemp"

	write_legacy_file_v2 "$1" "$write_x509_file_tmp" || \
		die "write_x509_type_tmp - write $1"


	verbose ": write_x509_type_tmp: $1 COMPLETE"
} # => write_x509_type_tmp()

############################################################################
#
# Create legacy files
#

# Write ALL legacy files to $1 or default
all_legacy_files_v2() {
	# Confirm over write
	if [ "$legacy_file_over_write" ]; then
		confirm "${NL}  Confirm OVER-WRITE files ? " yes "
Warning:
'legacy-hard' will OVER-WRITE all legacy files to default settings.

Legacy files:
* File: ${EASYRSA_PKI}/openssl-easyrsa.cnf
* File: ${EASYRSA_PKI}/vars.example
* Dir:  ${EASYRSA_PKI}/x509-types/*"

		verbose "all_legacy_files_v2 - over-write ENABLED"
	fi

	# Output directories
	legacy_out_d="$EASYRSA_PKI"
		easyrsa_mkdir "$legacy_out_d"
	x509_types_d="$legacy_out_d"/x509-types
		easyrsa_mkdir "$x509_types_d"

	# Create x509-types
	for legacy_type in COMMON ca server serverClient client \
		email codeSigning kdc
	do
		legacy_target="${x509_types_d}/${legacy_type}"
		write_legacy_file_v2 "$legacy_type" "$legacy_target" \
			"$legacy_file_over_write"
	done

	# vars.example
	legacy_type=vars
	legacy_target="$legacy_out_d"/vars.example
	write_legacy_file_v2 "$legacy_type" "$legacy_target" \
		"$legacy_file_over_write"

	# openssl-easyrsa.cnf
	legacy_type=ssl-cnf
	legacy_target="$legacy_out_d"/openssl-easyrsa.cnf
	write_legacy_file_v2 "$legacy_type" "$legacy_target" \
		"$legacy_file_over_write"

	# User notice
	if [ "$legacy_file_over_write" ]; then
		notice "legacy-hard has updated all files."
	else
		notice "legacy has updated missing files."
	fi
} # => all_legacy_files_v2()

# write legacy files to stdout or user defined file
write_legacy_file_v2() {
	# recursion check
	write_recursion="$(( write_recursion + 1 ))"
	if [ "$write_recursion" -gt 1 ]; then
		print "write recursion" > "$easyrsa_err_log"
		die "write recursion"
	fi

	write_type="$1"
	write_file="$2"
	write_over=
	[ "$3" = overwrite ] && write_over=1

	# Select by type
	case "$write_type" in
	ssl-cnf)
		set_openssl_easyrsa_cnf_vars unexpanded
		;;
	safe-cnf)
		set_openssl_easyrsa_cnf_vars expanded
		;;
	vars)
		;;
	# This correctly renames 'code-signing' to 'codeSigning'
	COMMON|ca|server|serverClient|client|codeSigning|email|kdc)
		;;
	selfsign)
		;;
	*)
		user_error "write - unknown type '$write_type'"
	esac

	# If $write_file is given then establish overwrite rules
	if [ "$write_file" ]; then

		# $write_file must not be a directory
		[ -d "$write_file" ] && user_error \
			"write: Target is a directory: '$write_file'"

		# If $write_file exists then check for temp-file
		if [ -f "$write_file" ]; then
			# if this is a temp file then enable auto-overwrite
			path="${write_file%%/temp.*}"
			if [ "$path" = "${secured_session}" ]; then
				verbose ": write_legacy_file_v2 - temp-file ACCEPTED"
				write_over=1
			else
				# target is not a temp-file, overwrite not changed
				verbose ": Target is not a temp-file: $write_file"
			fi
		else
			verbose ": Create new file: $write_file"
		fi
	else
		verbose ": No target file - output to stdout"
	fi

	# write legacy data stream to stdout or file
	if [ -f "$write_file" ]; then
		if [ "$write_over" ]; then
			verbose ": write_legacy_file_v2 - over-write ENABLED"
			create_legacy_stream "$write_type" > "$write_file" || \
				die "write failed"
			[ "$EASYRSA_DEBUG" ] && print \
				"### write OVERWRITE: $write_type to $write_file"
		else
			# Preserve existing file and continue
			verbose "write_legacy_file_v2 - over-write DISABLED "
			[ "$EASYRSA_DEBUG" ] && print \
				"### write PRESERVE existing: $write_file"
		fi
	elif [ "$write_file" ]; then
			verbose ": write_legacy_file_v2 - over-write DISABLED"
			create_legacy_stream "$write_type" > "$write_file" || \
				die "write failed"
			[ "$EASYRSA_DEBUG" ] && print \
				"### write NEWFILE: $write_type to $write_file"
	else
		# write stream to stdout ONLY
		create_legacy_stream "$write_type"
	fi

	write_recursion="$(( write_recursion - 1 ))"
} # => write_legacy_file_v2()

# set heredoc variables for openssl-easyrsa.cnf
# shellcheck disable=SC2016 # (info): $ don't expand in ''
set_openssl_easyrsa_cnf_vars(){
	case "$1" in
	expanded)
		# fully expand ssl-cnf for safe-cnf
		conf_EASYRSA_dir="$EASYRSA_PKI"
		conf_EASYRSA_PKI="$EASYRSA_PKI"
		conf_EASYRSA_DIGEST="$EASYRSA_DIGEST"
		conf_EASYRSA_KEY_SIZE="$EASYRSA_KEY_SIZE"
		conf_EASYRSA_DN="$EASYRSA_DN"
		conf_EASYRSA_REQ_CN="$EASYRSA_REQ_CN"
		conf_EASYRSA_REQ_COUNTRY="$EASYRSA_REQ_COUNTRY"
		conf_EASYRSA_REQ_PROVINCE="$EASYRSA_REQ_PROVINCE"
		conf_EASYRSA_REQ_CITY="$EASYRSA_REQ_CITY"
		conf_EASYRSA_REQ_ORG="$EASYRSA_REQ_ORG"
		conf_EASYRSA_REQ_OU="$EASYRSA_REQ_OU"
		conf_EASYRSA_REQ_EMAIL="$EASYRSA_REQ_EMAIL"
		conf_EASYRSA_REQ_SERIAL="$EASYRSA_REQ_SERIAL"
		;;
	unexpanded)
		# write standard ssl-cnf
		conf_EASYRSA_dir='$dir'
		conf_EASYRSA_PKI='$ENV::EASYRSA_PKI'
		conf_EASYRSA_DIGEST='$ENV::EASYRSA_DIGEST'
		conf_EASYRSA_KEY_SIZE='$ENV::EASYRSA_KEY_SIZE'
		conf_EASYRSA_DN='$ENV::EASYRSA_DN'
		conf_EASYRSA_REQ_CN='$ENV::EASYRSA_REQ_CN'
		conf_EASYRSA_REQ_COUNTRY='$ENV::EASYRSA_REQ_COUNTRY'
		conf_EASYRSA_REQ_PROVINCE='$ENV::EASYRSA_REQ_PROVINCE'
		conf_EASYRSA_REQ_CITY='$ENV::EASYRSA_REQ_CITY'
		conf_EASYRSA_REQ_ORG='$ENV::EASYRSA_REQ_ORG'
		conf_EASYRSA_REQ_OU='$ENV::EASYRSA_REQ_OU'
		conf_EASYRSA_REQ_EMAIL='$ENV::EASYRSA_REQ_EMAIL'
		conf_EASYRSA_REQ_SERIAL='$ENV::EASYRSA_REQ_SERIAL'
		;;
	*)
		die "set_openssl_easyrsa_cnf_vars - input"
	esac
} # => set_openssl_easyrsa_cnf_vars()

# Create x509 type
create_legacy_stream() {
	case "$1" in
	COMMON)
	# COMMON is not very useful
		cat <<- "CREATE_X509_TYPE_COMMON"
		CREATE_X509_TYPE_COMMON
		;;
	easyrsa)
	# This could be COMMON but not is not suitable for a CA
		cat <<- "CREATE_X509_TYPE_EASYRSA"
		basicConstraints = CA:FALSE
		subjectKeyIdentifier = hash
		authorityKeyIdentifier = keyid,issuer:always
		keyUsage = digitalSignature,keyEncipherment
		CREATE_X509_TYPE_EASYRSA
		;;
	serverClient)
	# serverClient
		create_legacy_stream easyrsa
		cat <<- "CREATE_X509_TYPE_SERV_CLI"
		extendedKeyUsage = serverAuth,clientAuth
		CREATE_X509_TYPE_SERV_CLI
		;;
	server)
	# server
		create_legacy_stream easyrsa
		cat <<- "CREATE_X509_TYPE_SERV"
		extendedKeyUsage = serverAuth
		CREATE_X509_TYPE_SERV
		;;
	client)
	# client
		create_legacy_stream easyrsa
		cat <<- "CREATE_X509_TYPE_CLI"
		extendedKeyUsage = clientAuth
		CREATE_X509_TYPE_CLI
		;;
	ca)
	# ca
		cat <<- "CREATE_X509_TYPE_CA"
		basicConstraints = CA:TRUE
		subjectKeyIdentifier = hash
		authorityKeyIdentifier = keyid:always,issuer:always
		keyUsage = cRLSign, keyCertSign
		CREATE_X509_TYPE_CA
		;;
	selfsign)
	# selfsign
		cat <<- "CREATE_X509_TYPE_SELFSIGN"
		subjectKeyIdentifier = hash
		authorityKeyIdentifier = keyid:always,issuer:always
		basicConstraints = CA:TRUE
		keyUsage = digitalSignature,keyEncipherment
		CREATE_X509_TYPE_SELFSIGN

		print "extendedKeyUsage = $selfsign_eku"
		;;
	codeSigning)
	# codeSigning
		cat <<- "CREATE_X509_CODE_SIGNING"
		basicConstraints = CA:FALSE
		subjectKeyIdentifier = hash
		authorityKeyIdentifier = keyid,issuer:always
		extendedKeyUsage = codeSigning
		keyUsage = digitalSignature
		CREATE_X509_CODE_SIGNING
		;;
	email)
	# email
		cat <<- "CREATE_X509_TYPE_EMAIL"
		basicConstraints = CA:FALSE
		subjectKeyIdentifier = hash
		authorityKeyIdentifier = keyid,issuer:always
		extendedKeyUsage = emailProtection
		keyUsage = digitalSignature,keyEncipherment,nonRepudiation
		CREATE_X509_TYPE_EMAIL
		;;
	kdc)
	# kdc
		cat <<- "CREATE_X509_TYPE_KDC"
basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = 1.3.6.1.5.2.3.5
keyUsage = nonRepudiation,digitalSignature,keyEncipherment,keyAgreement
issuerAltName = issuer:copy
subjectAltName = otherName:1.3.6.1.5.2.2;SEQUENCE:kdc_princ_name

[kdc_princ_name]
realm = EXP:0,GeneralString:${ENV::EASYRSA_KDC_REALM}
principal_name = EXP:1,SEQUENCE:kdc_principal_seq

[kdc_principal_seq]
name_type = EXP:0,INTEGER:1
name_string = EXP:1,SEQUENCE:kdc_principals

[kdc_principals]
princ1 = GeneralString:krbtgt
princ2 = GeneralString:${ENV::EASYRSA_KDC_REALM}
CREATE_X509_TYPE_KDC
		;;
	vars)
	# vars
		cat << "CREATE_VARS_EXAMPLE"
# Easy-RSA 3 parameter settings

# NOTE: If you installed Easy-RSA from your package manager, do not edit
# this file in place -- instead, you should copy the entire easy-rsa directory
# to another location so future upgrades do not wipe out your changes.

# HOW TO USE THIS FILE
#
# vars.example contains built-in examples to Easy-RSA settings. You MUST name
# this file "vars" if you want it to be used as a configuration file. If you
# do not, it WILL NOT be automatically read when you call easyrsa commands.
#
# It is not necessary to use this config file unless you wish to change
# operational defaults. These defaults should be fine for many uses without
# the need to copy and edit the "vars" file.
#
# All of the editable settings are shown commented and start with the command
# "set_var" -- this means any set_var command that is uncommented has been
# modified by the user. If you are happy with a default, there is no need to
# define the value to its default.

# NOTES FOR WINDOWS USERS
#
# Paths for Windows  *MUST* use forward slashes, or optionally double-escaped
# backslashes (single forward slashes are recommended.) This means your path
# to the openssl binary might look like this:
# "C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# A little housekeeping: DO NOT EDIT THIS SECTION
#
# Easy-RSA 3.x does not source into the environment directly.
# Complain if a user tries to do this:
if [ -z "$EASYRSA_CALLER" ]; then
	echo "You appear to be sourcing an Easy-RSA *vars* file. This is" >&2
	echo "no longer necessary and is disallowed. See the section called" >&2
	echo "*How to use this file* near the top comments for more details." >&2
	return 1
fi

# DO YOUR EDITS BELOW THIS POINT

# If your OpenSSL command is not in the system PATH, you will need to define
# the path here. Normally this means a full path to the executable, otherwise
# you could have left it undefined here and the shown default would be used.
#
# Windows users, remember to use paths with forward-slashes (or escaped
# back-slashes.) Windows users should declare the full path to the openssl
# binary here if it is not in their system PATH.
#
#set_var EASYRSA_OPENSSL	"openssl"
#
# This sample is in Windows syntax -- edit it for your path if not using PATH:
#set_var EASYRSA_OPENSSL	"C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# Windows users, to generate OpenVPN TLS Keys the Openvpn binary must be
# defined here.
#
#set_var EASYRSA_OPENVPN "C:\\Program Files\\Openvpn\\bin\\openvpn.exe"

# Define X509 DN mode.
#
# This is used to adjust which elements are included in the Subject field
# as the DN ("Distinguished Name"). Note that in 'cn_only' mode the
# Organizational fields, listed further below, are not used.
#
# Choices are:
#   cn_only  - Use just a commonName value.
#   org      - Use the "traditional" format:
#              Country/Province/City/Org/Org.Unit/email/commonName
#
#set_var EASYRSA_DN	"cn_only"

# Organizational fields (used with "org" mode and ignored in "cn_only" mode).
# These are the default values for fields which will be placed in the
# certificate.  Do not leave any of these fields blank, although interactively
# you may omit any specific field by typing the "." symbol (not valid for
# email).
#
# NOTE: The following characters are not supported
#       in these "Organizational fields" by Easy-RSA:
#       back-tick (`)
#
#set_var EASYRSA_REQ_COUNTRY	"US"
#set_var EASYRSA_REQ_PROVINCE	"California"
#set_var EASYRSA_REQ_CITY	"San Francisco"
#set_var EASYRSA_REQ_ORG	"Copyleft Certificate Co"
#set_var EASYRSA_REQ_EMAIL	"me@example.net"
#set_var EASYRSA_REQ_OU		"My Organizational Unit"

# Preserve the Distinguished Name field order
# of the certificate signing request
# *Only* effective in --dn-mode=org
#
#set_var EASYRSA_PRESERVE_DN	1

# Set no password mode - This will create the entire PKI without passwords.
# This can be better managed by choosing which entity private keys should be
# encrypted with the following command line options:
# Global option '--no-pass' or command option 'nopass'.
#
#set_var EASYRSA_NO_PASS	1

# Choose a size in bits for your keypairs. The recommended value is 2048.
# Using 2048-bit keys is considered more than sufficient for many years into
# the future. Larger keysizes will slow down TLS negotiation and make key/DH
# param generation take much longer. Values up to 4096 should be accepted by
# most software. Only used when the crypto alg is rsa, see below.
#
#set_var EASYRSA_KEY_SIZE	2048

# The default crypto mode is rsa; ec can enable elliptic curve support.
# Note that not all software supports ECC, so use care when enabling it.
# Choices for crypto alg are: (each in lower-case)
#  * rsa
#  * ec
#  * ed
#
#set_var EASYRSA_ALGO		rsa

# Define the named curve, used in ec & ed modes:
#
#set_var EASYRSA_CURVE		secp384r1

# In how many days should the root CA key expire?
#
#set_var EASYRSA_CA_EXPIRE	3650

# In how many days should certificates expire?
#
#set_var EASYRSA_CERT_EXPIRE	825

# How many days until the Certificate Revokation List will expire.
#
# IMPORTANT: When the CRL expires, an OpenVPN Server which uses a
# CRL will reject ALL new connections, until the CRL is replaced.
#
#set_var EASYRSA_CRL_DAYS	180

# Random serial numbers by default.
# Set to 'no' for the old incremental serial numbers.
#
#set_var EASYRSA_RAND_SN	"yes"

# Cut-off window for checking expiring certificates.
#
#set_var EASYRSA_PRE_EXPIRY_WINDOW	90

# Generate automatic subjectAltName for certificates
#
#set_var	EASYRSA_AUTO_SAN	1

# Add critical attribute to X509 fields: basicConstraints (BC),
# keyUsage (KU), extendedKeyUsage (EKU) or SAN
#
#set_var	EASYRSA_BC_CRIT		1
#set_var	EASYRSA_KU_CRIT		1
#set_var	EASYRSA_EKU_CRIT	1
#set_var	EASYRSA_SAN_CRIT	1

# Disable automatic inline files
#
#set_var	EASYRSA_DISABLE_INLINE	1
CREATE_VARS_EXAMPLE
		;;
	ssl-cnf|safe-cnf)
	# SSL config v3.2.0-1
	cat << CREATE_SSL_CONFIG
# For use with Easy-RSA 3.0+ and OpenSSL or LibreSSL

####################################################################
[ ca ]
default_ca	= CA_default		# The default ca section

####################################################################
[ CA_default ]

dir		= $conf_EASYRSA_PKI	# Where everything is kept
certs		= $conf_EASYRSA_dir			# Where the issued certs are kept
crl_dir		= $conf_EASYRSA_dir			# Where the issued crl are kept
database	= $conf_EASYRSA_dir/index.txt	# database index file.
new_certs_dir	= $conf_EASYRSA_dir/certs_by_serial	# default place for new certs.

certificate	= $conf_EASYRSA_dir/ca.crt		# The CA certificate
serial		= $conf_EASYRSA_dir/serial		# The current serial number
crl		= $conf_EASYRSA_dir/crl.pem		# The current CRL
private_key	= $conf_EASYRSA_dir/private/ca.key	# The private key
RANDFILE	= $conf_EASYRSA_dir/.rand		# private random number file

x509_extensions	= basic_exts		# The extensions to add to the cert

# A placeholder to handle the --copy-ext feature:
#%COPY_EXTS%	# Do NOT remove or change this line as --copy-ext support requires it

# This allows a V2 CRL. Ancient browsers don't like it, but anything Easy-RSA
# is designed for will. In return, we get the Issuer attached to CRLs.
crl_extensions	= crl_ext

# These fields are always configured via the command line.
# These fields are removed from this here-doc but retained
# in 'openssl-easyrsa.cnf' file, in case something breaks.
# default_days is no longer required by Easy-RSA
#default_days	= \$ENV::EASYRSA_CERT_EXPIRE	# how long to certify for
# default_crl_days is no longer required by Easy-RSA
#default_crl_days	= \$ENV::EASYRSA_CRL_DAYS	# how long before next CRL

default_md	= $conf_EASYRSA_DIGEST		# use public key default MD
preserve	= no			# keep passed DN ordering

# This allows to renew certificates which have not been revoked
unique_subject	= no

# A few different ways of specifying how similar the request should look
# For type CA, the listed attributes must be the same, and the optional
# and supplied fields are just that :-)
policy		= policy_anything

# For the 'anything' policy, which defines allowed DN fields
[ policy_anything ]
countryName		= optional
stateOrProvinceName	= optional
localityName		= optional
organizationName	= optional
organizationalUnitName	= optional
commonName		= supplied
emailAddress		= optional
serialNumber	= optional

####################################################################
# Easy-RSA request handling
# We key off \$DN_MODE to determine how to format the DN
[ req ]
default_bits		= $conf_EASYRSA_KEY_SIZE
default_keyfile	= privkey.pem
default_md		= $conf_EASYRSA_DIGEST
distinguished_name	= $conf_EASYRSA_DN
x509_extensions		= easyrsa_ca	# The extensions to add to the self signed cert

# A placeholder to handle the \$EXTRA_EXTS feature:
#%EXTRA_EXTS%	# Do NOT remove or change this line as \$EXTRA_EXTS support requires it

####################################################################
# Easy-RSA DN (Subject) handling

# Easy-RSA DN for cn_only support:
[ cn_only ]
commonName		= Common Name (eg: your user, host, or server name)
commonName_max		= 64
commonName_default	= $conf_EASYRSA_REQ_CN

# Easy-RSA DN for org support:
[ org ]
countryName			= Country Name (2 letter code)
countryName_default		= $conf_EASYRSA_REQ_COUNTRY
countryName_min			= 2
countryName_max			= 2

stateOrProvinceName		= State or Province Name (full name)
stateOrProvinceName_default	= $conf_EASYRSA_REQ_PROVINCE

localityName			= Locality Name (eg, city)
localityName_default		= $conf_EASYRSA_REQ_CITY

0.organizationName		= Organization Name (eg, company)
0.organizationName_default	= $conf_EASYRSA_REQ_ORG

organizationalUnitName		= Organizational Unit Name (eg, section)
organizationalUnitName_default	= $conf_EASYRSA_REQ_OU

commonName			= Common Name (eg: your user, host, or server name)
commonName_max			= 64
commonName_default		= $conf_EASYRSA_REQ_CN

emailAddress			= Email Address
emailAddress_default		= $conf_EASYRSA_REQ_EMAIL
emailAddress_max		= 64

serialNumber		= Serial-number (eg, device serial-number)
serialNumber_default	= $conf_EASYRSA_REQ_SERIAL

####################################################################
# Easy-RSA cert extension handling

# This section is effectively unused as the main script sets extensions
# dynamically. This core section is left to support the odd usecase where
# a user calls openssl directly.
[ basic_exts ]
basicConstraints	= CA:FALSE
subjectKeyIdentifier	= hash
authorityKeyIdentifier	= keyid,issuer:always

# The Easy-RSA CA extensions
[ easyrsa_ca ]

# PKIX recommendations:

subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always,issuer:always

# This could be marked critical, but it's nice to support reading by any
# broken clients who attempt to do so.
basicConstraints = CA:true

# Limit key usage to CA tasks. If you really want to use the generated pair as
# a self-signed cert, comment this out.
keyUsage = cRLSign, keyCertSign

# nsCertType omitted by default. Let's try to let the deprecated stuff die.
# nsCertType = sslCA

# A placeholder to handle the \$X509_TYPES and CA extra extensions \$EXTRA_EXTS:
#%CA_X509_TYPES_EXTRA_EXTS%	# Do NOT remove or change this line as \$X509_TYPES and EXTRA_EXTS demands it

# CRL extensions.
[ crl_ext ]

# Only issuerAltName and authorityKeyIdentifier make any sense in a CRL.

# issuerAltName=issuer:copy
authorityKeyIdentifier=keyid:always,issuer:always
CREATE_SSL_CONFIG
		;;
	*)
		die "create_legacy_stream: unknown type '$1'"
	esac
} # => create_legacy_stream()

# Version information
print_version() {
	ssl_version="$(
			"${EASYRSA_OPENSSL:-openssl}" version 2>/dev/null
		)"
		cat << VERSION_TEXT
EasyRSA Version Information
Version:     $EASYRSA_version
Generated:   ~DATE~
SSL Lib:     ${ssl_version:-undefined}
Git Commit:  ~GITHEAD~
Source Repo: https://github.com/OpenVPN/easy-rsa
VERSION_TEXT
} # => print_version()


########################################
# Invocation entry point:

EASYRSA_version="~VER~"
NL='
'

# Be secure with a restrictive umask
[ "$EASYRSA_NO_UMASK" ] || umask "${EASYRSA_UMASK:=077}"

# Register cleanup on EXIT
trap 'cleanup $?' EXIT
# When SIGHUP, SIGINT, SIGQUIT, SIGABRT and SIGTERM,
# explicitly exit to signal EXIT (non-bash shells)
trap "exit 1" 1
trap "exit 2" 2
trap "exit 3" 3
trap "exit 6" 6
trap "exit 15" 15

# Get host details - No configurable input allowed
detect_host

# Initialisation requirements
unset -v \
	OPENSSL_CONF \
	verify_ssl_lib_ok ssl_batch \
	secured_session \
	working_safe_ssl_conf working_safe_org_conf \
	alias_days text \
	prohibit_no_pass \
	invalid_vars \
	local_request error_build_full_cleanup \
	selfsign_eku \
	internal_batch mv_temp_error \
	easyrsa_exit_with_error error_info \
	write_recursion tools_error tools_error_txt

	# Used by build-ca->cleanup to restore prompt
	# after user interrupt when using manual password
	prompt_restore=0
	# Sequential temp-file counter
	mktemp_counter=0

# Parse options
while :; do
	# Reset per pass flags
	unset -v opt val \
		is_empty empty_ok number_only zero_allowed

	# Separate option from value:
	opt="${1%%=*}"
	val="${1#*=}"

	# Empty values are not allowed unless expected
	# eg: '--batch'
	[ "$opt" = "$val" ] && is_empty=1
	# eg: '--pki-dir='
	[ "$val" ] || is_empty=1

	case "$opt" in
		--days)
			number_only=1
			zero_allowed=1
			# Set the appropriate date variable
			# when called by command later
			alias_days="$val"
			;;
		--startdate)
			export EASYRSA_START_DATE="$val"
			;;
		--enddate)
			export EASYRSA_END_DATE="$val"
			;;
		--pki-dir|--pki)
			export EASYRSA_PKI="$val"
			;;
		--tmp-dir)
			export EASYRSA_TEMP_DIR="$val"
			;;
		--ssl-cnf|--ssl-conf)
			export EASYRSA_SSL_CONF="$val"
			;;
		--keep-tmp)
			export EASYRSA_KEEP_TEMP="$val"
			;;
		--use-algo)
			export EASYRSA_ALGO="$val"
			;;
		--keysize)
			number_only=1
			export EASYRSA_KEY_SIZE="$val"
			;;
		--curve)
			export EASYRSA_CURVE="$val"
			;;
		--dn-mode)
			export EASYRSA_DN="$val"
			;;
		--req-cn)
			export EASYRSA_REQ_CN="$val"
			;;
		--digest)
			export EASYRSA_DIGEST="$val"
			;;
		--req-c)
			empty_ok=1
			export EASYRSA_REQ_COUNTRY="$val"
			;;
		--req-st)
			empty_ok=1
			export EASYRSA_REQ_PROVINCE="$val"
			;;
		--req-city)
			empty_ok=1
			export EASYRSA_REQ_CITY="$val"
			;;
		--req-org)
			empty_ok=1
			export EASYRSA_REQ_ORG="$val"
			;;
		--req-email)
			empty_ok=1
			export EASYRSA_REQ_EMAIL="$val"
			;;
		--req-ou)
			empty_ok=1
			export EASYRSA_REQ_OU="$val"
			;;
		--req-serial)
			empty_ok=1
			export EASYRSA_REQ_SERIAL="$val"
			;;
		--ns-cert)
			empty_ok=1
			[ "$is_empty" ] && unset -v val
			export EASYRSA_NS_SUPPORT="${val:-yes}"
			;;
		--ns-comment)
			empty_ok=1
			export EASYRSA_NS_COMMENT="$val"
			;;
		--batch)
			empty_ok=1
			export EASYRSA_BATCH=1
			;;
		-s|--silent)
			empty_ok=1
			export EASYRSA_SILENT=1
			;;
		--sbatch|--silent-batch)
			empty_ok=1
			export EASYRSA_SILENT=1
			export EASYRSA_BATCH=1
			;;
		--verbose)
			empty_ok=1
			export EASYRSA_VERBOSE=1
			;;
		--days-margin)
			# ONLY ALLOWED use by status reports
			number_only=1
			export EASYRSA_iso_8601_MARGIN="$val"
			;;
		-S|--silent-ssl)
			empty_ok=1
			export EASYRSA_SILENT_SSL=1
			;;
		--force-safe-ssl)
			empty_ok=1
			export EASYRSA_FORCE_SAFE_SSL=1
			;;
		--nopass|--no-pass)
			empty_ok=1
			export EASYRSA_NO_PASS=1
			;;
		--passin)
			export EASYRSA_PASSIN="$val"
			;;
		--passout)
			export EASYRSA_PASSOUT="$val"
			;;
		--raw-ca)
			empty_ok=1
			export EASYRSA_RAW_CA=1
			;;
		--notext|--no-text)
			empty_ok=1
			export EASYRSA_NO_TEXT=1
			;;
		--subca-len)
			number_only=1
			zero_allowed=1
			export EASYRSA_SUBCA_LEN="$val"
			;;
		--vars)
			export EASYRSA_VARS_FILE="$val"
			;;
		--copy-ext)
			empty_ok=1
			export EASYRSA_CP_EXT=1
			;;
		--subject-alt-name|--san)
			# This allows --san to be used multiple times
			if [ "$EASYRSA_SAN" ]; then
				EASYRSA_SAN="$EASYRSA_SAN, $val"
			else
				EASYRSA_SAN="$val"
			fi
			;;
		--auto-san)
			empty_ok=1
			export EASYRSA_AUTO_SAN=1
			;;
		--san-crit*)
			empty_ok=1
			export EASYRSA_SAN_CRIT='critical,'
			;;
		--bc-crit*)
			empty_ok=1
			export EASYRSA_BC_CRIT=1
			;;
		--ku-crit*)
			empty_ok=1
			export EASYRSA_KU_CRIT=1
			;;
		--eku-crit*)
			empty_ok=1
			export EASYRSA_EKU_CRIT=1
			;;
		--new-subj*)
			export EASYRSA_NEW_SUBJECT="$val"
			;;
		--usefn)
			export EASYRSA_P12_FR_NAME="$val"
			;;
		--tools)
			export EASYRSA_TOOLS_LIB="$val"
			;;
		--version)
			shift "$#"
			set -- "$@" "version"
			break
			;;
		-h|--help|--usage)
			shift "$#"
			set -- "$@" "help"
			break
			;;
		-*)
			user_error "\
Unknown option '$opt'.
Run 'easyrsa help options' for option help."
			;;
		*)
			break
	esac

	# fatal error when no value was provided
	if [ "$is_empty" ]; then
		[ "$empty_ok" ] || \
			user_error "Missing value to option: $opt"
	fi

	# fatal error when a number is expected but not provided
	if [ "$number_only" ]; then
		case "$val" in
			(0)
				# Allow zero only
				[ "$zero_allowed" ] || \
					user_error "$opt - Number expected: '$val'"
				;;
			(*[!1234567890]*|0*)
				user_error "$opt - Number expected: '$val'"
		esac
	fi

	shift
done

# option dependencies
# Add full --san to extra extensions
if [ "$EASYRSA_SAN" ]; then
	EASYRSA_EXTRA_EXTS="\
$EASYRSA_EXTRA_EXTS
subjectAltName = ${EASYRSA_SAN_CRIT}${EASYRSA_SAN}"
fi

# Set cmd now
# vars_setup needs to know if this is init-pki
cmd="$1"
[ "$1" ] && shift # scrape off command

# Establish PKI and CA initialisation requirements
unset -v require_pki require_ca quiet_vars

case "$cmd" in
	''|help|version|show-host|rand|random)
		unset -v EASYRSA_SILENT
		quiet_vars=1
		;;
	init-pki|clean-all)
		: # ok
		;;
	*)
		require_pki=1
		case "$cmd" in
			gen-req|gen-dh|build-ca|show-req|export-p*| \
			inline|self-sign-*|write)
				: ;; # ok
			*) require_ca=1
		esac
esac

# Intelligent env-var detection and auto-loading:
# Select vars file as EASYRSA_VARS_FILE
# then source the vars file, if found
# otherwise, ignore no vars file
if select_vars; then
	[ "$quiet_vars" ] || information "\
Using Easy-RSA 'vars' configuration:
* $EASYRSA_VARS_FILE"
	source_vars "$EASYRSA_VARS_FILE"
else
	verbose "\
No Easy-RSA 'vars' configuration file exists!"
fi

# then set defaults
default_vars

# Check for unexpected changes to EASYRSA or EASYRSA_PKI
# https://github.com/OpenVPN/easy-rsa/issues/1006
validate_default_vars

# Check for conflicting input options
mutual_exclusions

# Verify SSL Lib - One time ONLY
verify_ssl_lib

# Hand off to the function responsible
# ONLY verify_working_env() for valid commands
case "$cmd" in
	init-pki|clean-all)
		verify_working_env
		init_pki "$@"
		;;
	build-ca)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CA_EXPIRE="$alias_days"
		build_ca "$@"
		;;
	self-sign-server)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		self_sign server "$@"
		;;
	self-sign-client)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		self_sign client "$@"
		;;
	self*)
		user_error "Self-sign syntax example: 'self-sign-server foo'"
		;;
	gen-dh)
		verify_working_env
		gen_dh
		;;
	gen-req)
		verify_working_env
		gen_req "$@"
		;;
	sign|sign-req)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		sign_req "$@"
		;;
	build-client-full)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		build_full client "$@"
		;;
	build-server-full)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		build_full server "$@"
		;;
	build-serverClient-full)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		build_full serverClient "$@"
		;;
	gen-crl)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CRL_DAYS="$alias_days"
		gen_crl
		;;
	revoke|revoke-issued)
		verify_working_env
		revoke 'issued' "$@"
		;;
	revoke-expired)
		verify_working_env
		revoke 'expired' "$@"
		;;
	revoke-renewed)
		verify_working_env
		revoke 'renewed/issued' "$@"
		;;
	import-req)
		verify_working_env
		import_req "$@"
		;;
	expire)
		verify_working_env
		expire_cert "$@"
		;;
	inline)
		verify_working_env
		inline_file "$@"
		;;
	export-p12)
		verify_working_env
		export_pkcs p12 "$@"
		;;
	export-p7)
		verify_working_env
		export_pkcs p7 "$@"
		;;
	export-p8)
		verify_working_env
		export_pkcs p8 "$@"
		;;
	export-p1)
		verify_working_env
		export_pkcs p1 "$@"
		;;
	set-pass|set-rsa-pass|set-ec-pass|set-ed-pass)
		verify_working_env
		set_pass "$@"
		;;
	update-db)
		verify_working_env
		update_db
		;;
	show-req)
		verify_working_env
		show req "$@"
		;;
	show-cert)
		verify_working_env
		show cert "$@"
		;;
	show-crl)
		verify_working_env
		show crl crl
		;;
	show-ca)
		verify_working_env
		show_ca "$@"
		;;
	show-host)
		verify_working_env
		show_host "$@"
		;;
	renew-ca)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CA_EXPIRE="$alias_days"
		renew_ca_cert "$@"
		;;
	renew)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		renew "$@"
		;;
	show-expire)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_PRE_EXPIRY_WINDOW="$alias_days"
		status expire "$@"
		;;
	show-revoke)
		verify_working_env
		status revoke "$@"
		;;
	show-renew)
		verify_working_env
		status renew "$@"
		;;
	verify-cert)
		verify_working_env
		# Called with --batch, this will return error
		# when the certificate fails verification.
		# Therefore, on error, exit with error.
		verify_cert "$@" || easyrsa_exit_with_error=1
		;;
	gen-tls-auth|gen-tls-auth-*)
		verify_working_env
		tls_key_gen tls-auth "$@"
		;;
	gen-tls-crypt|gen-tls-crypt-*)
		verify_working_env
		tls_key_gen tls-crypt "$@"
		;;
	gen-tls-cryptv2|gen-tls-cryptv2-*)
		verify_working_env
		tls_key_gen tls-crypt-v2 "$@"
		;;
	write)
		verify_working_env

		# Write legacy files to write_dir
		# or EASYRSA_PKI or EASYRSA
		case "$1" in
		legacy)
			# over-write NO
			shift
			legacy_file_over_write=
			all_legacy_files_v2 "$@"
			;;
		legacy-hard)
			# over-write YES
			shift
			legacy_file_over_write=overwrite
			all_legacy_files_v2 "$@"
			;;
		*)
			write_legacy_file_v2 "$@"
		esac
		;;
	serial|check-serial)
		verify_working_env
		# Called with --batch, this will return error
		# when the serial number is not unique.
		# Therefore, on error, exit with error.
		check_serial_unique "$@" || \
			easyrsa_exit_with_error=1
		;;
	display-dn)
		verify_working_env
		display_dn "$@"
		;;
	x509-eku|show-eku)
		verify_working_env
		ssl_cert_x509v3_eku "$@" || \
			easyrsa_exit_with_error=1
		;;
	rand|random)
		easyrsa_random "$1"
		;;
	""|help|-h|--help|--usage)
		verify_working_env
		cmd_help "$1"
		;;
	version)
		print_version
		;;
	*)
		user_error "\
Unknown command '$cmd'. Run without commands for usage help."
esac

# Check for untrapped errors
# shellcheck disable=SC2181 # Quote expand - pre-cleanup $?
if [ $? = 0 ]; then
	# Do 'cleanup ok' on successful completion
	cleanup ok
fi

# Otherwise, exit with error
print "Untrapped error detected!"
cleanup

# vim: ft=sh nu ai sw=8 ts=8 noet

================
File: pki/easy-rsa/easyrsa3/openssl-easyrsa.cnf
================
# For use with Easy-RSA 3.0+ and OpenSSL or LibreSSL

####################################################################
[ ca ]
default_ca	= CA_default		# The default ca section

####################################################################
[ CA_default ]

dir		= $ENV::EASYRSA_PKI	# Where everything is kept
certs		= $dir			# Where the issued certs are kept
crl_dir		= $dir			# Where the issued crl are kept
database	= $dir/index.txt	# database index file.
new_certs_dir	= $dir/certs_by_serial	# default place for new certs.

certificate	= $dir/ca.crt		# The CA certificate
serial		= $dir/serial		# The current serial number
crl		= $dir/crl.pem		# The current CRL
private_key	= $dir/private/ca.key	# The private key
RANDFILE	= $dir/.rand		# private random number file

x509_extensions	= basic_exts		# The extensions to add to the cert

# A placeholder to handle the --copy-ext feature:
#%COPY_EXTS%	# Do NOT remove or change this line as --copy-ext support requires it

# This allows a V2 CRL. Ancient browsers don't like it, but anything Easy-RSA
# is designed for will. In return, we get the Issuer attached to CRLs.
crl_extensions	= crl_ext

default_days	= $ENV::EASYRSA_CERT_EXPIRE	# how long to certify for
default_crl_days	= $ENV::EASYRSA_CRL_DAYS	# how long before next CRL
default_md	= $ENV::EASYRSA_DIGEST		# use public key default MD

# Note: preserve=no|yes, does nothing for EasyRSA.
# Use sign-req command option 'preserve' instead.
preserve	= no			# keep passed DN ordering

# This allows to renew certificates which have not been revoked
unique_subject	= no

# A few different ways of specifying how similar the request should look
# For type CA, the listed attributes must be the same, and the optional
# and supplied fields are just that :-)
policy		= policy_anything

# For the 'anything' policy, which defines allowed DN fields
[ policy_anything ]
countryName		= optional
stateOrProvinceName	= optional
localityName		= optional
organizationName	= optional
organizationalUnitName	= optional
commonName		= supplied
emailAddress		= optional
serialNumber	= optional

####################################################################
# Easy-RSA request handling
# We key off $DN_MODE to determine how to format the DN
[ req ]
default_bits		= $ENV::EASYRSA_KEY_SIZE
default_keyfile	= privkey.pem
default_md		= $ENV::EASYRSA_DIGEST
distinguished_name	= $ENV::EASYRSA_DN
x509_extensions		= easyrsa_ca	# The extensions to add to the self signed cert

# A placeholder to handle the $EXTRA_EXTS feature:
#%EXTRA_EXTS%	# Do NOT remove or change this line as $EXTRA_EXTS support requires it

####################################################################
# Easy-RSA DN (Subject) handling

# Easy-RSA DN for cn_only support:
[ cn_only ]
commonName		= Common Name (eg: your user, host, or server name)
commonName_max		= 64
commonName_default	= $ENV::EASYRSA_REQ_CN

# Easy-RSA DN for org support:
[ org ]
countryName			= Country Name (2 letter code)
countryName_default		= $ENV::EASYRSA_REQ_COUNTRY
countryName_min			= 2
countryName_max			= 2

stateOrProvinceName		= State or Province Name (full name)
stateOrProvinceName_default	= $ENV::EASYRSA_REQ_PROVINCE

localityName			= Locality Name (eg, city)
localityName_default		= $ENV::EASYRSA_REQ_CITY

0.organizationName		= Organization Name (eg, company)
0.organizationName_default	= $ENV::EASYRSA_REQ_ORG

organizationalUnitName		= Organizational Unit Name (eg, section)
organizationalUnitName_default	= $ENV::EASYRSA_REQ_OU

commonName			= Common Name (eg: your user, host, or server name)
commonName_max			= 64
commonName_default		= $ENV::EASYRSA_REQ_CN

emailAddress			= Email Address
emailAddress_default		= $ENV::EASYRSA_REQ_EMAIL
emailAddress_max		= 64

serialNumber		= Serial-number (eg, device serial-number)
serialNumber_default	= $ENV::EASYRSA_REQ_SERIAL

####################################################################
# Easy-RSA cert extension handling

# This section is effectively unused as the main script sets extensions
# dynamically. This core section is left to support the odd usecase where
# a user calls openssl directly.
[ basic_exts ]
basicConstraints	= CA:FALSE
subjectKeyIdentifier	= hash
authorityKeyIdentifier	= keyid,issuer:always

# The Easy-RSA CA extensions
[ easyrsa_ca ]

# PKIX recommendations:

subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always,issuer:always

# This could be marked critical, but it's nice to support reading by any
# broken clients who attempt to do so.
basicConstraints = CA:true

# Limit key usage to CA tasks. If you really want to use the generated pair as
# a self-signed cert, comment this out.
keyUsage = cRLSign, keyCertSign

# nsCertType omitted by default. Let's try to let the deprecated stuff die.
# nsCertType = sslCA

# A placeholder to handle the $X509_TYPES and CA extra extensions $EXTRA_EXTS:
#%CA_X509_TYPES_EXTRA_EXTS%	# Do NOT remove or change this line as $X509_TYPES and EXTRA_EXTS demands it

# CRL extensions.
[ crl_ext ]

# Only issuerAltName and authorityKeyIdentifier make any sense in a CRL.

# issuerAltName=issuer:copy
authorityKeyIdentifier=keyid:always,issuer:always

================
File: pki/easy-rsa/easyrsa3/vars.example
================
# Easy-RSA 3 parameter settings

# NOTE: If you installed Easy-RSA from your package manager, do not edit
# this file in place -- instead, you should copy the entire easy-rsa directory
# to another location so future upgrades do not wipe out your changes.

# HOW TO USE THIS FILE
#
# vars.example contains built-in examples to Easy-RSA settings. You MUST name
# this file "vars" if you want it to be used as a configuration file. If you
# do not, it WILL NOT be automatically read when you call easyrsa commands.
#
# It is not necessary to use this config file unless you wish to change
# operational defaults. These defaults should be fine for many uses without
# the need to copy and edit the "vars" file.
#
# All of the editable settings are shown commented and start with the command
# "set_var" -- this means any set_var command that is uncommented has been
# modified by the user. If you are happy with a default, there is no need to
# define the value to its default.

# NOTES FOR WINDOWS USERS
#
# Paths for Windows  *MUST* use forward slashes, or optionally double-escaped
# backslashes (single forward slashes are recommended.) This means your path
# to the openssl binary might look like this:
# "C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# A little housekeeping: DO NOT EDIT THIS SECTION
#
# Easy-RSA 3.x does not source into the environment directly.
# Complain if a user tries to do this:
if [ -z "$EASYRSA_CALLER" ]; then
	echo "You appear to be sourcing an Easy-RSA *vars* file. This is" >&2
	echo "no longer necessary and is disallowed. See the section called" >&2
	echo "*How to use this file* near the top comments for more details." >&2
	return 1
fi

# DO YOUR EDITS BELOW THIS POINT

# This variable is used as the base location of configuration files needed by
# easyrsa.  More specific variables for specific files (eg: EASYRSA_SSL_CONF)
# may override this default.
#
# The default value of this variable is the location of the easyrsa script
# itself, which is also where the configuration files are located in the
# easy-rsa tree.
#
#set_var EASYRSA	"${0%/*}"

# If your OpenSSL command is not in the system PATH, you will need to define
# the path here. Normally this means a full path to the executable, otherwise
# you could have left it undefined here and the shown default would be used.
#
# Windows users, remember to use paths with forward-slashes (or escaped
# back-slashes.) Windows users should declare the full path to the openssl
# binary here if it is not in their system PATH.
#
#set_var EASYRSA_OPENSSL	"openssl"
#
# This sample is in Windows syntax -- edit it for your path if not using PATH:
#set_var EASYRSA_OPENSSL	"C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# Define X509 DN mode.
#
# This is used to adjust which elements are included in the Subject field
# as the DN ("Distinguished Name"). Note that in 'cn_only' mode the
# Organizational fields, listed further below, are not used.
#
# Choices are:
#   cn_only  - Use just a commonName value.
#   org      - Use the "traditional" format:
#              Country/Province/City/Org/Org.Unit/email/commonName
#
#set_var EASYRSA_DN	"cn_only"

# Organizational fields (used with "org" mode and ignored in "cn_only" mode).
# These are the default values for fields which will be placed in the
# certificate.  Do not leave any of these fields blank, although interactively
# you may omit any specific field by typing the "." symbol (not valid for
# email).
#
# NOTE: The following characters are not supported
#       in these "Organizational fields" by Easy-RSA:
#       back-tick (`)
#
#set_var EASYRSA_REQ_COUNTRY	"US"
#set_var EASYRSA_REQ_PROVINCE	"California"
#set_var EASYRSA_REQ_CITY	"San Francisco"
#set_var EASYRSA_REQ_ORG	"Copyleft Certificate Co"
#set_var EASYRSA_REQ_EMAIL	"me@example.net"
#set_var EASYRSA_REQ_OU		"My Organizational Unit"

# Preserve the Distinguished Name field order
# of the certificate signing request
# *Only* effective in --dn-mode=org
#
#set_var EASYRSA_PRESERVE_DN	1

# Set no password mode - This will create the entire PKI without passwords.
# This can be better managed by choosing which entity private keys should be
# encrypted with the following command line options:
# Global option '--no-pass' or command option 'nopass'.
#
#set_var EASYRSA_NO_PASS	1

# Choose a size in bits for your keypairs. The recommended value is 2048.
# Using 2048-bit keys is considered more than sufficient for many years into
# the future. Larger keysizes will slow down TLS negotiation and make key/DH
# param generation take much longer. Values up to 4096 should be accepted by
# most software. Only used when the crypto alg is rsa, see below.
#
#set_var EASYRSA_KEY_SIZE	2048

# The default crypto mode is rsa; ec can enable elliptic curve support.
# Note that not all software supports ECC, so use care when enabling it.
# Choices for crypto alg are: (each in lower-case)
#  * rsa
#  * ec
#  * ed
#
#set_var EASYRSA_ALGO		rsa

# Define the named curve, used in ec & ed modes:
#
#set_var EASYRSA_CURVE		secp384r1

# In how many days should the root CA key expire?
#
#set_var EASYRSA_CA_EXPIRE	3650

# In how many days should certificates expire?
#
#set_var EASYRSA_CERT_EXPIRE	825

# How many days until the Certificate Revokation List will expire.
#
# IMPORTANT: When the CRL expires, an OpenVPN Server which uses a
# CRL will reject ALL new connections, until the CRL is replaced.
#
#set_var EASYRSA_CRL_DAYS	180

# Random serial numbers by default.
# Set to 'no' for the old incremental serial numbers.
#
#set_var EASYRSA_RAND_SN	"yes"

# Cut-off window for checking expiring certificates.
#
#set_var EASYRSA_PRE_EXPIRY_WINDOW	90

# Generate automatic subjectAltName for certificates
#
#set_var	EASYRSA_AUTO_SAN	1

# Add critical attribute to X509 fields: basicConstraints (BC),
# keyUsage (KU), extendedKeyUsage (EKU) or SAN
#
#set_var	EASYRSA_BC_CRIT		1
#set_var	EASYRSA_KU_CRIT		1
#set_var	EASYRSA_EKU_CRIT	1
#set_var	EASYRSA_SAN_CRIT	1

# Disable automatic inline files
#
#set_var	EASYRSA_DISABLE_INLINE	1

# Support deprecated "Netscape" extensions? (choices "yes" or "no").
# The default is "no", to discourage use of deprecated extensions.
# If you require this feature to use with --ns-cert-type, set this to "yes".
# This support should be replaced with the more modern --remote-cert-tls
# feature.  If you do not use --ns-cert-type in your configs, it is safe,
# and recommended, to leave this defined to "no".
# When set to "yes", server-signed certs get the nsCertType=server attribute
# and also get any NS_COMMENT defined below in the nsComment field.
#
#set_var EASYRSA_NS_SUPPORT	"no"

# When NS_SUPPORT is set to "yes", this field is added as the nsComment field.
# Set this blank to omit it. With NS_SUPPORT set to "no" this field is ignored.
#
#set_var EASYRSA_NS_COMMENT	"Easy-RSA Generated Certificate"

# !!
# NOTE: ADVANCED OPTIONS BELOW THIS POINT
# PLAY WITH THEM AT YOUR OWN RISK
# !!

# Broken shell command aliases: If you have a largely broken shell that is
# missing any of these POSIX-required commands used by Easy-RSA, you will need
# to define an alias to the proper path for the command.  The symptom will be
# some form of a "command not found" error from your shell. This means your
# shell is BROKEN, but you can hack around it here if you really need. These
# shown values are not defaults: it is up to you to know what you are doing if
# you touch these.
#
#alias awk="/alt/bin/awk"
#alias cat="/alt/bin/cat"

# X509 extensions directory:
# If you want to customize the X509 extensions used, set the directory to look
# for extensions here. Each cert type you sign must have a matching filename,
# and an optional file named "COMMON" is included first when present. Note that
# when undefined here, default behaviour is to look in $EASYRSA_PKI first, then
# fallback to $EASYRSA for the "x509-types" dir.  You may override this
# detection with an explicit dir here.
#
#set_var EASYRSA_EXT_DIR	"$EASYRSA/x509-types"

# Non-functional
# If you want to generate KDC certificates, you need to set the realm here.
#
#set_var EASYRSA_KDC_REALM      "CHANGEME.EXAMPLE.COM"

# OpenSSL config file:
# If you need to use a specific openssl config file, you can reference it here.
# Normally this file is auto-detected from a file named openssl-easyrsa.cnf
# from the EASYRSA_PKI or EASYRSA dir, in that order. NOTE that this file is
# Easy-RSA specific and you cannot just use a standard config file, so this is
# an advanced feature.
#
#set_var EASYRSA_SSL_CONF	"$EASYRSA_PKI/openssl-easyrsa.cnf"

# Cryptographic digest to use.
# Do not change this default unless you understand the security implications.
# Valid choices include: md5, sha1, sha256, sha224, sha384, sha512
#
#set_var EASYRSA_DIGEST		"sha256"

# Batch mode. Leave this disabled unless you intend to call Easy-RSA explicitly
# in batch mode without any user input, confirmation on dangerous operations,
# or most output. Setting this to any non-blank string enables batch mode.
#
#set_var EASYRSA_BATCH		""

================
File: pki/easy-rsa/Licensing/gpl-2.0.txt
================
GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

================
File: pki/easy-rsa/pki/certs_by_serial/967FF89932D79EEA6ABB4114F96CE482.pem
================
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            96:7f:f8:99:32:d7:9e:ea:6a:bb:41:14:f9:6c:e4:82
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=pki.example.tld
        Validity
            Not Before: Feb  3 14:09:09 2025 GMT
            Not After : May  9 14:09:09 2027 GMT
        Subject: CN=mqtt.example.tld
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:a7:81:73:41:ce:6f:64:52:ea:68:c4:96:6b:97:
                    96:31:e1:86:0f:30:26:32:f7:0a:c9:47:53:70:ec:
                    3e:d8:96:f9:99:2d:2e:8d:b4:b3:02:05:0e:40:63:
                    69:44:4f:8e:c6:06:6f:e3:65:b3:4b:ae:14:b3:3b:
                    bf:36:32:48:5d:b4:07:af:b7:11:6b:04:c2:09:8b:
                    8f:64:d1:42:ef:d1:d7:70:08:8e:c7:23:55:ce:3f:
                    ff:6b:a4:be:8d:17:6c:24:e8:8f:06:2f:0c:7f:43:
                    d1:85:e8:e5:54:2d:51:d5:a8:a3:5a:55:d2:4d:2b:
                    04:33:0f:54:93:8a:d4:0e:5b:1b:70:c8:db:a4:d9:
                    cd:4a:17:12:1a:77:87:64:db:53:b3:c2:b7:27:66:
                    84:0a:48:e5:bb:d8:60:f6:c5:32:c3:1f:86:16:9d:
                    09:20:6e:7b:2d:4f:d3:29:c0:f0:36:d5:84:81:ea:
                    59:b2:a7:b8:82:0d:57:49:0a:0a:f7:31:b8:02:51:
                    e6:94:20:37:62:75:df:93:e2:10:ec:8f:a3:f2:a0:
                    44:c7:18:29:34:da:91:a4:f6:5c:03:07:78:59:e3:
                    05:fe:58:6e:3d:e4:41:07:cc:28:7c:d8:90:6b:da:
                    6e:e7:22:1b:ba:d9:8f:13:3b:5a:8b:c2:0c:b9:50:
                    62:57
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Basic Constraints: 
                CA:FALSE
            X509v3 Subject Key Identifier: 
                DE:2B:C6:06:A9:41:45:AD:6A:0E:13:6D:EC:5A:ED:73:72:70:42:E2
            X509v3 Authority Key Identifier: 
                keyid:48:75:89:D3:5A:86:ED:A9:4B:E0:1F:D1:E8:24:9E:7D:5E:FB:84:2A
                DirName:/CN=pki.example.tld
                serial:7A:60:D9:26:19:E1:3E:2B:45:58:C7:DA:58:79:16:A6:5C:21:7B:28
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication
            X509v3 Key Usage: 
                Digital Signature, Key Encipherment
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        09:c8:c7:5f:b9:93:11:08:23:ca:11:20:12:b8:54:6f:35:2b:
        1f:e8:90:ba:dd:ba:d1:0d:51:a1:e4:33:76:fd:95:6a:9b:4c:
        0c:5f:91:9f:94:ee:4c:f5:79:e7:fb:0c:c8:b4:1f:bf:4a:d4:
        bb:b3:ee:b6:12:bc:9a:4a:63:c6:ff:87:2f:e9:dd:6c:8e:ee:
        76:13:cf:c6:29:ca:0f:a6:0d:8a:cd:13:bf:13:06:6e:b0:68:
        c2:ab:8d:3e:af:15:be:2e:c0:a3:4f:5b:50:0c:2f:06:8f:8f:
        42:ab:a0:1b:41:44:4f:29:98:4a:e0:05:52:57:9b:10:0e:b6:
        49:00:6b:46:ef:8c:1d:de:5e:d9:3e:e9:a0:21:b7:b2:2c:e9:
        61:ca:d6:90:e0:d9:ad:c9:7e:0c:8e:9b:c5:70:4f:81:6b:d0:
        6c:a8:6c:eb:f6:fb:06:1e:41:fb:ec:a2:f8:95:c5:8c:71:c9:
        e3:f9:6c:c5:b9:c0:12:1d:72:b9:43:81:16:d2:61:c3:e1:94:
        3b:a3:b2:60:45:da:be:b4:4c:80:3b:13:91:c0:2b:7c:73:15:
        8e:fc:3b:dd:c4:e8:20:fd:82:d9:3e:d8:83:e4:92:68:7c:2d:
        86:8d:a6:3f:9a:0a:4e:a6:77:17:6a:13:de:56:60:f3:7b:19:
        80:2f:69:17:fc:a7:3c:73:e7:3e:a0:6d:4b:cc:74:cb:67:50:
        f7:4d:dd:56:b1:9c:77:16:29:af:62:82:5e:24:ac:fa:af:04:
        9b:c3:6c:4c:bd:2b:93:eb:55:49:0a:31:1f:89:af:1e:30:06:
        14:84:48:ad:fb:20:23:17:37:18:b9:f4:05:26:2b:f6:7b:14:
        df:31:42:72:b4:2c:62:fa:85:b9:73:aa:c4:41:43:04:09:7d:
        b6:db:a9:b3:aa:fe:66:46:cf:cc:50:7b:80:9b:89:e1:58:aa:
        8b:87:1a:5b:0d:d9:ec:c6:00:00:ae:66:14:27:89:fb:f9:9b:
        2e:17:5b:7d:1d:44:bd:a9:08:3a:1a:c2:cd:64:50:8b:fb:7a:
        c2:a0:5f:3c:8f:c7:a8:9f:17:9b:fe:22:e7:27:ec:de:26:95:
        5f:99:cd:0b:7b:9e:92:51:84:c7:32:50:dc:bd:64:cd:8a:20:
        c7:ce:8a:ef:1c:29:cb:c2:b2:76:d8:cd:5a:ab:46:65:a3:3f:
        db:57:e7:ad:68:6e:3a:23:d2:6a:e9:65:3c:ef:81:2a:db:18:
        c7:86:d0:5d:51:cc:3b:db:bb:98:e6:61:9b:fc:f0:9e:62:5f:
        e6:7c:b0:3a:ff:08:a7:45:ab:22:e1:62:22:50:98:0d:d0:c3:
        28:1a:48:b6:2e:b8:d1:6d
-----BEGIN CERTIFICATE-----
MIIEZzCCAk+gAwIBAgIRAJZ/+Jky157qartBFPls5IIwDQYJKoZIhvcNAQELBQAw
GjEYMBYGA1UEAwwPcGtpLmV4YW1wbGUudGxkMB4XDTI1MDIwMzE0MDkwOVoXDTI3
MDUwOTE0MDkwOVowGzEZMBcGA1UEAwwQbXF0dC5leGFtcGxlLnRsZDCCASIwDQYJ
KoZIhvcNAQEBBQADggEPADCCAQoCggEBAKeBc0HOb2RS6mjElmuXljHhhg8wJjL3
CslHU3DsPtiW+ZktLo20swIFDkBjaURPjsYGb+Nls0uuFLM7vzYySF20B6+3EWsE
wgmLj2TRQu/R13AIjscjVc4//2ukvo0XbCTojwYvDH9D0YXo5VQtUdWoo1pV0k0r
BDMPVJOK1A5bG3DI26TZzUoXEhp3h2TbU7PCtydmhApI5bvYYPbFMsMfhhadCSBu
ey1P0ynA8DbVhIHqWbKnuIINV0kKCvcxuAJR5pQgN2J135PiEOyPo/KgRMcYKTTa
kaT2XAMHeFnjBf5Ybj3kQQfMKHzYkGvabuciG7rZjxM7WovCDLlQYlcCAwEAAaOB
pjCBozAJBgNVHRMEAjAAMB0GA1UdDgQWBBTeK8YGqUFFrWoOE23sWu1zcnBC4jBV
BgNVHSMETjBMgBRIdYnTWobtqUvgH9HoJJ59XvuEKqEepBwwGjEYMBYGA1UEAwwP
cGtpLmV4YW1wbGUudGxkghR6YNkmGeE+K0VYx9pYeRamXCF7KDATBgNVHSUEDDAK
BggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAAnIx1+5
kxEII8oRIBK4VG81Kx/okLrdutENUaHkM3b9lWqbTAxfkZ+U7kz1eef7DMi0H79K
1Luz7rYSvJpKY8b/hy/p3WyO7nYTz8Ypyg+mDYrNE78TBm6waMKrjT6vFb4uwKNP
W1AMLwaPj0KroBtBRE8pmErgBVJXmxAOtkkAa0bvjB3eXtk+6aAht7Is6WHK1pDg
2a3JfgyOm8VwT4Fr0GyobOv2+wYeQfvsoviVxYxxyeP5bMW5wBIdcrlDgRbSYcPh
lDujsmBF2r60TIA7E5HAK3xzFY78O93E6CD9gtk+2IPkkmh8LYaNpj+aCk6mdxdq
E95WYPN7GYAvaRf8pzxz5z6gbUvMdMtnUPdN3VaxnHcWKa9igl4krPqvBJvDbEy9
K5PrVUkKMR+Jrx4wBhSESK37ICMXNxi59AUmK/Z7FN8xQnK0LGL6hblzqsRBQwQJ
fbbbqbOq/mZGz8xQe4CbieFYqouHGlsN2ezGAACuZhQnifv5my4XW30dRL2pCDoa
ws1kUIv7esKgXzyPx6ifF5v+Iucn7N4mlV+ZzQt7npJRhMcyUNy9ZM2KIMfOiu8c
KcvCsnbYzVqrRmWjP9tX561objoj0mrpZTzvgSrbGMeG0F1RzDvbu5jmYZv88J5i
X+Z8sDr/CKdFqyLhYiJQmA3QwygaSLYuuNFt
-----END CERTIFICATE-----

================
File: pki/easy-rsa/pki/inline/private/README.inline.private
================
# Inline files in the 'private' directory contain security keys which
# MUST only be transmitted over a secure connection, such as 'scp'.

================
File: pki/easy-rsa/pki/inline/mqtt.example.tld.inline
================
# Easy-RSA Inline file
# Certificate type: server
# commonName: mqtt.example.tld
# SHA256 fingerprint:
# A1:FB:5E:D5:A6:96:C6:72:25:71:EA:FA:21:51:29:DD:B0:2A:35:5D:18:DD:E2:3E:D7:C2:3A:17:94:D6:FF:89
# Decimal serial number: 200048663243996794341520840514190763138

<cert>
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            96:7f:f8:99:32:d7:9e:ea:6a:bb:41:14:f9:6c:e4:82
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=pki.example.tld
        Validity
            Not Before: Feb  3 14:09:09 2025 GMT
            Not After : May  9 14:09:09 2027 GMT
        Subject: CN=mqtt.example.tld
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:a7:81:73:41:ce:6f:64:52:ea:68:c4:96:6b:97:
                    96:31:e1:86:0f:30:26:32:f7:0a:c9:47:53:70:ec:
                    3e:d8:96:f9:99:2d:2e:8d:b4:b3:02:05:0e:40:63:
                    69:44:4f:8e:c6:06:6f:e3:65:b3:4b:ae:14:b3:3b:
                    bf:36:32:48:5d:b4:07:af:b7:11:6b:04:c2:09:8b:
                    8f:64:d1:42:ef:d1:d7:70:08:8e:c7:23:55:ce:3f:
                    ff:6b:a4:be:8d:17:6c:24:e8:8f:06:2f:0c:7f:43:
                    d1:85:e8:e5:54:2d:51:d5:a8:a3:5a:55:d2:4d:2b:
                    04:33:0f:54:93:8a:d4:0e:5b:1b:70:c8:db:a4:d9:
                    cd:4a:17:12:1a:77:87:64:db:53:b3:c2:b7:27:66:
                    84:0a:48:e5:bb:d8:60:f6:c5:32:c3:1f:86:16:9d:
                    09:20:6e:7b:2d:4f:d3:29:c0:f0:36:d5:84:81:ea:
                    59:b2:a7:b8:82:0d:57:49:0a:0a:f7:31:b8:02:51:
                    e6:94:20:37:62:75:df:93:e2:10:ec:8f:a3:f2:a0:
                    44:c7:18:29:34:da:91:a4:f6:5c:03:07:78:59:e3:
                    05:fe:58:6e:3d:e4:41:07:cc:28:7c:d8:90:6b:da:
                    6e:e7:22:1b:ba:d9:8f:13:3b:5a:8b:c2:0c:b9:50:
                    62:57
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Basic Constraints: 
                CA:FALSE
            X509v3 Subject Key Identifier: 
                DE:2B:C6:06:A9:41:45:AD:6A:0E:13:6D:EC:5A:ED:73:72:70:42:E2
            X509v3 Authority Key Identifier: 
                keyid:48:75:89:D3:5A:86:ED:A9:4B:E0:1F:D1:E8:24:9E:7D:5E:FB:84:2A
                DirName:/CN=pki.example.tld
                serial:7A:60:D9:26:19:E1:3E:2B:45:58:C7:DA:58:79:16:A6:5C:21:7B:28
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication
            X509v3 Key Usage: 
                Digital Signature, Key Encipherment
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        09:c8:c7:5f:b9:93:11:08:23:ca:11:20:12:b8:54:6f:35:2b:
        1f:e8:90:ba:dd:ba:d1:0d:51:a1:e4:33:76:fd:95:6a:9b:4c:
        0c:5f:91:9f:94:ee:4c:f5:79:e7:fb:0c:c8:b4:1f:bf:4a:d4:
        bb:b3:ee:b6:12:bc:9a:4a:63:c6:ff:87:2f:e9:dd:6c:8e:ee:
        76:13:cf:c6:29:ca:0f:a6:0d:8a:cd:13:bf:13:06:6e:b0:68:
        c2:ab:8d:3e:af:15:be:2e:c0:a3:4f:5b:50:0c:2f:06:8f:8f:
        42:ab:a0:1b:41:44:4f:29:98:4a:e0:05:52:57:9b:10:0e:b6:
        49:00:6b:46:ef:8c:1d:de:5e:d9:3e:e9:a0:21:b7:b2:2c:e9:
        61:ca:d6:90:e0:d9:ad:c9:7e:0c:8e:9b:c5:70:4f:81:6b:d0:
        6c:a8:6c:eb:f6:fb:06:1e:41:fb:ec:a2:f8:95:c5:8c:71:c9:
        e3:f9:6c:c5:b9:c0:12:1d:72:b9:43:81:16:d2:61:c3:e1:94:
        3b:a3:b2:60:45:da:be:b4:4c:80:3b:13:91:c0:2b:7c:73:15:
        8e:fc:3b:dd:c4:e8:20:fd:82:d9:3e:d8:83:e4:92:68:7c:2d:
        86:8d:a6:3f:9a:0a:4e:a6:77:17:6a:13:de:56:60:f3:7b:19:
        80:2f:69:17:fc:a7:3c:73:e7:3e:a0:6d:4b:cc:74:cb:67:50:
        f7:4d:dd:56:b1:9c:77:16:29:af:62:82:5e:24:ac:fa:af:04:
        9b:c3:6c:4c:bd:2b:93:eb:55:49:0a:31:1f:89:af:1e:30:06:
        14:84:48:ad:fb:20:23:17:37:18:b9:f4:05:26:2b:f6:7b:14:
        df:31:42:72:b4:2c:62:fa:85:b9:73:aa:c4:41:43:04:09:7d:
        b6:db:a9:b3:aa:fe:66:46:cf:cc:50:7b:80:9b:89:e1:58:aa:
        8b:87:1a:5b:0d:d9:ec:c6:00:00:ae:66:14:27:89:fb:f9:9b:
        2e:17:5b:7d:1d:44:bd:a9:08:3a:1a:c2:cd:64:50:8b:fb:7a:
        c2:a0:5f:3c:8f:c7:a8:9f:17:9b:fe:22:e7:27:ec:de:26:95:
        5f:99:cd:0b:7b:9e:92:51:84:c7:32:50:dc:bd:64:cd:8a:20:
        c7:ce:8a:ef:1c:29:cb:c2:b2:76:d8:cd:5a:ab:46:65:a3:3f:
        db:57:e7:ad:68:6e:3a:23:d2:6a:e9:65:3c:ef:81:2a:db:18:
        c7:86:d0:5d:51:cc:3b:db:bb:98:e6:61:9b:fc:f0:9e:62:5f:
        e6:7c:b0:3a:ff:08:a7:45:ab:22:e1:62:22:50:98:0d:d0:c3:
        28:1a:48:b6:2e:b8:d1:6d
-----BEGIN CERTIFICATE-----
MIIEZzCCAk+gAwIBAgIRAJZ/+Jky157qartBFPls5IIwDQYJKoZIhvcNAQELBQAw
GjEYMBYGA1UEAwwPcGtpLmV4YW1wbGUudGxkMB4XDTI1MDIwMzE0MDkwOVoXDTI3
MDUwOTE0MDkwOVowGzEZMBcGA1UEAwwQbXF0dC5leGFtcGxlLnRsZDCCASIwDQYJ
KoZIhvcNAQEBBQADggEPADCCAQoCggEBAKeBc0HOb2RS6mjElmuXljHhhg8wJjL3
CslHU3DsPtiW+ZktLo20swIFDkBjaURPjsYGb+Nls0uuFLM7vzYySF20B6+3EWsE
wgmLj2TRQu/R13AIjscjVc4//2ukvo0XbCTojwYvDH9D0YXo5VQtUdWoo1pV0k0r
BDMPVJOK1A5bG3DI26TZzUoXEhp3h2TbU7PCtydmhApI5bvYYPbFMsMfhhadCSBu
ey1P0ynA8DbVhIHqWbKnuIINV0kKCvcxuAJR5pQgN2J135PiEOyPo/KgRMcYKTTa
kaT2XAMHeFnjBf5Ybj3kQQfMKHzYkGvabuciG7rZjxM7WovCDLlQYlcCAwEAAaOB
pjCBozAJBgNVHRMEAjAAMB0GA1UdDgQWBBTeK8YGqUFFrWoOE23sWu1zcnBC4jBV
BgNVHSMETjBMgBRIdYnTWobtqUvgH9HoJJ59XvuEKqEepBwwGjEYMBYGA1UEAwwP
cGtpLmV4YW1wbGUudGxkghR6YNkmGeE+K0VYx9pYeRamXCF7KDATBgNVHSUEDDAK
BggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAAnIx1+5
kxEII8oRIBK4VG81Kx/okLrdutENUaHkM3b9lWqbTAxfkZ+U7kz1eef7DMi0H79K
1Luz7rYSvJpKY8b/hy/p3WyO7nYTz8Ypyg+mDYrNE78TBm6waMKrjT6vFb4uwKNP
W1AMLwaPj0KroBtBRE8pmErgBVJXmxAOtkkAa0bvjB3eXtk+6aAht7Is6WHK1pDg
2a3JfgyOm8VwT4Fr0GyobOv2+wYeQfvsoviVxYxxyeP5bMW5wBIdcrlDgRbSYcPh
lDujsmBF2r60TIA7E5HAK3xzFY78O93E6CD9gtk+2IPkkmh8LYaNpj+aCk6mdxdq
E95WYPN7GYAvaRf8pzxz5z6gbUvMdMtnUPdN3VaxnHcWKa9igl4krPqvBJvDbEy9
K5PrVUkKMR+Jrx4wBhSESK37ICMXNxi59AUmK/Z7FN8xQnK0LGL6hblzqsRBQwQJ
fbbbqbOq/mZGz8xQe4CbieFYqouHGlsN2ezGAACuZhQnifv5my4XW30dRL2pCDoa
ws1kUIv7esKgXzyPx6ifF5v+Iucn7N4mlV+ZzQt7npJRhMcyUNy9ZM2KIMfOiu8c
KcvCsnbYzVqrRmWjP9tX561objoj0mrpZTzvgSrbGMeG0F1RzDvbu5jmYZv88J5i
X+Z8sDr/CKdFqyLhYiJQmA3QwygaSLYuuNFt
-----END CERTIFICATE-----
</cert>

# When you recieve your key place it in the
# 'pki/private' sub-dir of your PKI and use command 'inline'
# to rebuild this inline file with your key.
# <key>
# * Paste your private key here *
# </key>

<ca>
-----BEGIN CERTIFICATE-----
MIIFWTCCA0GgAwIBAgIUemDZJhnhPitFWMfaWHkWplwheygwDQYJKoZIhvcNAQEL
BQAwGjEYMBYGA1UEAwwPcGtpLmV4YW1wbGUudGxkMCAXDTI1MDIwMzE0MDAwNFoY
DzMwMjQwNjA2MTQwMDA0WjAaMRgwFgYDVQQDDA9wa2kuZXhhbXBsZS50bGQwggIi
MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCrGiIsoJAA7dsliv8w4OnLT3Ue
JN8ukoa++6giI21KYmoswE7JJL7OWT19l62O5giFbw2AadkKw9+SORmmC342eruZ
eQKbUduoG1McrqrTRIbUfCZQlUYttF89gpcOal2UtG0vPOTwBRZkrq6H68wuUVM3
CkWSu/cImP4/9MbyGlJUGv8wvlVzBB+qeViE9Q49EIN5C3gr6LbgyfplBG5V0WK3
IxFE1pWg4Dj1/el3jjF6EDQGMBSngogO56cxgi6ZFzDr5v5csHDLKMtU9fEuHX70
RA5GwyLj6VvUKrMrgYC/MPRI5ggapTWH5QQ62g2CLhvCPwFzm5/lp6KLhQElkn7D
I4QGg1hNFHnuOJhotPcfHNqkAmvA9++x36eb+JmO2fNlUd7HcZrMLnnKAk+FaxAe
PaauBjiiBktm2fwYO4MHvpnzhB3KKvXqL1UiNiCXgFLuq9EpsxkTWj6mAM6iRpUi
ERtzk0XWS24g6gVDOr9LLQZE5yW4YC8cixymkL3921zn/DulIbO0bMYkdtcoTyyM
sL+tiDA0Cl/lglvcHrtCg2H0/o/a6emSmXpZ7s6m/JYZkRkcdCwwBLkfNSB8qkSJ
U+WbzpOAeegcwnPJlEwO8awqh8hMzkG/RK7PSRipJnqI3LYMv9dHuJJbVg53hPSO
N1xby0TzRfTIi1tT9wIDAQABo4GUMIGRMAwGA1UdEwQFMAMBAf8wHQYDVR0OBBYE
FEh1idNahu2pS+Af0egknn1e+4QqMFUGA1UdIwROMEyAFEh1idNahu2pS+Af0egk
nn1e+4QqoR6kHDAaMRgwFgYDVQQDDA9wa2kuZXhhbXBsZS50bGSCFHpg2SYZ4T4r
RVjH2lh5FqZcIXsoMAsGA1UdDwQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAdnOO
lbcXn+0QRRl5nVbBsMisGmvQGEudop5Ypu1v3frBDDsH2Q03lcGIuQGa4qa7Tb/T
xl7wdwj7CdCpAQpUYjVRyWTS1z2nDpCe8W5EG4oEDjMF5eNnvzU9IxLbY1s2vCcY
2VNi4P5rdZvCetz/DZIK6oP+ZGzkwhqnITs25LWw+exx80rXlc4NHpEFGvfeZj9i
cYWzR4SwyUHZHmHsxSZCTm7EUFUayE+Ao7jf6Qhi+qNOTqWt1OnH4Hev6fKH4fiq
EKrnPk3C2YtCqeiC1mLw/fwNZEFyEBo4vbpb+spBhNDpfT/+GZyvGZ7OD4EHttmh
s9fZLf6k23Mcb5ixOqq00x22Hn1INaRTW/GtZ3qcwZem1JUy/rmItGriEZ/+cGjk
1xEEgI9G5cS5qqbWB0Olm8zbE3KKFSAxpK+ZlsnmkoCoJMKfP6oYI/okTVRFEy0z
Ku4N8MGkvXh1ikQcIirJra/n9eTat1n9iceb34hgxV93Srxdmg4fpMdM8GxOkQab
26CSsecBQzWGFxOQt4zQAoXQQSDI2PFITN6jXBNUrYdKoTTQEBrkJ9T9KnBFWoIe
M9BFRNeLJAUZ71gdaYgEzKtYOcZhWG5tfdo+MPxLjdchC7A95xl6wGJFmchabtIG
3RLvEQa6PFIDC1xajQUZDMQdiwWDxxGVldotKos=
-----END CERTIFICATE-----
</ca>

# Easy-RSA TLS Key not found!

================
File: pki/easy-rsa/pki/issued/mqtt.example.tld.crt
================
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            96:7f:f8:99:32:d7:9e:ea:6a:bb:41:14:f9:6c:e4:82
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=pki.example.tld
        Validity
            Not Before: Feb  3 14:09:09 2025 GMT
            Not After : May  9 14:09:09 2027 GMT
        Subject: CN=mqtt.example.tld
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:a7:81:73:41:ce:6f:64:52:ea:68:c4:96:6b:97:
                    96:31:e1:86:0f:30:26:32:f7:0a:c9:47:53:70:ec:
                    3e:d8:96:f9:99:2d:2e:8d:b4:b3:02:05:0e:40:63:
                    69:44:4f:8e:c6:06:6f:e3:65:b3:4b:ae:14:b3:3b:
                    bf:36:32:48:5d:b4:07:af:b7:11:6b:04:c2:09:8b:
                    8f:64:d1:42:ef:d1:d7:70:08:8e:c7:23:55:ce:3f:
                    ff:6b:a4:be:8d:17:6c:24:e8:8f:06:2f:0c:7f:43:
                    d1:85:e8:e5:54:2d:51:d5:a8:a3:5a:55:d2:4d:2b:
                    04:33:0f:54:93:8a:d4:0e:5b:1b:70:c8:db:a4:d9:
                    cd:4a:17:12:1a:77:87:64:db:53:b3:c2:b7:27:66:
                    84:0a:48:e5:bb:d8:60:f6:c5:32:c3:1f:86:16:9d:
                    09:20:6e:7b:2d:4f:d3:29:c0:f0:36:d5:84:81:ea:
                    59:b2:a7:b8:82:0d:57:49:0a:0a:f7:31:b8:02:51:
                    e6:94:20:37:62:75:df:93:e2:10:ec:8f:a3:f2:a0:
                    44:c7:18:29:34:da:91:a4:f6:5c:03:07:78:59:e3:
                    05:fe:58:6e:3d:e4:41:07:cc:28:7c:d8:90:6b:da:
                    6e:e7:22:1b:ba:d9:8f:13:3b:5a:8b:c2:0c:b9:50:
                    62:57
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Basic Constraints: 
                CA:FALSE
            X509v3 Subject Key Identifier: 
                DE:2B:C6:06:A9:41:45:AD:6A:0E:13:6D:EC:5A:ED:73:72:70:42:E2
            X509v3 Authority Key Identifier: 
                keyid:48:75:89:D3:5A:86:ED:A9:4B:E0:1F:D1:E8:24:9E:7D:5E:FB:84:2A
                DirName:/CN=pki.example.tld
                serial:7A:60:D9:26:19:E1:3E:2B:45:58:C7:DA:58:79:16:A6:5C:21:7B:28
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication
            X509v3 Key Usage: 
                Digital Signature, Key Encipherment
    Signature Algorithm: sha256WithRSAEncryption
    Signature Value:
        09:c8:c7:5f:b9:93:11:08:23:ca:11:20:12:b8:54:6f:35:2b:
        1f:e8:90:ba:dd:ba:d1:0d:51:a1:e4:33:76:fd:95:6a:9b:4c:
        0c:5f:91:9f:94:ee:4c:f5:79:e7:fb:0c:c8:b4:1f:bf:4a:d4:
        bb:b3:ee:b6:12:bc:9a:4a:63:c6:ff:87:2f:e9:dd:6c:8e:ee:
        76:13:cf:c6:29:ca:0f:a6:0d:8a:cd:13:bf:13:06:6e:b0:68:
        c2:ab:8d:3e:af:15:be:2e:c0:a3:4f:5b:50:0c:2f:06:8f:8f:
        42:ab:a0:1b:41:44:4f:29:98:4a:e0:05:52:57:9b:10:0e:b6:
        49:00:6b:46:ef:8c:1d:de:5e:d9:3e:e9:a0:21:b7:b2:2c:e9:
        61:ca:d6:90:e0:d9:ad:c9:7e:0c:8e:9b:c5:70:4f:81:6b:d0:
        6c:a8:6c:eb:f6:fb:06:1e:41:fb:ec:a2:f8:95:c5:8c:71:c9:
        e3:f9:6c:c5:b9:c0:12:1d:72:b9:43:81:16:d2:61:c3:e1:94:
        3b:a3:b2:60:45:da:be:b4:4c:80:3b:13:91:c0:2b:7c:73:15:
        8e:fc:3b:dd:c4:e8:20:fd:82:d9:3e:d8:83:e4:92:68:7c:2d:
        86:8d:a6:3f:9a:0a:4e:a6:77:17:6a:13:de:56:60:f3:7b:19:
        80:2f:69:17:fc:a7:3c:73:e7:3e:a0:6d:4b:cc:74:cb:67:50:
        f7:4d:dd:56:b1:9c:77:16:29:af:62:82:5e:24:ac:fa:af:04:
        9b:c3:6c:4c:bd:2b:93:eb:55:49:0a:31:1f:89:af:1e:30:06:
        14:84:48:ad:fb:20:23:17:37:18:b9:f4:05:26:2b:f6:7b:14:
        df:31:42:72:b4:2c:62:fa:85:b9:73:aa:c4:41:43:04:09:7d:
        b6:db:a9:b3:aa:fe:66:46:cf:cc:50:7b:80:9b:89:e1:58:aa:
        8b:87:1a:5b:0d:d9:ec:c6:00:00:ae:66:14:27:89:fb:f9:9b:
        2e:17:5b:7d:1d:44:bd:a9:08:3a:1a:c2:cd:64:50:8b:fb:7a:
        c2:a0:5f:3c:8f:c7:a8:9f:17:9b:fe:22:e7:27:ec:de:26:95:
        5f:99:cd:0b:7b:9e:92:51:84:c7:32:50:dc:bd:64:cd:8a:20:
        c7:ce:8a:ef:1c:29:cb:c2:b2:76:d8:cd:5a:ab:46:65:a3:3f:
        db:57:e7:ad:68:6e:3a:23:d2:6a:e9:65:3c:ef:81:2a:db:18:
        c7:86:d0:5d:51:cc:3b:db:bb:98:e6:61:9b:fc:f0:9e:62:5f:
        e6:7c:b0:3a:ff:08:a7:45:ab:22:e1:62:22:50:98:0d:d0:c3:
        28:1a:48:b6:2e:b8:d1:6d
-----BEGIN CERTIFICATE-----
MIIEZzCCAk+gAwIBAgIRAJZ/+Jky157qartBFPls5IIwDQYJKoZIhvcNAQELBQAw
GjEYMBYGA1UEAwwPcGtpLmV4YW1wbGUudGxkMB4XDTI1MDIwMzE0MDkwOVoXDTI3
MDUwOTE0MDkwOVowGzEZMBcGA1UEAwwQbXF0dC5leGFtcGxlLnRsZDCCASIwDQYJ
KoZIhvcNAQEBBQADggEPADCCAQoCggEBAKeBc0HOb2RS6mjElmuXljHhhg8wJjL3
CslHU3DsPtiW+ZktLo20swIFDkBjaURPjsYGb+Nls0uuFLM7vzYySF20B6+3EWsE
wgmLj2TRQu/R13AIjscjVc4//2ukvo0XbCTojwYvDH9D0YXo5VQtUdWoo1pV0k0r
BDMPVJOK1A5bG3DI26TZzUoXEhp3h2TbU7PCtydmhApI5bvYYPbFMsMfhhadCSBu
ey1P0ynA8DbVhIHqWbKnuIINV0kKCvcxuAJR5pQgN2J135PiEOyPo/KgRMcYKTTa
kaT2XAMHeFnjBf5Ybj3kQQfMKHzYkGvabuciG7rZjxM7WovCDLlQYlcCAwEAAaOB
pjCBozAJBgNVHRMEAjAAMB0GA1UdDgQWBBTeK8YGqUFFrWoOE23sWu1zcnBC4jBV
BgNVHSMETjBMgBRIdYnTWobtqUvgH9HoJJ59XvuEKqEepBwwGjEYMBYGA1UEAwwP
cGtpLmV4YW1wbGUudGxkghR6YNkmGeE+K0VYx9pYeRamXCF7KDATBgNVHSUEDDAK
BggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAAnIx1+5
kxEII8oRIBK4VG81Kx/okLrdutENUaHkM3b9lWqbTAxfkZ+U7kz1eef7DMi0H79K
1Luz7rYSvJpKY8b/hy/p3WyO7nYTz8Ypyg+mDYrNE78TBm6waMKrjT6vFb4uwKNP
W1AMLwaPj0KroBtBRE8pmErgBVJXmxAOtkkAa0bvjB3eXtk+6aAht7Is6WHK1pDg
2a3JfgyOm8VwT4Fr0GyobOv2+wYeQfvsoviVxYxxyeP5bMW5wBIdcrlDgRbSYcPh
lDujsmBF2r60TIA7E5HAK3xzFY78O93E6CD9gtk+2IPkkmh8LYaNpj+aCk6mdxdq
E95WYPN7GYAvaRf8pzxz5z6gbUvMdMtnUPdN3VaxnHcWKa9igl4krPqvBJvDbEy9
K5PrVUkKMR+Jrx4wBhSESK37ICMXNxi59AUmK/Z7FN8xQnK0LGL6hblzqsRBQwQJ
fbbbqbOq/mZGz8xQe4CbieFYqouHGlsN2ezGAACuZhQnifv5my4XW30dRL2pCDoa
ws1kUIv7esKgXzyPx6ifF5v+Iucn7N4mlV+ZzQt7npJRhMcyUNy9ZM2KIMfOiu8c
KcvCsnbYzVqrRmWjP9tX561objoj0mrpZTzvgSrbGMeG0F1RzDvbu5jmYZv88J5i
X+Z8sDr/CKdFqyLhYiJQmA3QwygaSLYuuNFt
-----END CERTIFICATE-----

================
File: pki/easy-rsa/pki/reqs/mqtt.example.tld.req
================
-----BEGIN CERTIFICATE REQUEST-----
MIICYDCCAUgCAQAwGzEZMBcGA1UEAwwQbXF0dC5leGFtcGxlLnRsZDCCASIwDQYJ
KoZIhvcNAQEBBQADggEPADCCAQoCggEBAKeBc0HOb2RS6mjElmuXljHhhg8wJjL3
CslHU3DsPtiW+ZktLo20swIFDkBjaURPjsYGb+Nls0uuFLM7vzYySF20B6+3EWsE
wgmLj2TRQu/R13AIjscjVc4//2ukvo0XbCTojwYvDH9D0YXo5VQtUdWoo1pV0k0r
BDMPVJOK1A5bG3DI26TZzUoXEhp3h2TbU7PCtydmhApI5bvYYPbFMsMfhhadCSBu
ey1P0ynA8DbVhIHqWbKnuIINV0kKCvcxuAJR5pQgN2J135PiEOyPo/KgRMcYKTTa
kaT2XAMHeFnjBf5Ybj3kQQfMKHzYkGvabuciG7rZjxM7WovCDLlQYlcCAwEAAaAA
MA0GCSqGSIb3DQEBCwUAA4IBAQAkVW00PaXwFyA5O0+TEM1ZwNrD4df9wMieOqEU
mEqrP/l76ZloZ/3KIfLZCHR4t7+DdSv8oTxR8dF1tCSYHJSONQe4hQ13SW0rBSe5
veUCPy2YrWPNE99Mi9I+RjV9hJFumE3S5b7znq9wV+pocDfmMMWjy+C+9bVU4ZGt
QP3cKnRj8oGM/Z5LEjhECYgb+oY5qBIFkz9vsOo2MloJzdSh8NLmKkxfzCUiBeND
cmW/au8SxiNBzrffWwHGipMZL40J4lg0tK/vpEtfDn25/bH44EhHtYxv7WG4OOq+
bB9rEKYbms+MWscHN8trz6p9QfDTqIJklkFpNM0vDQJmUMLu
-----END CERTIFICATE REQUEST-----

================
File: pki/easy-rsa/pki/ca.crt
================
-----BEGIN CERTIFICATE-----
MIIFWTCCA0GgAwIBAgIUemDZJhnhPitFWMfaWHkWplwheygwDQYJKoZIhvcNAQEL
BQAwGjEYMBYGA1UEAwwPcGtpLmV4YW1wbGUudGxkMCAXDTI1MDIwMzE0MDAwNFoY
DzMwMjQwNjA2MTQwMDA0WjAaMRgwFgYDVQQDDA9wa2kuZXhhbXBsZS50bGQwggIi
MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCrGiIsoJAA7dsliv8w4OnLT3Ue
JN8ukoa++6giI21KYmoswE7JJL7OWT19l62O5giFbw2AadkKw9+SORmmC342eruZ
eQKbUduoG1McrqrTRIbUfCZQlUYttF89gpcOal2UtG0vPOTwBRZkrq6H68wuUVM3
CkWSu/cImP4/9MbyGlJUGv8wvlVzBB+qeViE9Q49EIN5C3gr6LbgyfplBG5V0WK3
IxFE1pWg4Dj1/el3jjF6EDQGMBSngogO56cxgi6ZFzDr5v5csHDLKMtU9fEuHX70
RA5GwyLj6VvUKrMrgYC/MPRI5ggapTWH5QQ62g2CLhvCPwFzm5/lp6KLhQElkn7D
I4QGg1hNFHnuOJhotPcfHNqkAmvA9++x36eb+JmO2fNlUd7HcZrMLnnKAk+FaxAe
PaauBjiiBktm2fwYO4MHvpnzhB3KKvXqL1UiNiCXgFLuq9EpsxkTWj6mAM6iRpUi
ERtzk0XWS24g6gVDOr9LLQZE5yW4YC8cixymkL3921zn/DulIbO0bMYkdtcoTyyM
sL+tiDA0Cl/lglvcHrtCg2H0/o/a6emSmXpZ7s6m/JYZkRkcdCwwBLkfNSB8qkSJ
U+WbzpOAeegcwnPJlEwO8awqh8hMzkG/RK7PSRipJnqI3LYMv9dHuJJbVg53hPSO
N1xby0TzRfTIi1tT9wIDAQABo4GUMIGRMAwGA1UdEwQFMAMBAf8wHQYDVR0OBBYE
FEh1idNahu2pS+Af0egknn1e+4QqMFUGA1UdIwROMEyAFEh1idNahu2pS+Af0egk
nn1e+4QqoR6kHDAaMRgwFgYDVQQDDA9wa2kuZXhhbXBsZS50bGSCFHpg2SYZ4T4r
RVjH2lh5FqZcIXsoMAsGA1UdDwQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAdnOO
lbcXn+0QRRl5nVbBsMisGmvQGEudop5Ypu1v3frBDDsH2Q03lcGIuQGa4qa7Tb/T
xl7wdwj7CdCpAQpUYjVRyWTS1z2nDpCe8W5EG4oEDjMF5eNnvzU9IxLbY1s2vCcY
2VNi4P5rdZvCetz/DZIK6oP+ZGzkwhqnITs25LWw+exx80rXlc4NHpEFGvfeZj9i
cYWzR4SwyUHZHmHsxSZCTm7EUFUayE+Ao7jf6Qhi+qNOTqWt1OnH4Hev6fKH4fiq
EKrnPk3C2YtCqeiC1mLw/fwNZEFyEBo4vbpb+spBhNDpfT/+GZyvGZ7OD4EHttmh
s9fZLf6k23Mcb5ixOqq00x22Hn1INaRTW/GtZ3qcwZem1JUy/rmItGriEZ/+cGjk
1xEEgI9G5cS5qqbWB0Olm8zbE3KKFSAxpK+ZlsnmkoCoJMKfP6oYI/okTVRFEy0z
Ku4N8MGkvXh1ikQcIirJra/n9eTat1n9iceb34hgxV93Srxdmg4fpMdM8GxOkQab
26CSsecBQzWGFxOQt4zQAoXQQSDI2PFITN6jXBNUrYdKoTTQEBrkJ9T9KnBFWoIe
M9BFRNeLJAUZ71gdaYgEzKtYOcZhWG5tfdo+MPxLjdchC7A95xl6wGJFmchabtIG
3RLvEQa6PFIDC1xajQUZDMQdiwWDxxGVldotKos=
-----END CERTIFICATE-----

================
File: pki/easy-rsa/pki/crl.pem
================
-----BEGIN X509 CRL-----
MIICvjCBpwIBATANBgkqhkiG9w0BAQsFADAaMRgwFgYDVQQDDA9wa2kuZXhhbXBs
ZS50bGQXDTI1MDIwMzE0MTMzNFoXDTI1MDgwMjE0MTMzNFqgWTBXMFUGA1UdIwRO
MEyAFEh1idNahu2pS+Af0egknn1e+4QqoR6kHDAaMRgwFgYDVQQDDA9wa2kuZXhh
bXBsZS50bGSCFHpg2SYZ4T4rRVjH2lh5FqZcIXsoMA0GCSqGSIb3DQEBCwUAA4IC
AQAyBnda9OlFgGkKC1tQili7p9p9+ckLPafRFClOgIdtAna4PHkvkdQsKT5cxhuq
lTsfakYTcWH3sY2d3ktBXqOGap1v41LwIWe6Pg32P0Km9pG4oWk0iaYUPJGkMXke
0YOHoxqd7hAOCdG+nof0y7qq0wQbIvns+h4loutRKqf81GMTH7Ez/vJejUQRY5IH
zgg6IEPFu3JrErTgi9VH3LQf8srNHBIJqADNmWd4pvNeyvvwO5N5KYE3MZspKF7f
2nu3VrdOjcgZkvfvEDuR9wMFuMJMC0j/CaOtAgMNk57qsXPxAwxyH1vcI9eM2c7z
bzH3QSkIAHLFtHx7lkVsORYT3WbOyOi8QEOGPr/lf/EyxvpMB+McA0X5eGwEmRPV
cxa7GPb7WYLCWbTHT4rfaz27F2IAa2tfApumvPj76yBQrkAHxAcPFD2bcuBEdB1B
/fCockEe5JIg7NCOGCVcQEqg3xIPwq48NKmzS9DthOw2laPRM6SpOjkgju73k/zd
0u/vckFY8CX0hXx+6S/Qo2CemL3IGxqUNyzs2sqSEqp9Qy6fXO0eNMvyiIkR/6x/
YQYeuf3JKLPA51TDif6JrdCbB0/s4Z0TUppobcVHEFDGGsw2uSR3Nd1JfqmiRds9
WOSJXt9R7hbtWbwMrJ5BJHISutxUo5JCzD4iGCnEIvKabA==
-----END X509 CRL-----

================
File: pki/easy-rsa/pki/index.txt
================
V	270509140909Z		967FF89932D79EEA6ABB4114F96CE482	unknown	/CN=mqtt.example.tld

================
File: pki/easy-rsa/pki/index.txt.attr
================
unique_subject = no

================
File: pki/easy-rsa/pki/serial
================
967FF89932D79EEA6ABB4114F96CE483

================
File: pki/easy-rsa/pki/serial.old
================
967ff89932d79eea6abb4114f96ce482

================
File: pki/easy-rsa/pki/vars.example
================
# Easy-RSA 3 parameter settings

# NOTE: If you installed Easy-RSA from your package manager, do not edit
# this file in place -- instead, you should copy the entire easy-rsa directory
# to another location so future upgrades do not wipe out your changes.

# HOW TO USE THIS FILE
#
# vars.example contains built-in examples to Easy-RSA settings. You MUST name
# this file "vars" if you want it to be used as a configuration file. If you
# do not, it WILL NOT be automatically read when you call easyrsa commands.
#
# It is not necessary to use this config file unless you wish to change
# operational defaults. These defaults should be fine for many uses without
# the need to copy and edit the "vars" file.
#
# All of the editable settings are shown commented and start with the command
# "set_var" -- this means any set_var command that is uncommented has been
# modified by the user. If you are happy with a default, there is no need to
# define the value to its default.

# NOTES FOR WINDOWS USERS
#
# Paths for Windows  *MUST* use forward slashes, or optionally double-escaped
# backslashes (single forward slashes are recommended.) This means your path
# to the openssl binary might look like this:
# "C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# A little housekeeping: DO NOT EDIT THIS SECTION
#
# Easy-RSA 3.x does not source into the environment directly.
# Complain if a user tries to do this:
if [ -z "$EASYRSA_CALLER" ]; then
	echo "You appear to be sourcing an Easy-RSA *vars* file. This is" >&2
	echo "no longer necessary and is disallowed. See the section called" >&2
	echo "*How to use this file* near the top comments for more details." >&2
	return 1
fi

# DO YOUR EDITS BELOW THIS POINT

# If your OpenSSL command is not in the system PATH, you will need to define
# the path here. Normally this means a full path to the executable, otherwise
# you could have left it undefined here and the shown default would be used.
#
# Windows users, remember to use paths with forward-slashes (or escaped
# back-slashes.) Windows users should declare the full path to the openssl
# binary here if it is not in their system PATH.
#
#set_var EASYRSA_OPENSSL	"openssl"
#
# This sample is in Windows syntax -- edit it for your path if not using PATH:
#set_var EASYRSA_OPENSSL	"C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# Windows users, to generate OpenVPN TLS Keys the Openvpn binary must be
# defined here.
#
#set_var EASYRSA_OPENVPN "C:\\Program Files\\Openvpn\\bin\\openvpn.exe"

# Define X509 DN mode.
#
# This is used to adjust which elements are included in the Subject field
# as the DN ("Distinguished Name"). Note that in 'cn_only' mode the
# Organizational fields, listed further below, are not used.
#
# Choices are:
#   cn_only  - Use just a commonName value.
#   org      - Use the "traditional" format:
#              Country/Province/City/Org/Org.Unit/email/commonName
#
#set_var EASYRSA_DN	"cn_only"

# Organizational fields (used with "org" mode and ignored in "cn_only" mode).
# These are the default values for fields which will be placed in the
# certificate.  Do not leave any of these fields blank, although interactively
# you may omit any specific field by typing the "." symbol (not valid for
# email).
#
# NOTE: The following characters are not supported
#       in these "Organizational fields" by Easy-RSA:
#       back-tick (`)
#
#set_var EASYRSA_REQ_COUNTRY	"US"
#set_var EASYRSA_REQ_PROVINCE	"California"
#set_var EASYRSA_REQ_CITY	"San Francisco"
#set_var EASYRSA_REQ_ORG	"Copyleft Certificate Co"
#set_var EASYRSA_REQ_EMAIL	"me@example.net"
#set_var EASYRSA_REQ_OU		"My Organizational Unit"

# Preserve the Distinguished Name field order
# of the certificate signing request
# *Only* effective in --dn-mode=org
#
#set_var EASYRSA_PRESERVE_DN	1

# Set no password mode - This will create the entire PKI without passwords.
# This can be better managed by choosing which entity private keys should be
# encrypted with the following command line options:
# Global option '--no-pass' or command option 'nopass'.
#
#set_var EASYRSA_NO_PASS	1

# Choose a size in bits for your keypairs. The recommended value is 2048.
# Using 2048-bit keys is considered more than sufficient for many years into
# the future. Larger keysizes will slow down TLS negotiation and make key/DH
# param generation take much longer. Values up to 4096 should be accepted by
# most software. Only used when the crypto alg is rsa, see below.
#
#set_var EASYRSA_KEY_SIZE	2048

# The default crypto mode is rsa; ec can enable elliptic curve support.
# Note that not all software supports ECC, so use care when enabling it.
# Choices for crypto alg are: (each in lower-case)
#  * rsa
#  * ec
#  * ed
#
#set_var EASYRSA_ALGO		rsa

# Define the named curve, used in ec & ed modes:
#
#set_var EASYRSA_CURVE		secp384r1

# In how many days should the root CA key expire?
#
#set_var EASYRSA_CA_EXPIRE	3650

# In how many days should certificates expire?
#
#set_var EASYRSA_CERT_EXPIRE	825

# How many days until the Certificate Revokation List will expire.
#
# IMPORTANT: When the CRL expires, an OpenVPN Server which uses a
# CRL will reject ALL new connections, until the CRL is replaced.
#
#set_var EASYRSA_CRL_DAYS	180

# Random serial numbers by default.
# Set to 'no' for the old incremental serial numbers.
#
#set_var EASYRSA_RAND_SN	"yes"

# Cut-off window for checking expiring certificates.
#
#set_var EASYRSA_PRE_EXPIRY_WINDOW	90

# Generate automatic subjectAltName for certificates
#
#set_var	EASYRSA_AUTO_SAN	1

# Add critical attribute to X509 fields: basicConstraints (BC),
# keyUsage (KU), extendedKeyUsage (EKU) or SAN
#
#set_var	EASYRSA_BC_CRIT		1
#set_var	EASYRSA_KU_CRIT		1
#set_var	EASYRSA_EKU_CRIT	1
#set_var	EASYRSA_SAN_CRIT	1

# Disable automatic inline files
#
#set_var	EASYRSA_DISABLE_INLINE	1

================
File: pki/easy-rsa/release-keys/README.md
================
Easy-RSA 3 release GPG keys
===

This document contains the GPG Key IDs used to sign official releases starting
with the 3.x series. These release-keys are available on public keyserver
mirrors, such as pgp.mit.edu.

Current keys
---

These keys are currently valid:

* Key ID [0x9D7367F3](https://keys.openpgp.org/vks/v1/by-fingerprint/6F4056821152F03B6B24F2FCF8489F839D7367F3)
  * Owner: Eric Crist <ecrist@secure-computing.net>
  * Key fingerprint: 6F40 5682 1152 F03B 6B24  F2FC F848 9F83 9D73 67F3

Former keys
---

These keys were once valid but are now expired or revoked:

* Key ID 0x606FD463
  * Owner: Josh Cepek <josh.cepek@usa.net>
  * Key fingerprint: 65FF 3F24 AA08 E882 CB44  4C94 D731 D97A 606F D463
  * Member is no longer active with EasyRSA.

Verifying Signatures
===
You can verify the signatures provided by downloading the public key for the current key (above) and adding it to your keychain. Then you can verify with the following command:
```
ecrist@marvin:~/Downloads-> gpg --verify EasyRSA-3.0.8.tgz.sig EasyRSA-3.0.8.tgz
gpg: Signature made Wed Sep  9 16:00:35 2020 CDT
gpg:                using RSA key C8FCA3E7F787072CDEB91D2F72964219390D0D0E
gpg: Good signature from "Eric F Crist <ecrist@secure-computing.net>"
```

================
File: pki/easy-rsa/.gitignore
================
easyrsa3/pki
easyrsa3/vars
easyrsa3/safessl-easyrsa.cnf
easyrsa3/unit?tests
easyrsa-unit-tests.sh
easyrsa-unit-tests-help.sh
dist-staging
.DS_Store
test-deps/*
shellcheck

================
File: pki/easy-rsa/ChangeLog
================
Easy-RSA 3 ChangeLog

3.3.0 (TBD)

   * Update OpenSSL to 3.4.0 (d020b66)

3.2.2 (2025-02-01)

   * Fold easyrsa-tools.lib into easyrsa (56cfa0c) (#1288)
   * Revert da3c249: Do not remove index.txt.attr (a236b97) (#1287)
   * Windows: Remove mktemp binary and text files (135f642) (#1285)
   * op-test.sh: Disable download ossl3 and shellcheck binaries (473c43b) (#1284)
   * Forbid self-signed certificate from being expired/renewed/revoked (ab45ae7) (#1274)
   * Rename global option --ssl-conf (DEPRECATED) to --ssl-cnf (c788423) (#1270)
   * bugfix: Save and Restore $EASYRSA_SSL_CONF for compound commands (7cdb14d) (#1270)
   * bugfix: Always use locate_support_files() after secure_session() (d530bc3) (#1270)
   * bugfix: easyrsa-tools.lib: renew, write full metadata to temp-file (b47d2af) (#1267)
   * Introduce new command 'revoke-issued' (38bf2d8) (#1266)
     Commands 'revoke' and 'revoke-issued' are identical.
     Command 'revoke' can ONLY be used in batch mode.
   * vars.example: Remove $EASYRSA_PKI (8ee8dcf) (#1262)
     There is no effect on existing 'vars' files.
   * easyrsa-tools.lib: Move to 'easyrsa3' directory (d30b688) (#1259)
     This now includes 'easyrsa-tools.lib' in the distribution tarballs.
   * Upgrade easyrsa-tools.lib to version 322 - As of command 'renew-ca'
   * easyrsa-tools.lib: Introduce new command 'renew-ca' (ba32b0d) (#1255)
   * easyrsa-tools.lib: show-expire, allow --days to be zero (a1033a5) (#1254)
   * Command 'help': Ignore EASYRSA_SILENT (8804d6b) (#1249)
   * bugfix: easyrsa-tools.lib: renew SAN, remove excess word 'Address' (af17492) (#1251)
   * New global variable 'EASYRSA_DISABLE_INLINE' (ad257ab) (#1245)
   * bugfix: revoke, renew: Remove pki/inline/private/$file.inline (febef85) (#1244)
     Initial bug report #1242 (Minor)
     Stop removing old credentials file pki/$file.creds (a871e9c)
   * Add LibreSSL version 4 to supported SSL Libraries (7df616b) (#1240)
   * sign-req: Allow custom X509 Types (2ee08cc) (#1238)
   * Remove redundant file index.txt.attr (da3c249) (#1233)

3.2.1 (2024-09-13)

   * inline: Add decimal value for cert. serial (Linux Only) (b33038e) (#1222)
   * Always exit with error for unknown command options (Except nopass) (#1221)
     (build-ca: b2f7912); (gen-req: 07f21d3); (build_full(): 0ff7f4c);
     (export_pkcs(): 2c51288); (set-pass: 1266d4e)
   * Integrate Easy-RSA TLS-Key for use with 'init-pki soft' (03d9dc2) (#1220)
     Note: Inline files that contain private key data are now created in sub-dir
     'pki/inline/private'.
   * easyrsa-tools.lib, show-expire: Add CA certificate to report (a36cd54) (#1215)
   * inline: OpenVPN TLS Keys inlining for TLS-AUTH, TLS-CRYPT-V1 (6e9e4a2) (#1185)
     Note: Command inline only writes directly to inline file not stdout.
   * easyrsa-tools.lib: OpenVPN TLS Key gen. TLS-AUTH, TLS-CRYPT-V1 (cf0da16) (#1185)
   * easyrsa-tools.lib: expire_status_v2() (show-expire version 2) (1e43bf5) (#1214)
   * sign-req: Require 128bit serial number (806ee19) (#1213)
   * Move command 'verify-cert' to Tools-lib; drop 'verify' shortcut (ddbf304) (#1209)
   * Windows secure_session(): Ensure $secured_session dir is created (d99b242) (#1203)
   * Switch to '-f' for file existence (6ab98c9..a02f545) (#1201)
   * inline: Move auto-inline from build_full() to sign_req() (823f70f) (#1201)
   * gen-crl: Create additional CRL in DER format (69df0d8) (#1198)
   * self-sign: Allow Edwards Curve based keys (81b749b) (#1197)
   * Re-enable command 'renew' (version 2): Requires EasyRSA Tools (30fe311) (#1195)
   * bug-fix: revoke: Pass the correct certificate location (24d5514)
   * vars.example: Add flags for auto-SAN and X509 critical attribute (a41dfcc)
   * Global option --eku-crit: Mark X509 extendedKeyUsage as critical (ca09211)
   * sign-req: Add critical and pathlen details to confirmation (deae705) (#1182)
   * export-p12: Automatically generate inline file (9d90370) (#1181)
   * Introduce global option --auto-san, use commonName as SAN (5c36d44) (#1180)
   * Introduce global option --san-crit, mark SAN critical (dd69f50) (#1179)
   * Introduce new global options: --ku-crit and --bc-crit (b79abee) (#1176)
   * gen-req: Always check for existing request file (7eab98e) (#1177)
   * revoke/revoke-expired/-renewed: Keep duplicate certificate (3da7f66) (#1177)
   * revoke-expired/-renewed: Keep req/key files for resigning (4537ae7) (#1177)
   * revoke: Add abbreviations for optional 'reason' (a88ccc7) (#1173)
   * build-ca: Allow use of --req-cn without batch mode (b77a0fb) (#1170)
   * gen-req: Re-enable use of --req-cn (5cf8c46) (#1170)
   * write: Change syntax, target as file, not directory (722ce54) (#1165)

3.2.0 (2024-05-18)

   * Revert ca76697: Restore escape_hazard() (b1e9d7a) (#1137)
   * New X509 Type: 'selfsign' Internal only (999533e) (#1135)
   * New commands: self-sign-server and self-sign-client (9f8a1d1) (#1127)
   * build-ca: Command 'req', remove SSL option '-keyout' (4e02c8a) (#1123)
   * Remove escape_hazard(), obsolete (ca76697)
   * Remove command and function display_cn(), unused (be8f400) (#1114)
   * Introduce Options to edit Request Subject during command 'sign-req'
     Global Option: --new-subject -- Command 'sign-req' option: 'newsubj'
     First proposed in: (#439) -- Completed: (83b81c7) (#1111)
   * docs: Update EasyRSA-Renew-and-Revoke.md (f6c2bf5) (#1109)
   * Remove all 'renew' code; replaced by 'expire' code (9d94207) (#1109)
   * Introduce commands: 'expire' and 'revoke-expired' (a1890fa) (#1109)
   * Keep request files [CSR] when revoking certificates (6d6e8d8) (#1109)
   * Restrict use of --req-cn to build-ca (0a46164) (#1098)
   * Remove command 'display-san' (Code removed in 5a06f94) (50e6002) (#1096)
   * help: Add 'copyext'; How to use --copy-ext and --san (5a06f94) (#1096)
   * Allow --san to be used multiple times (5a06f94) (#1096)
   * Remove default server subject alternative name (0b85a5d) (#576)
   * Move Status Reports to 'easyrsa-tools.lib' (214b909) (#1080)
   * export-p12, OpenSSL v1.x: Upgrade PBE and MAC options (60a508a)
     (#1084 - Based on #1081)
   * Windows: Introduce 'Non-Admin' mode (c2823c4) (#1073)
   * LibreSSL: Add fix for missing 'x509' option '-ext' (96dd959) (#1068)
   * Variable heredoc expansion for SSL/Safe Config file (9c5d423) (#1064)

   Branch-merge: v3.2.0-beta2 (#1055) 2024/01/13 Commit: d51d79b

   * Always use here-doc version of openssl-easyrsa.cnf (2a8c0de)
     Only use here-doc if the current version is recognised by sha256 hash.
     The current file is NEVER deleted (60216d5). Partially revert: 2a8c0de
   * export-p12: New command option 'legacy'. OpenSSL V3 Only (f8514de)
     Fallback to encryption algorithm RC2_CBC or 3DES_CBC
   * export-p12: Always set 'friendlyName' to file-name-base (da9e594)
   * Update OpenSSL to 3.2.0 (03e4829)

   Branch-merge: v3.2.0-beta1 (#1046) 2023/12/15 Commit: 7120876

   * Important note: As of Easy-RSA version 3.2.0-beta1, the configuration files
     `vars.example`, `openssl-easyrsa.cnf` and all files in `x509-types` directory
     are no longer required. Package maintainers can omit these files in the future.
     All files are created as required and deleted upon command completion.
     `vars.example` is created during `init-pki` and placed in the fresh PKI.
     These files will be retained for downstream packaging compatibility.

   * Rename X509-type file `code-signing` to `codeSigning` (1c6b31a)
     The original file will be retained as `code-signing`, however, the automatic
     X509-types creation will name the file `codeSigning`. This effectively means
     that both are valid X509-types, until `code-signing` is dropped.
   * init-pki: Always write vars.example file to fresh PKI (66a8f3e)
   * New command 'write': Write 'legacy' files to stdout or files (c814e0a)
   * Remove command 'make-safe-ssl': Replaced by command 'write safe-cnf' (c814e0a)
   * New Command 'rand': Expose easyrsa_random() to the command line (6131cbf)
   * Remove function 'set_pass_legacy()' (7470c2a)
   * Remove command 'rewind-renew' (72b4079)
   * Remove command 'rebuild' (d6953cc)
   * Remove command 'upgrade' (6a88edd)

   Branch-merge: v3.2.0-alpha2 (#1043) 2023/12/7 Commit: ed0dc46
   * Remove EASYRSA_NO_VARS; Allow graceful use without a vars file (3c0ca17)

   Branch-merge: v3.2.0-alpha1 (#1041) 2023/12/2 Commit: 42c2e95
   * New diagnostic command 'display-cn' (#1040)
   * Expand renewable certificate types to include code-signing (#1039)

3.1.7 (2023-10-13)
   * Rewrite vars-auto-detect, adhere to EasyRSA-Advanced.md (#1029)
     Under the hood, this is a considerable change but there are no user
     noticeable differences. With the exception of:
     Caveat: The default '$PWD/pki/vars' file is forbidden to change either
             EASYRSA or EASYRSA_PKI, which are both implied by default.
   * EasyRSA-Advanced.md: Correct vars-auto-detect hierarchy (#1029)
     Commit: ecd65065e3303da78811278a154ef7a969c2777b
             EASYRSA/vars is moved to a higher priority than a default PKI.
             vars-auto-detect no longer searches 'easyrsa' program directory.
   * gen-crl: preserve existing crl.pem ownership+mode (#1020)
   * New command: make-vars - Print vars.example (here-doc) to stdout (#1024)
   * show-expire: Calculate cert. expire seconds from DB date (#1023)
   * Update OpenSSL to 3.1.2

3.1.6 (2023-07-18)
   * New commands: 'inline' and 'x509-eku' (#993)
     inline: Build an inline file for a commonName
     x509-eku: Extract X509v3 extended key usage from a certificate
   * Expose serial-check, display-dn, display-san and default-san to
     command line. (#980) (Debugging functions, which remain undocumented)
   * Expand default status to include vars-file and CA status (#973)
   * sign-req: Allow the CSR DN-field order to be preserved (#970)

3.1.5 (2023-06-10)
   * Build Update: script now supports signing and verifying
   * Automate support-file creation (Free packaging) (#964)
   * build-ca: New command option 'raw-ca', abbreviation: 'raw' (#963)

     This 'raw' method, is the most reliable way to build a CA,
     with a password, without writing the CA password to a temp-file.

   This option completely replaces both methods below:

   * build-ca: New option --ca-via-stdin, use SSL -pass* argument 'stdin' (#959)
     Option '--ca-via-stdin' offers no more security than standard method.
     Easy-RSA version 3.1.4 ONLY.

   * build-ca: Replace password temp-files with file-descriptors (#955)
     Using file-descriptors does not work in Windows.
     Easy-RSA version 3.1.3 ONLY.

3.1.4 (2023-05-23)
   * build-ca: New option --ca-via-stdin, use SSL -pass* argument 'stdin' (#959)
   * build-ca: Revert manual CA password method to temp-files (#959)
     Supersedes #955

     Release v3.1.3 was fatally flawed, it would fail to build a CA under Windows.
     Release v3.1.4 is specifically a bugfix ONLY, to resolve the Windows problem.

     See the following commits for further details:
     5d7ad1306d5ebf1588aef77eb3445e70cf5b4ebc
         build-ca: Revert manual CA password method to temp-files
     c11135d19b2e7e7385d28abb1132978c849dfa74
         build-ca: Use OpenSSL password I/O argument 'stdin'
     27870d695a324e278854146afdac5d6bdade9bba
         build-ca: Replace password temp-file method with file-descriptors
         Superseded by 5d7ad13 above.

3.1.3 (2023-05-19)
   * build-ca: Replace password temp-files with file-descriptors (#955)
     Superseded by #959
   * Replace --fix-offset with --startdate, --enddate (#918)
   * Introduce option -S|--silent-ssl: Silence SSL output (#913)
   * Only create a random serial number file when expected (#896)
   * Always verify SSL lib, for all commands (#877)
   * Option --fix-offset: Adjust off-by-one day (#847) Superseded (#918)
   * Update OpenSSL to v3.0.8

3.1.2 (2023-01-13)
   * build-full: Always enable inline file creation (#834)
   * Make default Edwards curve ED25519 (#828)
   * Allow --fix-offset to create post-dated certificates (#804) Superseded (#918)
   * Introduce command 'set-pass' (#756)
   * Introduce global option '--nopass|--no-pass' (#752)
   * Introduce global option '--notext|--no-text' (#745)
   * Command 'help': For unknown command, exit with error (#737)
   * Find data-files in the correct order (#727 - Reported #725)
   * Update OpenSSL to 3.0.7 for Windows distribution

3.1.1 (2022-10-13)
   * Remove command 'renewable' (#715)
   * Expand 'show-renew', include 'renewed/certs_by_serial' (#700)
   * Resolve long-standing issue with --subca-len=N (#691)
   *  ++ NOTICE: Add EasyRSA-Renew-and-Revoke.md (#690)
   * Require 'openssl-easyrsa.cnf' is up to date (#695}
   * Introduce 'renew' (version 3). Only renew cert (#688)
   * Always ensure X509-types files exist (#581 #696)
   * Expand alias '--days' to all suitable options with a period (#674)
   * Introduce --keep-tmp, keep temp files for debugging (#667)
   * Add serialNumber (OID 2.5.4.5) to DN 'org' mode (#606)
   * Support ampersand and dollar-sign in vars file (#590)
   * Introduce 'rewind-renew' (#579)
   * Expand status reports to include checking a single cert (#577)
   * Introduce 'revoke-renewed' (#547)
   * update OpenSSL for Windows to 3.0.5

3.1.0 (2022-05-18)
   * Introduce basic support for OpenSSL version 3 (#492)
   * Update regex in grep to be POSIX compliant (#556)
   * Introduce status reporting tools (#555 & #557)
   * Display certificates using UTF8 (#551)
   * Allow certificates to be created with fixed date offset (#550)
   * Add 'verify' to verify certificate against CA (#549)
   * Add PKCS#12 alias 'friendlyName' (#544)
   * Support multiple IP-Addresses in SAN (#564)
   * Add option '--renew-days=NN', custom renew grace period (#557)
   * Add 'nopass' option to the 'export-pkcs' functions (#411)
   * Add support for 'busybox' (#543)
   * Add option '--tmp-dir=DIR' to declare Temp-dir (Commit f503a22)   

3.0.9 (2022-05-17)
   * Upgrade OpenSSL from 1.1.0j to 1.1.1o (#405, #407) 
      - We are building this ourselves now.
   * Fix --version so it uses EASYRSA_OPENSSL (#416)
   * Use openssl rand instead of non-POSIX mktemp (#478)
   * Fix paths with spaces (#443)
   * Correct OpenSSL version from Homebrew on macOs (#416)
   * Fix revoking a renewed certificate (Original PR #394)
     Follow-up commit: ef22701878bb10df567d60f2ac50dce52a82c9ee
   * Introduce 'show-crl' (d1993892178c5219f4a38d50db3b53d1a972b36c)
   * Support Windows-Git 'version of bash' (#533)
   * Disallow use of single quote (') in vars file, Warning (#530)
   * Creating a CA uses x509-types/ca and COMMON (#526)
   * Prefer 'PKI/vars' over all other locations (#528)
   * Introduce 'init-pki soft'  option (#197)
   * Warnings are no longer silenced by --batch (#523)
   * Improve packaging options (#510)
   * Update regex for POSIX compliance (#556)
   * Correct date format for Darwin/BSD (#559)

3.0.8 (2020-09-09)
   * Provide --version option (#372)
   * Version information now within generated certificates like on *nix
   * Fixed issue where gen-dh overwrote existing files without warning (#373)
   * Fixed issue with ED/EC certificates were still signed by RSA (#374)
   * Added support for export-p8 (#339)
   * Clarified error message (#384)
   * 2->3 upgrade now errors and prints message when vars isn't found (#377)

3.0.7 (2020-03-30)
   * Include OpenSSL libs and binary for Windows 1.1.0j
   * Remove RANDFILE environment variable (#261)
   * Workaround for bug in win32 mktemp (#247, #305, PR #312)
   * Handle IP address in SAN and renewals (#317)
   * Workaround for ash and no set -o echo (#319)
   * Shore up windows testing framework (#314)
   * Provide upgrade mechanism for older versions of EasyRSA (#349)
   * Add support for KDC certificates (#322)
   * Add support for Edward Curves (#354, #350)
   * Add support for EASYRSA_PASSIN and EASYRSA_PASSOUT env vars (#368)
   * Add support for RID to SAN (#362)

3.0.6 (2019-02-01)
   * Certificates that are revoked now move to a revoked subdirectory (#63)
   * EasyRSA no longer clobbers non-EASYRSA environment variables (#277)
   * More sane string checking, allowing for commas in CN (#267)
   * Support for reasonCode in CRL (#280)
   * Better handling for capturing passphrases (#230, others)
   * Improved LibreSSL/MacOS support
   * Adds support to renew certificates up to 30 days before expiration (#286)
     - This changes previous behavior allowing for certificate creation using
       duplicate CNs.

3.0.5 (2018-09-15)
   * Fix #17 & #58: use AES256 for CA key
   * Also, don't use read -s, use stty -echo
   * Fix broken "nopass" option
   * Add -r to read to stop errors reported by shellcheck (and to behave)
   * Remove overzealous quotes around $pkcs_opts (more SC errors)
   * Support for LibreSSL
   * EasyRSA version will be reported in certificate comments
   * Client certificates now expire in 3 year (1080 days) by default

3.0.4 (2018-01-21)
    * Remove use of egrep (#154)
    * Integrate with Travis-CI (#165)
    * Remove "local" from variable assignment (#165)
    * Other changes related to Travis-CI fixes
	* Assign values to variables defined previously w/local
    * Finally(?) fix the subjectAltName issues I presented earlier (really
      fixes #168)

3.0.3 (2017-08-22)
    * Include mktemp windows binary
    * copy CSR extensions into signed certificate


3.0.2 (2017-08-21)
    * Add missing windows binaries


3.0.1 (2015-10-25)
    * Correct some packaging errors


3.0.0 (2015-09-07)

    * cab4a07 Fix typo: Hellman
        (ljani: Github)

    * 171834d Fix typo: Default
        (allo-: Github)

    * 8b42eea Make aes256 default, replacing 3des
        (keros: Github)

    * f2f4ac8 Make -utf8 default
        (roubert: Github)


3.0.0-rc2 (2014/07/27)

    * 1551e5f docs: fix typo
        (Josh Cepek <josh.cepek@usa.net>)

    * 7ae44b3 Add KNOWN_ISSUES to stage next -rc release
        (Josh Cepek <josh.cepek@usa.net>)

    * a0d58b2 Update documentation
        (Josh Cepek <josh.cepek@usa.net>)

    * 5758825 Fix vars.example with proper path to extensions.temp
        (Josh Cepek <josh.cepek@usa.net>)

    * 89f369c Add support to change private key passphrases
        (Josh Cepek <josh.cepek@usa.net>)

    * 49d7c10 Improve docs: add Upgrade-Notes; add online support refs
        (Josh Cepek <josh.cepek@usa.net>)

    * fcc4547 Add build-dist packaging script; update Building docs
        (Josh Cepek <josh.cepek@usa.net>)

    * f74d08e docs: update Hacking.md with layout & git conventions
        (Josh Cepek <josh.cepek@usa.net>)

    * 0754f23 Offload temp file removal to a clean_temp() function
        (Josh Cepek <josh.cepek@usa.net>)

    * 1c90df9 Fix incorrect handling of invalid --use-algo option
        (Josh Cepek <josh.cepek@usa.net>)

    * c86289b Fix batch-mode handling with changes in e75ad75
        (Josh Cepek <josh.cepek@usa.net>)

    * e75ad75 refine how booleans are evaluated
        (Eric F Crist <ecrist@secure-computing.net>)

    * cc19823 Merge PKCS#7 feature from pull req #14
        (Author: Luiz Angelo Daros de Luca <luizluca@tre-sc.gov.br>)
        (Modified-By: Josh Cepek <josh.cepek@usa.net>)

    * 8b1fe01 Support OpenSSL-0.9.8 with the EXTRA_EXTS feature
        (Josh Cepek <josh.cepek@usa.net>)

    * d5516d5 Windows: make builds easier by using a matching dir structure
        (Josh Cepek <josh.cepek@usa.net>)

    * dc2e6dc Windows: improve external checks and env-var help
        (Josh Cepek <josh.cepek@usa.net>)

3.0.0-rc1 (2013/12/01)

    * The 3.x release is a nearly complete re-write of the 2.x codebase

    * Initial 3.x series code by Josh Cepek <josh.cepek@usa.net> -- continuing
    maintenance by the OpenVPN community development team and associated
    contributors

    * Add ECDSA (elliptic curve) support, thanks to Steffan Karger
    <steffan@karger.me>

================
File: pki/easy-rsa/COPYING.md
================
Easy-RSA -- A Shell-based CA Utility
====================================

Copyright (C) 2013 by the Open-Source OpenVPN development community

Easy-RSA 3 license: GPLv2
-------------------------

All the Easy-RSA code contained in this project falls under a GPLv2 license with
full text available in the Licensing/ directory. Additional components used by
this project fall under additional licenses:

Additional licenses for external components
-------------------------------------------

The following components are under different licenses; while not part of the
Easy-RSA source code, these components are used by Easy-RSA or provided in
platform distributions as described below:

### OpenSSL

  OpenSSL is not linked by Easy-RSA, nor is it currently provided in any release
  package by Easy-RSA. However, Easy-RSA is tightly coupled with OpenSSL, so
  effective use of this code will require your acceptance and installation of
  OpenSSL.

### Additional Windows Components

  The Windows binary package includes mksh/Win32 and unxutils binary components,
  with full licensing details available in the distro/windows/Licensing/
  subdirectory of this project. mksh/Win32 is under a MirOS license (with some
  additional component licenses present there) and unxutils is under a GPLv2
  license.

================
File: pki/easy-rsa/KNOWN_ISSUES
================
For a full list of issues, please visit the GitHub issue tracker at
https://github.com/OpenVPN/easy-rsa/issues

* EasyRSA tools, MKSH and mkdir.exe, *may* not work with Windows 11.
  Requires further investigation.

* OpenSSL 3.x does not appear to work on Windows 7.  Please use EasyRSA v3.0.9
  if you intend on using Windows 7.  Note that Windows 7 is no longer supported
  by Microsoft.

================
File: pki/easy-rsa/op-test.sh
================
#!/bin/sh
#
# Downloads the run_unit_tests.sh file from easyrsa-unit-tests repo
# and executes that - allows for disconnected testing from the easy-rsa
# repo with TravisCI.

# log
log () {
	[ "$disable_log" ] && return
	if printf '%s\n' "* $*"; then
		return
	else
		echo "printf failed"
		exit 9
	fi
} # => log ()

# clean up
clean_up () {
	if [ "$no_delete" ]; then
		log "saved final state.."
	else
		log "op-test: clean_up"
		if [ "$EASYRSA_NIX" ]; then
			[ "$keep_eut" ] || rm -f "$utest_bin"
			[ "$keep_sc" ] || rm -f "$sc_bin"
			[ "$keep_ssl" ] || rm -f "$ssl_bin"
		fi
	fi
} # => clean_up ()

# curl download and openssl hash
# wing it ..
curl_it () {
	#log "BEGIN: curl_it"
	if [ "$#" -eq 2 ]; then
		file="$1"
		hash="$2"
	else
		log "> Usage: <file> <hash>"
		return 1
	fi

	if [ "$enable_curl" ]; then
		: # ok
	else
		log "> curl disabled"
		return 0
	fi

	# valid target
	case "$file" in
	easyrsa-unit-tests.sh|easyrsa-unit-tests-help.sh)
		unset -v require_hash
	;;
	shellcheck|openssl)
		require_hash=1
	;;
	*)
		log "> invalid target: $file"
		return 1
	esac

	# download
	if [ "$enable_curl" ]; then
		log "> download: ${gh_url}/${file}"
		curl -SO "${gh_url}/${file}" || \
			log "> download failed: ${file}"
	else
		log "> curl disabled"
	fi

	# hash download
	if [ "${require_hash}" ]; then
		if [ -e "${file}" ]; then
			log "> hash ${file}"
			temp_hash="$(openssl sha256 "${file}")"
			#log "temp_hash: $temp_hash"
			#log "hash     : $hash"
			if [ "$temp_hash" = "$hash" ]; then
				: # OK - hash is good
			else
				log "> hash failed: ${file}"
				return 1
			fi
		else
			log "> file missing: ${file}"
			return 1
		fi
	else
		if [ -e "${file}" ]; then
			: # ok - file is here
		else
			log "> file missing: ${file}"
			return 1
		fi
	fi
} # => curl_it ()

################################################################################

# RUN unit test
run_unit_test ()
{
	if [ "${utest_bin_ok}" ]; then

		# Start unit tests
		log ">>> BEGIN unit tests:"
		[ "$no_delete" ] && export SAVE_PKI=1

		if [ "${dry_run}" ]; then
			log "<<dry-run>> sh ${utest_bin} ${verb} $use_passwords"
			estat=1
		else
			log ">>>>>>: sh ${utest_bin} ${verb}"
			if sh "${utest_bin}" "${verb}" "$use_passwords"; then
				log "OK"
				estat=0
				if [ "$EASYRSA_BY_TINCANTECH" ]; then
					sh "${utest_help_bin}" "${help_verb}" "$use_passwords"
				fi
			else
				log "FAIL"
				estat=1
			fi
		fi
		log "<<< END unit tests:"
		unset SAVE_PKI
	else
		log "unit-test abandoned"
		estat=1
	fi
} # => run_unit_test ()

########################################

## DOWNLOAD unit-test
download_unit_test () {
	# if not present then download unit-test
	target_file="${utest_file}"
	target_hash="${utest_hash}"
	if [ "$enable_unit_test" ]; then
		if [ -e "${ERSA_UT}/${target_file}" ]; then
			[ -x "${ERSA_UT}/${target_file}" ] || \
				chmod +x "${ERSA_UT}/${target_file}"
			# version check
			if "${ERSA_UT}/${target_file}" version; then
				utest_bin="${ERSA_UT}/${target_file}"
				utest_bin_ok=1
				export ERSA_UTEST_CURL_TARGET=localhost
			else
				log "version check failed: ${ERSA_UT}/${target_file}"
			fi
		else
			# download and basic check
			log "curl_it ${target_file}"
			if curl_it "${target_file}" "${target_hash}"; then
				[ -x "${ERSA_UT}/${target_file}" ] || \
					chmod +x "${ERSA_UT}/${target_file}"
				# functional check - version check
				if "${ERSA_UT}/${target_file}" version; then
					utest_bin="${ERSA_UT}/${target_file}"
					utest_bin_ok=1
					export ERSA_UTEST_CURL_TARGET=online
					unset -v keep_eut
				else
					log "version check failed: ${target_file}"
				fi
			else
				log "curl_it ${target_file} - failed"
			fi
		fi
		[ "$utest_bin_ok" ] || log "undefined: utest_bin_ok"
		log "setup unit-test - ok"
	else
		log "unit-test disabled"
	fi # => shellcheck
}
## DOWNLOAD unit-test

## DOWNLOAD unit-test-help
download_unit_test_help () {
	# if not present then download unit-test-help
	target_file="${utest_help_file}"
	target_hash="${utest_hash}"
	if [ "$enable_unit_test" ]; then
		if [ -e "${ERSA_UT}/${target_file}" ]; then
			[ -x "${ERSA_UT}/${target_file}" ] || \
				chmod +x "${ERSA_UT}/${target_file}"
			# version check
			if "${ERSA_UT}/${target_file}" version; then
				utest_help_bin="${ERSA_UT}/${target_file}"
				utest_help_bin_ok=1
				export ERSA_UTEST_CURL_TARGET=localhost
			else
				log "version check failed: ${ERSA_UT}/${target_file}"
			fi
		else
			# download and basic check
			log "curl_it ${target_file}"
			if curl_it "${target_file}" "${target_hash}"; then
				[ -x "${ERSA_UT}/${target_file}" ] || \
					chmod +x "${ERSA_UT}/${target_file}"
				# functional check - version check
				if "${ERSA_UT}/${target_file}" version; then
					utest_help_bin="${ERSA_UT}/${target_file}"
					utest_help_bin_ok=1
					export ERSA_UTEST_CURL_TARGET=online
					unset -v keep_eut
				else
					log "version check failed: ${target_file}"
				fi
			else
				log "curl_it ${target_file} - failed"
			fi
		fi
		[ "$utest_help_bin_ok" ] || log "undefined: utest_help_bin_ok"
		log "setup unit-test-help - ok"
	else
		log "unit-test-help disabled"
	fi # => shellcheck
}
## DOWNLOAD unit-test-help

################################################################################

## USE shellcheck

# Run shellcheck
run_shellcheck () {
	sc_bin=shellcheck
	if [ "$enable_shellcheck" ] && [ "$EASYRSA_NIX" ]; then
		# shell-check easyrsa3/easyrsa
		if [ -e easyrsa3/easyrsa ]; then
			if "${sc_bin}" -s sh -S warning -x easyrsa3/easyrsa; then
				log "shellcheck easyrsa3/easyrsa completed - ok"
			else
				log "shellcheck easyrsa3/easyrsa completed - FAILED"
			fi
		else
			log "easyrsa binary not present, not using shellcheck"
		fi

		# shell-check dev/easyrsa-tools.lib
		if [ -e dev/easyrsa-tools.lib ]; then
			if "${sc_bin}" -s sh -S warning -x dev/easyrsa-tools.lib; then
				log "shellcheck dev/easyrsa-tools.lib completed - ok"
			else
				log "shellcheck dev/easyrsa-tools.lib completed - FAILED"
			fi
		else
			log "dev/easyrsa-tools.lib not present, not using shellcheck"
		fi

		# shell-check easyrsa-unit-tests.sh
		if [ -e easyrsa-unit-tests.sh ]; then
			if "${sc_bin}" -s sh -S warning -x easyrsa-unit-tests.sh; then
				log "shellcheck easyrsa-unit-tests.sh completed - ok"
			else
				log "shellcheck easyrsa-unit-tests.sh completed - FAILED"
			fi
		else
			log "easyrsa-unit-tests.sh binary not present, not using shellcheck"
		fi
	else
		log "shellcheck abandoned"
	fi
}
## USE shellcheck

########################################

## DOWNLOAD shellcheck
download_shellcheck () {
	# if not present then download shellcheck
	target_file="${sc_file}"
	target_hash="${sc_hash}"
	if [ "$enable_shellcheck" ] && [ "$EASYRSA_NIX" ]; then
		log "setup shellcheck"
		if [ -e "${ERSA_UT}/${target_file}" ]; then
			[ -x "${ERSA_UT}/${target_file}" ] || \
				chmod +x "${ERSA_UT}/${target_file}"
			"${ERSA_UT}/${target_file}" -V || \
				log "version check failed: ${ERSA_UT}/${target_file}"
			sc_bin="${ERSA_UT}/${target_file}"
			sc_bin_ok=1
			log "shellcheck enabled"
		else
			# download and basic check
			log "curl_it ${target_file}"
			if curl_it "${target_file}" "${target_hash}"; then
				log "curl_it ${target_file} - ok"
				[ -x "${ERSA_UT}/${target_file}" ] || \
					chmod +x "${ERSA_UT}/${target_file}"
				# functional check
				if "${ERSA_UT}/${target_file}" -V; then
					sc_bin="${ERSA_UT}/${target_file}"
					sc_bin_ok=1
					unset -v keep_sc
				else
					log "version check failed: ${ERSA_UT}/${target_file}"
				fi
				log "shellcheck enabled"
			else
				log "curl_it ${target_file} - failed"
			fi
		fi
	fi

	## DOWNLOAD shellcheck
}

################################################################################

## DOWNLOAD openssl-3
download_opensslv3 () {
	# if not present then download and then use openssl3
	target_file="${ssl_file}"
	target_hash="${ssl_hash}"
	if [ "$enable_openssl3" ] && [ "$EASYRSA_NIX" ]; then
		if [ -e "${ERSA_UT}/${target_file}" ]; then
			[ -x "${ERSA_UT}/${target_file}" ] || \
				chmod +x "${ERSA_UT}/${target_file}"
			# version check 'openssl version'
			"${ERSA_UT}/${target_file}" version || \
				log "version check failed: ${ERSA_UT}/${target_file}"
			ssl_bin="${ERSA_UT}/${target_file}"
			ssl_bin_ok=1
			# Set up Easy-RSA Unit-Test for OpenSSL-v3
			export EASYRSA_OPENSSL="${ssl_bin}"
		else
			# download and basic check
			log "curl_it ${target_file}"
			if curl_it "${target_file}" "${target_hash}"; then
				log "curl_it ${target_file} - ok"
				[ -x "${ERSA_UT}/${target_file}" ] || \
					chmod +x "${ERSA_UT}/${target_file}"
				# functional check - version check 'openssl version'
				if "${ERSA_UT}/${target_file}" version; then
					ssl_bin="${ERSA_UT}/${target_file}"
					ssl_bin_ok=1
					unset -v keep_ssl
					# Set up Easy-RSA Unit-Test for OpenSSL-v3
					export EASYRSA_OPENSSL="${ssl_bin}"
				else
					log "version check failed: ${ERSA_UT}/${target_file}"
				fi
			else
				log "curl_it ${target_file} - failed"
			fi
		fi

			log "OpenSSL-v3 enabled"

	else
		if [ "$EASYRSA_NIX" ]; then
			log "System SSL enabled"
			ssl_bin="openssl"
			ssl_bin_ok=1
		else
			log "Windows, no OpenSSL-v3"
			log "System SSL enabled"
			ssl_bin="openssl"
			ssl_bin_ok=1
		fi
	fi
} # => ## DOWNLOAD openssl-3

################################################################################

	# Register clean_up on EXIT
	#trap "exited 0" 0
	# When SIGHUP, SIGINT, SIGQUIT, SIGABRT and SIGTERM,
	# explicitly exit to signal EXIT (non-bash shells)
	trap "clean_up" 1
	trap "clean_up" 2
	trap "clean_up" 3
	trap "clean_up" 6
	trap "clean_up" 15


unset -v disable_log verb no_delete \
		enable_unit_test enable_shellcheck enable_openssl3

keep_sc=1
keep_ssl=1
keep_eut=1

# Set by default
enable_unit_test=1
enable_curl=1
EASYRSA_NIX=1

while [ -n "$1" ]; do
	case "$1" in
	--no-log)			disable_log=1 ;;
	'')					verb='-v' ;;
	-v)					verb='-v' ;;
	-vv)				verb='-vv' ;;
	-sc)				enable_shellcheck=1 ;;
	-o3)				: ;; # ignored
	-p)					use_passwords='-p' ;;
	-dr)				dry_run=1 ;;
	-nt|--no-test)		unset -v enable_unit_test ;;
	-nc|--no-curl)		unset -v enable_curl ;;
	-nd|--no-delete)	no_delete=1 ;;
	-w|--windows)		export EASYRSA_WIN=1; unset -v EASYRSA_NIX ;;
	*)
		log "Unknown option: $1"
		exit 9
	esac
	shift
done

log "Easy-RSA Unit Tests:"

# Layout
ERSA_UT="${PWD}"

# Sources
gh_url='https://raw.githubusercontent.com/OpenVPN/easyrsa-unit-tests/master'

utest_file='easyrsa-unit-tests.sh'
unset -v utest_bin utest_bin_ok
utest_hash='no-hash'

utest_help_file='easyrsa-unit-tests-help.sh'
unset -v utest_help_bin utest_help_bin_ok
#utest_hash='no-hash'
help_verb="-vv"

sc_file='shellcheck'
unset -v sc_bin sc_bin_ok
# v 0.8.0
#sc_hash='SHA256(shellcheck)= f4bce23c11c3919c1b20bcb0f206f6b44c44e26f2bc95f8aa708716095fa0651'

# v 0.9.0
sc_hash='SHA256(shellcheck)= 7087178d54de6652b404c306233264463cb9e7a9afeb259bb663cc4dbfd64149'

ssl_file='openssl'
unset -v ssl_bin ssl_bin_ok
# v 3.0.3
#ssl_hash='SHA256(openssl)= a0aed8b4aec1b72ca17c8a9ab04e10d829343a12cb5e7f8f6ae73e6f2ce026fd'

# v 3.0.5
#ssl_hash='SHA256(openssl)= 341d278423aeecbaa2b057b84b5501dd492c8f7e192c5bb9c66a260dbc022a4c'

# v 3.0.7
#ssl_hash='SHA256(openssl)= 606f8fb9d6ac7993c2f68efba8c4f022e128a8e9ab1a0921e4941d9f88a7bb5b'

# v 3.1.0
ssl_hash='SHA256(openssl)= 85b562891087d4c64868d8d1f0a381407d8e23fb66c37ce9baad55cf57edbc04'

# Here we go ..

#download_shellcheck
#download_opensslv3
download_unit_test
download_unit_test_help

run_shellcheck
run_unit_test

# No trap required..
clean_up

################################################################################

log "estat: $estat ${dry_run:+<<dry run>>}"
exit $estat

# vim: no

================
File: pki/easy-rsa/README.md
================
[![CI](https://github.com/Openvpn/easy-rsa/actions/workflows/action.yml/badge.svg)](https://github.com/Openvpn/easy-rsa/actions/workflows/action.yml)
# Overview

easy-rsa is a CLI utility to build and manage a PKI CA. In layman's terms,
this means to create a root certificate authority, and request and sign
certificates, including intermediate CAs and certificate revocation lists (CRL).

# Downloads

If you are looking for release downloads, please see the releases section on
GitHub. Releases are also available as source checkouts using named tags.

# Documentation

For 3.x project documentation and usage, see the [README.quickstart.md](README.quickstart.md) file or
the more detailed docs under the [doc/](doc/) directory. The .md files are in Markdown
format and can be converted to html files as desired for release packages, or
read as-is in plaintext.

# Getting help using easy-rsa

Currently, Easy-RSA development co-exists with OpenVPN even though they are
separate projects. The following resources are good places as of this writing to
seek help using Easy-RSA:

The [openvpn-users mailing list](https://lists.sourceforge.net/lists/listinfo/openvpn-users)
is a good place to post usage or help questions.

Users of GitHub can report problems to the Easy-RSA `issues` list.

# Branch structure

The easy-rsa master branch is currently tracking development for the 3.x release
cycle. Please note that, at any given time, master may be broken. Feel free to
create issues against master, but have patience when using the master branch. It
is recommended to use a release, and priority will be given to bugs identified in
the most recent release.

The prior 2.x and 1.x versions are available as release branches for
tracking and possible back-porting of relevant fixes.

Branch layout is:

    master             <- Active: v3.2.x - Rolling.
    v3.<N>.<N>-<LABEL>    Active: Development branches.
    testing               Sandbox: Subject to change without notice.
    v3.1.8                Sunset: Bugfix only for v3.1.7

    The following are NOT compatible with OpenSSL version 3:

    v3.0.6                Inactive: Archived.
    v3.0.5                Inactive: Archived.
    v3.0.4                Inactive: Archived.
    release/3.0           Inactive: Archived.
    release/2.x           Inactive: Archived.
    release/1.x           Inactive: Unmaintained.

LICENSING info for 3.x is in the [COPYING.md](COPYING.md) file

## Contributing

Please refer to: [doc/EasyRSA-Contributing.md](doc/EasyRSA-Contributing.md)

# Code style, standards

We are attempting to adhere to the POSIX standard, which can be found here:

https://pubs.opengroup.org/onlinepubs/9699919799/

================
File: pki/easy-rsa/README.quickstart.md
================
Easy-RSA 3 Quickstart README
============================

This is a quickstart guide to using Easy-RSA version 3. Detailed help on usage
and specific commands can be found by running ./easyrsa -h.  Additional
documentation can be found in the doc/ directory.

If you're upgrading from the Easy-RSA 2.x series, there are Upgrade-Notes
available, also under the doc/ path.

Setup and signing the first request
-----------------------------------

Here is a quick run-though of what needs to happen to start a new PKI and sign
your first entity certificate:

1. Choose a system to act as your CA and create a new PKI and CA:

        ./easyrsa init-pki
        ./easyrsa build-ca

2. On the system that is requesting a certificate, init its own PKI and generate
   a keypair/request. Note that init-pki is used _only_ when this is done on a
   separate system (or at least a separate PKI dir.) This is the recommended
   procedure. If you are not using this recommended procedure, skip the next
   import-req step.

        ./easyrsa init-pki
        ./easyrsa gen-req EntityName

3. Transport the request (.req file) to the CA system and import it. The name
   given here is arbitrary and only used to name the request file.

        ./easyrsa import-req /tmp/path/to/import.req EntityName

4. Sign the request as the correct type. This example uses a client type:

        ./easyrsa sign-req client EntityName

5. Transport the newly signed certificate to the requesting entity. This entity
   may also need the CA cert (ca.crt) unless it had a prior copy.

6. The entity now has its own keypair, signed cert, and the CA.

Signing subsequent requests
---------------------------

Follow steps 2-6 above to generate subsequent keypairs and have the CA return
signed certificates.

Revoking certs and creating CRLs
--------------------------------

This is a CA-specific task.

To permanently revoke an issued certificate, provide the short name used during
import:

        ./easyrsa revoke EntityName

To create an updated CRL that contains all revoked certs up to that point:

        ./easyrsa gen-crl

After generation, the CRL will need to be sent to systems that reference it.

Generating Diffie-Hellman (DH) params
-------------------------------------

After initializing a PKI, any entity can create DH params that needs them. This
is normally only used by a TLS server. While the CA PKI can generate this, it
makes more sense to do it on the server itself to avoid the need to send the
files to another system after generation.

DH params can be generated with:

        ./easyrsa gen-dh

Showing details of requests or certs
------------------------------------

To show the details of a request or certificate by referencing the short
EntityName, use one of the following commands. It is an error to call these
without a matching file.

        ./easyrsa show-req EntityName
        ./easyrsa show-cert EntityName

Changing private key passphrases
--------------------------------

RSA and EC private keys can be re-encrypted so a new passphrase can be supplied
with one of the following commands depending on the key type:

        ./easyrsa set-rsa-pass EntityName
        ./easyrsa set-ec-pass EntityName

Optionally, the passphrase can be removed completely with the 'nopass' flag.
Consult the command help for details.

================
File: pki/easy-rsa/vars
================
# Easy-RSA 3 parameter settings

# NOTE: If you installed Easy-RSA from your package manager, do not edit
# this file in place -- instead, you should copy the entire easy-rsa directory
# to another location so future upgrades do not wipe out your changes.

# HOW TO USE THIS FILE
#
# vars.example contains built-in examples to Easy-RSA settings. You MUST name
# this file "vars" if you want it to be used as a configuration file. If you
# do not, it WILL NOT be automatically read when you call easyrsa commands.
#
# It is not necessary to use this config file unless you wish to change
# operational defaults. These defaults should be fine for many uses without
# the need to copy and edit the "vars" file.
#
# All of the editable settings are shown commented and start with the command
# "set_var" -- this means any set_var command that is uncommented has been
# modified by the user. If you are happy with a default, there is no need to
# define the value to its default.

# NOTES FOR WINDOWS USERS
#
# Paths for Windows  *MUST* use forward slashes, or optionally double-escaped
# backslashes (single forward slashes are recommended.) This means your path
# to the openssl binary might look like this:
# "C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# A little housekeeping: DO NOT EDIT THIS SECTION
#
# Easy-RSA 3.x does not source into the environment directly.
# Complain if a user tries to do this:
if [ -z "$EASYRSA_CALLER" ]; then
	echo "You appear to be sourcing an Easy-RSA *vars* file. This is" >&2
	echo "no longer necessary and is disallowed. See the section called" >&2
	echo "*How to use this file* near the top comments for more details." >&2
	return 1
fi

# DO YOUR EDITS BELOW THIS POINT

# This variable is used as the base location of configuration files needed by
# easyrsa.  More specific variables for specific files (eg: EASYRSA_SSL_CONF)
# may override this default.
#
# The default value of this variable is the location of the easyrsa script
# itself, which is also where the configuration files are located in the
# easy-rsa tree.
#
#set_var EASYRSA	"${0%/*}"

# If your OpenSSL command is not in the system PATH, you will need to define
# the path here. Normally this means a full path to the executable, otherwise
# you could have left it undefined here and the shown default would be used.
#
# Windows users, remember to use paths with forward-slashes (or escaped
# back-slashes.) Windows users should declare the full path to the openssl
# binary here if it is not in their system PATH.
#
#set_var EASYRSA_OPENSSL	"openssl"
#
# This sample is in Windows syntax -- edit it for your path if not using PATH:
#set_var EASYRSA_OPENSSL	"C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# Edit this variable to point to your soon-to-be-created key directory.
# By default, this will be "$PWD/pki" (ie: the "pki" subdirectory of the
# directory you are currently in).
#
# WARNING: init-pki will do a rm -rf on this directory so make sure you define
# it correctly!  Interactive mode will prompt before acting.
#
#set_var EASYRSA_PKI		"$PWD/pki"

# Define directory for temporary subdirectories.
#
#set_var EASYRSA_TEMP_DIR	"$EASYRSA_PKI"

# Define X509 DN mode.
#
# This is used to adjust which elements are included in the Subject field
# as the DN ("Distinguished Name"). Note that in 'cn_only' mode the
# Organizational fields, listed further below, are not used.
#
# Choices are:
#   cn_only  - Use just a commonName value.
#   org      - Use the "traditional" format:
#              Country/Province/City/Org/Org.Unit/email/commonName
#
#set_var EASYRSA_DN	"cn_only"

# Organizational fields (used with "org" mode and ignored in "cn_only" mode).
# These are the default values for fields which will be placed in the
# certificate.  Do not leave any of these fields blank, although interactively
# you may omit any specific field by typing the "." symbol (not valid for
# email).
#
# NOTE: The following characters are not supported
#       in these "Organizational fields" by Easy-RSA:
#       back-tick (`)
#
set_var EASYRSA_REQ_COUNTRY	"ES"
set_var EASYRSA_REQ_PROVINCE	"Barcelona"
set_var EASYRSA_REQ_CITY	"Torrelavit"
set_var EASYRSA_REQ_ORG	"ymbi"
set_var EASYRSA_REQ_EMAIL	"oriol@joor.net"
set_var EASYRSA_REQ_OU		"IT"

# Preserve the Distinguished Name field order
# of the certificate signing request
# *Only* effective in --dn-mode=org
#
#set_var EASYRSA_PRESERVE_DN	1

# Set no password mode - This will create the entire PKI without passwords.
# This can be better managed by choosing which entity private keys should be
# encrypted with the following command line options:
# Global option '--no-pass' or command option 'nopass'.
#
#set_var EASYRSA_NO_PASS	1

# Choose a size in bits for your keypairs. The recommended value is 2048.
# Using 2048-bit keys is considered more than sufficient for many years into
# the future. Larger keysizes will slow down TLS negotiation and make key/DH
# param generation take much longer. Values up to 4096 should be accepted by
# most software. Only used when the crypto alg is rsa, see below.
#
set_var EASYRSA_KEY_SIZE	4096

# The default crypto mode is rsa; ec can enable elliptic curve support.
# Note that not all software supports ECC, so use care when enabling it.
# Choices for crypto alg are: (each in lower-case)
#  * rsa
#  * ec
#  * ed
#
#set_var EASYRSA_ALGO		rsa

# Define the named curve, used in ec & ed modes:
#
#set_var EASYRSA_CURVE		secp384r1

# In how many days should the root CA key expire?
#
set_var EASYRSA_CA_EXPIRE	365000

# In how many days should certificates expire?
#
set_var EASYRSA_CERT_EXPIRE	825

# How many days until the next CRL publish date?  Note that the CRL can still
# be parsed after this timeframe passes. It is only used for an expected next
# publication date.
#
set_var EASYRSA_CRL_DAYS	180

# Random serial numbers by default.
# Set to 'no' for the old incremental serial numbers.
#
set_var EASYRSA_RAND_SN	"yes"

# Cut-off window for checking expiring certificates.
#
#set_var EASYRSA_PRE_EXPIRY_WINDOW	90

# Generate automatic subjectAltName for certificates
#
#set_var	EASYRSA_AUTO_SAN	1

# Add critical attribute to X509 fields: basicConstraints (BC),
# keyUsage (KU), extendedKeyUsage (EKU) or SAN
#
#set_var	EASYRSA_BC_CRIT		1
#set_var	EASYRSA_KU_CRIT		1
#set_var	EASYRSA_EKU_CRIT	1
#set_var	EASYRSA_SAN_CRIT	1

# Support deprecated "Netscape" extensions? (choices "yes" or "no").
# The default is "no", to discourage use of deprecated extensions.
# If you require this feature to use with --ns-cert-type, set this to "yes".
# This support should be replaced with the more modern --remote-cert-tls
# feature.  If you do not use --ns-cert-type in your configs, it is safe,
# and recommended, to leave this defined to "no".
# When set to "yes", server-signed certs get the nsCertType=server attribute
# and also get any NS_COMMENT defined below in the nsComment field.
#
#set_var EASYRSA_NS_SUPPORT	"no"

# When NS_SUPPORT is set to "yes", this field is added as the nsComment field.
# Set this blank to omit it. With NS_SUPPORT set to "no" this field is ignored.
#
#set_var EASYRSA_NS_COMMENT	"Easy-RSA Generated Certificate"

# !!
# NOTE: ADVANCED OPTIONS BELOW THIS POINT
# PLAY WITH THEM AT YOUR OWN RISK
# !!

# Broken shell command aliases: If you have a largely broken shell that is
# missing any of these POSIX-required commands used by Easy-RSA, you will need
# to define an alias to the proper path for the command.  The symptom will be
# some form of a "command not found" error from your shell. This means your
# shell is BROKEN, but you can hack around it here if you really need. These
# shown values are not defaults: it is up to you to know what you are doing if
# you touch these.
#
#alias awk="/alt/bin/awk"
#alias cat="/alt/bin/cat"

# X509 extensions directory:
# If you want to customize the X509 extensions used, set the directory to look
# for extensions here. Each cert type you sign must have a matching filename,
# and an optional file named "COMMON" is included first when present. Note that
# when undefined here, default behaviour is to look in $EASYRSA_PKI first, then
# fallback to $EASYRSA for the "x509-types" dir.  You may override this
# detection with an explicit dir here.
#
#set_var EASYRSA_EXT_DIR	"$EASYRSA/x509-types"

# Non-functional
# If you want to generate KDC certificates, you need to set the realm here.
#
#set_var EASYRSA_KDC_REALM      "CHANGEME.EXAMPLE.COM"

# OpenSSL config file:
# If you need to use a specific openssl config file, you can reference it here.
# Normally this file is auto-detected from a file named openssl-easyrsa.cnf
# from the EASYRSA_PKI or EASYRSA dir, in that order. NOTE that this file is
# Easy-RSA specific and you cannot just use a standard config file, so this is
# an advanced feature.
#
#set_var EASYRSA_SSL_CONF	"$EASYRSA_PKI/openssl-easyrsa.cnf"

# Cryptographic digest to use.
# Do not change this default unless you understand the security implications.
# Valid choices include: md5, sha1, sha256, sha224, sha384, sha512
#
#set_var EASYRSA_DIGEST		"sha256"

# Batch mode. Leave this disabled unless you intend to call Easy-RSA explicitly
# in batch mode without any user input, confirmation on dangerous operations,
# or most output. Setting this to any non-blank string enables batch mode.
#
#set_var EASYRSA_BATCH		""

================
File: pki/easy-rsa/wop-test.bat
================
@echo off

IF "%1"=="/SL" (set SAVE_LAYOUT=1) ELSE set SAVE_LAYOUT=0

set SYS_ARCH=test
IF %PROCESSOR_ARCHITECTURE%==x86 set SYS_ARCH=win32
IF %PROCESSOR_ARCHITECTURE%==x86_64 set SYS_ARCH=win64
IF %PROCESSOR_ARCHITECTURE%==AMD64 set SYS_ARCH=win64
IF %SYS_ARCH%==test (
	echo Fatal Error: Unknown PROCESSOR_ARCHITECTURE
	set SYS_ARCH=
	exit /B 1 )

set WORK_DIR=%cd%
mkdir "%WORK_DIR%\easyrsa3\bin"
copy  "%WORK_DIR%\distro\windows\bin\*" "%WORK_DIR%\easyrsa3\bin"
copy  "%WORK_DIR%\distro\windows\%SYS_ARCH%\*" "%WORK_DIR%\easyrsa3\bin"
copy  "%WORK_DIR%\distro\windows\EasyRSA-Start.bat" "%WORK_DIR%\easyrsa3\EasyRSA-Start.bat"
PATH=%PATH%;%WORK_DIR%\easyrsa3\bin;C:\PROGRA~1\openssl

cmd /C "easyrsa3\bin\sh.exe wop-test.sh"
IF ERRORLEVEL 1 (
	echo Error occurred, Exit 1
	exit /B 1 )

REM Success ..
	IF %SAVE_LAYOUT% EQU 0 (
		echo rmdir /S /Q "%WORK_DIR%\easyrsa3\bin"
		rmdir /S /Q "%WORK_DIR%\easyrsa3\bin"
		echo del /Q "%WORK_DIR%\easyrsa3\EasyRSA-Start.bat"
		del /Q "%WORK_DIR%\easyrsa3\EasyRSA-Start.bat"
		REM echo del "%WORK_DIR%\easyrsa3\.rnd"
		REM del /Q "%WORK_DIR%\easyrsa3\.rnd"
	) ELSE echo NOTICE; Saved Layout

set SAVE_LAYOUT=
set SYS_ARCH=

================
File: pki/easy-rsa/wop-test.sh
================
#!/bin/sh
# shellcheck disable=SC2161,SC1091

# This script is a frontend designed to create & launch a POSIX shell
# environment suitable for use with Easy-RSA. mksh/Win32 is used with this
# project; use with other POSIX shells for Windows may require modification to
# this wrapper script.

cd easyrsa3 || { echo "ERROR: Cannot find easyrsa3 directory"; exit 1; }

setup_path="${EASYRSA:-$PWD}"
export PATH="$setup_path;$setup_path/bin;$PATH"
export HOME="$setup_path"

# This prevents reading from a user's .mkshrc if they have one.
# A user who runs mksh for other purposes might have it
export ENV="/disable-env"

# Verify required externals are present
extern_list="which awk cat cp mkdir printf rm"
for f in $extern_list; do
	if ! which "${f}.exe" >/dev/null 2>&1; then
		echo ""
		echo "FATAL: EasyRSA Shell init is missing a required external file:"
		echo "  ${f}.exe"
		echo "  Your installation is incomplete and cannot function without the required"
		echo "  files."
		echo ""
		echo "  Press enter to exit."
		#shellcheck disable=SC2162
		read
		exit 1
	fi
done

# set_var is defined as any vars file needs it.
# This is the same as in easyrsa, but we _don't_ export
set_var() {
        var="$1"
        shift
        value="$*"
        eval "$var=\"\${$var-$value}\""
} #=> set_var()

# Check for a usable openssl bin, referencing vars if present
[ -r "vars" ] && EASYRSA_CALLER=1 . "vars" 2>/dev/null
if [ -z "$EASYRSA_OPENSSL" ] && ! which openssl.exe >/dev/null 2>&1; then
	echo "WARNING: openssl isn't in your system PATH. The openssl binary must be"
	echo "  available in the PATH, defined in the 'vars' file, or defined in a"
	echo "  named environment variable. See README-Windows.txt for more info."
fi

[ -f "$setup_path/easyrsa" ] || {
	echo "Missing easyrsa script. Expected to find it at: $setup_path/easyrsa"
	exit 2
}

# Set prompt and welcome message
export PS1='
EasyRSA Shell
# '
echo ""
echo "Welcome to the EasyRSA 3 Shell for Windows."
echo "Easy-RSA 3 is available under a GNU GPLv2 license."
echo ""
echo "Invoke './easyrsa' to call the program. Without commands, help is displayed."

cd ..

./op-test.sh -w -p -v

================
File: python_client/certs/ca.crt
================
-----BEGIN CERTIFICATE-----
MIIFWTCCA0GgAwIBAgIUemDZJhnhPitFWMfaWHkWplwheygwDQYJKoZIhvcNAQEL
BQAwGjEYMBYGA1UEAwwPcGtpLmV4YW1wbGUudGxkMCAXDTI1MDIwMzE0MDAwNFoY
DzMwMjQwNjA2MTQwMDA0WjAaMRgwFgYDVQQDDA9wa2kuZXhhbXBsZS50bGQwggIi
MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCrGiIsoJAA7dsliv8w4OnLT3Ue
JN8ukoa++6giI21KYmoswE7JJL7OWT19l62O5giFbw2AadkKw9+SORmmC342eruZ
eQKbUduoG1McrqrTRIbUfCZQlUYttF89gpcOal2UtG0vPOTwBRZkrq6H68wuUVM3
CkWSu/cImP4/9MbyGlJUGv8wvlVzBB+qeViE9Q49EIN5C3gr6LbgyfplBG5V0WK3
IxFE1pWg4Dj1/el3jjF6EDQGMBSngogO56cxgi6ZFzDr5v5csHDLKMtU9fEuHX70
RA5GwyLj6VvUKrMrgYC/MPRI5ggapTWH5QQ62g2CLhvCPwFzm5/lp6KLhQElkn7D
I4QGg1hNFHnuOJhotPcfHNqkAmvA9++x36eb+JmO2fNlUd7HcZrMLnnKAk+FaxAe
PaauBjiiBktm2fwYO4MHvpnzhB3KKvXqL1UiNiCXgFLuq9EpsxkTWj6mAM6iRpUi
ERtzk0XWS24g6gVDOr9LLQZE5yW4YC8cixymkL3921zn/DulIbO0bMYkdtcoTyyM
sL+tiDA0Cl/lglvcHrtCg2H0/o/a6emSmXpZ7s6m/JYZkRkcdCwwBLkfNSB8qkSJ
U+WbzpOAeegcwnPJlEwO8awqh8hMzkG/RK7PSRipJnqI3LYMv9dHuJJbVg53hPSO
N1xby0TzRfTIi1tT9wIDAQABo4GUMIGRMAwGA1UdEwQFMAMBAf8wHQYDVR0OBBYE
FEh1idNahu2pS+Af0egknn1e+4QqMFUGA1UdIwROMEyAFEh1idNahu2pS+Af0egk
nn1e+4QqoR6kHDAaMRgwFgYDVQQDDA9wa2kuZXhhbXBsZS50bGSCFHpg2SYZ4T4r
RVjH2lh5FqZcIXsoMAsGA1UdDwQEAwIBBjANBgkqhkiG9w0BAQsFAAOCAgEAdnOO
lbcXn+0QRRl5nVbBsMisGmvQGEudop5Ypu1v3frBDDsH2Q03lcGIuQGa4qa7Tb/T
xl7wdwj7CdCpAQpUYjVRyWTS1z2nDpCe8W5EG4oEDjMF5eNnvzU9IxLbY1s2vCcY
2VNi4P5rdZvCetz/DZIK6oP+ZGzkwhqnITs25LWw+exx80rXlc4NHpEFGvfeZj9i
cYWzR4SwyUHZHmHsxSZCTm7EUFUayE+Ao7jf6Qhi+qNOTqWt1OnH4Hev6fKH4fiq
EKrnPk3C2YtCqeiC1mLw/fwNZEFyEBo4vbpb+spBhNDpfT/+GZyvGZ7OD4EHttmh
s9fZLf6k23Mcb5ixOqq00x22Hn1INaRTW/GtZ3qcwZem1JUy/rmItGriEZ/+cGjk
1xEEgI9G5cS5qqbWB0Olm8zbE3KKFSAxpK+ZlsnmkoCoJMKfP6oYI/okTVRFEy0z
Ku4N8MGkvXh1ikQcIirJra/n9eTat1n9iceb34hgxV93Srxdmg4fpMdM8GxOkQab
26CSsecBQzWGFxOQt4zQAoXQQSDI2PFITN6jXBNUrYdKoTTQEBrkJ9T9KnBFWoIe
M9BFRNeLJAUZ71gdaYgEzKtYOcZhWG5tfdo+MPxLjdchC7A95xl6wGJFmchabtIG
3RLvEQa6PFIDC1xajQUZDMQdiwWDxxGVldotKos=
-----END CERTIFICATE-----

================
File: python_client/mqtt_pub.py
================
import os
import ssl
import sys
from dotenv import load_dotenv
import paho.mqtt.client as mqtt

def main(topic: str, message: str):
    # Load environment variables from .env file
    load_dotenv()

    # Retrieve MQTT and SSL/TLS configurations from environment variables
    MQTT_HOST = os.getenv('MQTT_HOST')
    MQTT_PORT = int(os.getenv('MQTT_PORT', 8883))

    CA_FILE = os.getenv('CA_FILE')
    CERT_FILE = os.getenv('CERT_FILE')
    KEY_FILE = os.getenv('KEY_FILE')
    KEY_PASSPHRASE = os.getenv('KEY_PASSPHRASE')

    # Validate required parameters
    required_vars = [MQTT_HOST, MQTT_PORT, CA_FILE, CERT_FILE, KEY_FILE]
    if not all(required_vars):
        print("Error: Missing one or more required environment variables.")
        sys.exit(1)

    # Create an MQTT client instance
    client = mqtt.Client(
        callback_api_version=mqtt.CallbackAPIVersion.VERSION2
    )

    client.tls_set(
        ca_certs=CA_FILE
    )

    # Define callback functions
    def on_connect(client, userdata, flags, rc, properties=None):  # Added properties parameter
        if rc == 0:
            print("Connected to MQTT Broker successfully.")
            # Publish the message once connected
            result = client.publish(topic, message)
            status = result[0]
            if status == 0:
                print(f"Message '{message}' sent to topic '{topic}'.")
            else:
                print(f"Failed to send message to topic {topic}.")
            client.disconnect()
        else:
            print(f"Failed to connect, return code {rc}")

    # Assign callbacks
    client.on_connect = on_connect

    # Connect to the MQTT broker
    try:
        client.connect(MQTT_HOST, MQTT_PORT, keepalive=60)
    except Exception as e:
        print(f"Connection failed: {e}")
        sys.exit(1)

    # Start the network loop and wait for callbacks
    client.loop_forever()

if __name__ == "__main__":
    main("the_topic", "the_message")

================
File: python_client/mqtt_sub.py
================
import os
import ssl
import sys
from dotenv import load_dotenv
import paho.mqtt.client as mqtt

def main(topic: str, message: str):
    # Load environment variables from .env file
    load_dotenv()

    # Retrieve MQTT and SSL/TLS configurations from environment variables
    MQTT_HOST = os.getenv('MQTT_HOST')
    MQTT_PORT = int(os.getenv('MQTT_PORT', 8883))

    CA_FILE = os.getenv('CA_FILE')
    CERT_FILE = os.getenv('CERT_FILE')
    KEY_FILE = os.getenv('KEY_FILE')
    KEY_PASSPHRASE = os.getenv('KEY_PASSPHRASE')

    # Validate required parameters
    required_vars = [MQTT_HOST, MQTT_PORT, CA_FILE, CERT_FILE, KEY_FILE]
    if not all(required_vars):
        print("Error: Missing one or more required environment variables.")
        sys.exit(1)

    # Create an MQTT client instance
    client = mqtt.Client(
        callback_api_version=mqtt.CallbackAPIVersion.VERSION2
    )

    client.tls_set(
        ca_certs=CA_FILE
    )

    # Define callback functions
    def on_connect(client, userdata, flags, rc, properties=None):  # Added properties parameter
        if rc == 0:
            print("Connected to MQTT Broker successfully.")
            # Publish the message once connected
            result = client.publish(topic, message)
            status = result[0]
            if status == 0:
                print(f"Message '{message}' sent to topic '{topic}'.")
            else:
                print(f"Failed to send message to topic {topic}.")
            client.disconnect()
        else:
            print(f"Failed to connect, return code {rc}")

    # Assign callbacks
    client.on_connect = on_connect

    # Connect to the MQTT broker
    try:
        client.connect(MQTT_HOST, MQTT_PORT, keepalive=60)
    except Exception as e:
        print(f"Connection failed: {e}")
        sys.exit(1)

    # Start the network loop and wait for callbacks
    client.loop_forever()

if __name__ == "__main__":
    main("the_topic", "the_message")

================
File: servidor/easy-rsa/.github/workflows/action.yml
================
# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the action will run.
on:
  # Triggers the workflow on push or pull request events but only for the master branch
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  xtest:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    env:
      EASYRSA_BY_TINCANTECH: 1
      EASYRSA_REMOTE_CI: 1
      EASYRSA_NIX: 1
      TERM: xterm-256color
      EASYRSA_SILENT_SSL: 1

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: operational test
        run: sh op-test.sh -vv -sc -o3 -p

      # Runs a set of commands using the runners shell
      # - name: Run a multi-line script
      #    run: |
      #      echo Add other actions to build,
      #      echo test, and deploy your project.
      # This workflow contains a single job called "build"

  xtest_old:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    env:
      EASYRSA_BY_TINCANTECH: 1
      EASYRSA_REMOTE_CI: 1
      EASYRSA_NIX: 1
      TERM: xterm-256color
      EASYRSA_SILENT_SSL: 1
      EASYRSA_FORCE_SAFE_SSL: 1
      EASYRSA_LEGACY_SAFE_SSL: 1
      EASYRSA_VERBOSE: 1

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: operational test
        run: sh op-test.sh -vv -sc -o3 -p

      # Runs a set of commands using the runners shell
      # - name: Run a multi-line script
      #    run: |
      #      echo Add other actions to build,
      #      echo test, and deploy your project.
      # This workflow contains a single job called "build"

  wtest:
    # The type of runner that the job will run on
    runs-on: windows-latest

    env:
      EASYRSA_REMOTE_CI: 1
      EASYRSA_WIN: 1
      TERM: xterm-256color
      EASYRSA_SILENT_SSL: 1

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: cmd /c wop-test.bat

      # Runs a set of commands using the runners shell
      # - name: Run a multi-line script
      #    run: |
      #      echo Add other actions to build,
      #      echo test, and deploy your project.

  mtest:
    # The type of runner that the job will run on
    runs-on: macos-latest

    env:
      EASYRSA_REMOTE_CI: 1
      # Limit run to RSA and EC only, Libre does not do ED
      #LIBRESSL_LIMIT: 1
      EASYRSA_MAC: 1
      TERM: xterm-256color
      EASYRSA_SILENT_SSL: 1

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: sh op-test.sh -v -p

      # Runs a set of commands using the runners shell
      # - name: Run a multi-line script
      #    run: |
      #      echo Add other actions to build,
      #      echo test, and deploy your project.

================
File: servidor/easy-rsa/distro/windows/bin/easyrsa-shell-init.sh
================
#!/bin/sh
# shellcheck disable=SC2161,SC1091,SC2028

# This script is a frontend designed to create & launch a POSIX shell
# environment suitable for use with Easy-RSA. mksh/Win32 is used with this
# project; use with other POSIX shells for Windows may require modification to
# this wrapper script.

echo "Easy-RSA starting.."

setup_path="${EASYRSA:-$PWD}"
export PATH="$setup_path;$setup_path/bin;$PATH"
export HOME="$setup_path"

# This prevents reading from a user's .mkshrc if they have one.
# A user who runs mksh for other purposes might have it
export ENV="/disable-env"

# Verify required externals are present
extern_list="which awk cat cp mkdir printf rm"
for f in $extern_list; do
	if ! which "${f}.exe" >/dev/null 2>&1; then
		echo ""
		echo "FATAL: EasyRSA Shell init is missing a required external file:"
		echo "  ${f}.exe"
		echo "  Your installation is incomplete and cannot function without the required"
		echo "  files."
		echo ""
		#shellcheck disable=SC2162
		read -p "Press Enter or CTRL-C to exit."
		exit 1
	fi
done

# Allow options
non_admin=""
while [ "$1" ]; do
	case "$1" in
		/[Nn][Aa]|/no-adm*|--no-adm*)
			non_admin=1
			echo "Using no-admin mode"
		;;
		*)
			echo "Ignoring unknown option: '$1'"
	esac
	shift
done

# Access denied
access_denied() {
	echo "Access error: $1"
	echo "\
To use Easy-RSA in a protected system directory, you must have
full administrator privileges via Windows User Access Control."
	echo ""

	#shellcheck disable=SC2162
	read -p "Press Enter or CTRL-C to exit."
	exit 1
}

# Use home directory/easy-rsa
if [ "$non_admin" ]; then
	[ "${HOMEDRIVE}" ] || \
		access_denied "Undefined: HOMEDRIVE"
	user_home_drv="${HOMEDRIVE}"

	[ "${HOMEPATH}" ] || \
		access_denied "Undefined: HOMEPATH"
	eval "user_home_dir='\\${HOMEPATH}'"

	# shellcheck disable=SC2154 # user_home_dir is not assigned
	user_home="${user_home_drv}${user_home_dir}"

	[ -d "$user_home" ] || \
		access_denied "Missing: $user_home"

	cd "$user_home" 2>/dev/null || \
		access_denied "Access: $user_home"

	if [ ! -d easy-rsa ]; then
		mkdir easy-rsa 2>/dev/null || \
			access_denied "mkdir: easy-rsa"
		# Required test
		[ -d easy-rsa ] || \
			access_denied "Missing: easy-rsa"
	fi

	cd easy-rsa 2>/dev/null || \
		access_denied "Access: easy-rsa"

	export HOME="$PWD"
	export PATH="$HOME;$PATH"
	unset -v user_home_drv user_home_dir user_home
fi

# Check for broken administrator access
# https://github.com/OpenVPN/easy-rsa/issues/1072
[ -d "$HOME" ] || access_denied "-d HOME"
win_tst_d="$HOME"/easyrsa-write-test

# Required tests
mkdir "$win_tst_d" 2>/dev/null || access_denied "mkdir"
[ -d "$win_tst_d" ] || access_denied "-d"
echo 1 >"$win_tst_d"/1 2>/dev/null || access_denied "write"
[ -f "$win_tst_d"/1 ] || access_denied "-f"
rm -rf "$win_tst_d" 2>/dev/null || access_denied "rm"
[ ! -d "$win_tst_d" ] || access_denied "! -d"
unset -v win_tst_d
unset -f access_denied

# set_var is defined as any vars file needs it.
# This is the same as in easyrsa, but we _don't_ export
set_var() {
        var="$1"
        shift
        value="$*"
        eval "$var=\"\${$var-$value}\""
} #=> set_var()

# Check for a usable openssl bin, referencing vars if present
[ -r "vars" ] && EASYRSA_CALLER=1 . "vars" 2>/dev/null
if [ -z "$EASYRSA_OPENSSL" ] && ! which openssl.exe >/dev/null 2>&1; then
	echo "WARNING: openssl isn't in your system PATH. The openssl binary must be"
	echo "  available in the PATH, defined in the 'vars' file, or defined in a"
	echo "  named environment variable. See README-Windows.txt for more info."
fi

[ -f "$setup_path/easyrsa" ] || {
	echo "Missing easyrsa script. Expected to find it at: $setup_path/easyrsa"
	read -p "Press Enter or CTRL-C to exit."
	exit 2
}

# Set prompt and welcome message
export PS1='
EasyRSA Shell
# '
echo ""
echo "Welcome to the EasyRSA 3 Shell for Windows."
echo "Easy-RSA 3 is available under a GNU GPLv2 license."
echo ""
echo "Invoke 'easyrsa' to call the program. Without commands, help is displayed."
echo ""
echo "Using directory: $HOME"
echo ""

# Drop to a shell and await input
sh.exe

================
File: servidor/easy-rsa/distro/windows/Licensing/LICENSE-OpenSSL.txt
================
LICENSE ISSUES
  ==============

  The OpenSSL toolkit stays under a double license, i.e. both the conditions of
  the OpenSSL License and the original SSLeay license apply to the toolkit.
  See below for the actual license texts.

  OpenSSL License
  ---------------

/* ====================================================================
 * Copyright (c) 1998-2018 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@cryptsoft.com).
 *
 */

 Original SSLeay License
 -----------------------

/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscape's SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are adhered to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the routines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publicly available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

================
File: servidor/easy-rsa/distro/windows/Licensing/mksh-Win32.txt
================
Licence
-------

mksh/Win32 is a derived work of The MirBSD Korn Shell and
recognised by The MirOS Project but realised by an independent
developer with support and legal permit by Scalaris AG.


The shell itself comes under The MirOS Licence:

Copyright (c) 2002-2013
	The MirOS Project
Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
	Thorsten Glaser <tg@mirbsd.org>
Copyright (c) 2010, 2011, 2012, 2013
	Michael Langguth <lan@scalaris.com>

Provided that these terms and disclaimer and all copyright notices
are retained or reproduced in an accompanying document, permission
is granted to deal in this work without restriction, including un-
limited rights to use, publicly perform, distribute, sell, modify,
merge, give away, or sublicence.

This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
the utmost extent permitted by applicable law, neither express nor
implied; without malicious intent or gross negligence. In no event
may a licensor, author or contributor be held liable for indirect,
direct, other damage, loss, or other issues arising in any way out
of dealing in the work, even if advised of the possibility of such
damage or existence of a defect, except proven that it results out
of said person's immediate fault when using the work as intended.


The shell contains strlcpy() under the ISC licence:

Copyright (c) 2006, 2008, 2009
	Thorsten Glaser <tg@mirbsd.org>
Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>

Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


This version of the shell contains setmode() under the UCB BSD licence:

Copyright (c) 1989, 1993, 1994
	The Regents of the University of California.  All rights reserved.

This code is derived from software contributed to Berkeley by
Dave Borman at Cray Research, Inc.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the University nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.


The shell includes nedmalloc under the Boost Software License which,
in turn, includes dlmalloc under CC0 (eventually) in its binary.


The "liblan" portability library is covered by The MirOS Licence:

Copyright (c) 1996, 1998, 2003, 2004, 2005, 2010, 2011, 2012, 2013
	Scalaris AG, Author: Michael Langguth <lan@scalaris.com>

Provided that these terms and disclaimer and all copyright notices
are retained or reproduced in an accompanying document, permission
is granted to deal in this work without restriction, including un-
limited rights to use, publicly perform, distribute, sell, modify,
merge, give away, or sublicence.

This work is provided "AS IS" and WITHOUT WARRANTY of any kind, to
the utmost extent permitted by applicable law, neither express nor
implied; without malicious intent or gross negligence. In no event
may a licensor, author or contributor be held liable for indirect,
direct, other damage, loss, or other issues arising in any way out
of dealing in the work, even if advised of the possibility of such
damage or existence of a defect, except proven that it results out
of said person's immediate fault when using the work as intended.


It includes an implementation of POSIX directory browsing functions
and types for Win32 under a Historical Permission Notice variant:

Copyright Kevlin Henney, 1997, 2003. All rights reserved.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose is hereby granted without fee, provided
that this copyright and permissions notice appear in all copies and
derivatives.

This software is supplied "as is" without express or implied warranty.

But that said, if there are any problems please get in touch.


The program shortcut (mkshicon1.ico) is an unregistered trademark:

Copyright (c) 2013 Michael Langguth
Copyright (c) 2006 Benny Siegert
Copyright (c) 2005 Thorsten Glaser

This icon may be used to refer to The MirBSD Korn Shell and
its Win32 port. Distribution patches are acceptable as long
as they modify $KSH_VERSION according to the guidelines that
are published on the website; forks and works that are not
derivatives are not allowed to use it.

The BSD daemon is Copyright (c) 1988 by Marshall Kirk McKusick.
All Rights Reserved.  Individuals may use the daemon for their
personal use within the bounds of good taste.  When reasonably
possible, the text shown above is to be included.

The Shilouette daemon is Copyright (c) 2003 by Rick Collette.
The MirOS Project may freely use the former ekkoBSD Logo,
the shilouette Daemon, for MirBSD, on anything the project
leader sees fit, so long as it pertains to MirBSD in some
way and the leader gives credit for the original daemon to
Marshall Kirk McKusick.

================
File: servidor/easy-rsa/distro/windows/EasyRSA-Start.bat
================
@echo OFF
bin\sh.exe bin\easyrsa-shell-init.sh %*

================
File: servidor/easy-rsa/distro/windows/README-Windows.txt
================
Easy-RSA 3 Windows README

Easy-RSA 3 runs POSIX shell code, so use on Windows has some additional
requirements: an OpenSSL installation, and a usable shell environment.

The Windows packages of EasyRSA 3.0.7+ include an OpenSSL binary and
libraries that will be used by default.  If you want to use a system binary
instead, remove the openssl.exe and the lib*.dll files from the bin
directory.

The Easy-RSA Windows release includes a ready-to-use shell
environment with special thanks to the mksh/Win32 project.

Contents of this file:
  1. OpenSSL
  2. shell environment
  3. Windows paths
  4. Appendix:
   4.1: reference links
   4.2: license of included components
  5. Special Thanks
   5.1: mksh/Win32

1. Getting a POSIX shell

   The binary release of Easy-RSA 3 comes bundled with the mksh/Win32 shell
   environment and a handful of shell utility programs from the unxutils
   project. This is the easiest way to get a usable shell environment.

   (A) Using the mksh/Win32 shell

       With the Windows binary Easy-RSA download, all the necessary utilities
       are already present. Starting a shell environment is accomplished by
       running the `EasyRSA Start.bat` file.

       A basic collection of shell utilities is included, such as ls, cat, mv,
       and so on. Additional programs can be manually installed from the
       unxutils project (link in appendix); this is intentionally a limited set
	   of programs since most Windows users will use native methods to perform
       filesystem manipulation.

   (B) Using a full POSIX environment (Advanced users only)

       An environment such as Cygwin can provide the necessary POSIX environment
       for the Easy-RSA shell code to run. However, Cygwin paths are not usable
       by native Win32 applications. This means that the OpenSSL installation
       used must also understand Cygwin paths or command calls will fail.
       Provided this requirement is met, Cygwin can directly run the easyrsa
       script without any special interpreter or startup wrapper.

2. Windows Paths

   The provided mksh/Win32 shell understands Windows paths. However, you MUST
   either:

   * Use forward slashes instead of single backslashes, or
   * Use double-backslashes.

   This means the following path formats are accepted:

    "C:/Program Files/OpenSSL-Win32/bin/openssl.exe"
    "C:\\Program Files\\OpenSSL-Win32\\bin\\openssl.exe"

   This is primarily to reference a functioning OpenSSL installation (see
   section 1 above) but applies to any other paths used in env-vars, the `vars`
   file, or in shell commands such as ls, cd, and so on.

3. Appendix

 3.1: Reference Links

   * OpenSSL website:
     https://www.openssl.org

   * OpenSSL binary distribution links:
     https://www.openssl.org/related/binaries.html

   * OpenSSL download page, built by "Shining Light Productions"
     http://slproweb.com/products/Win32OpenSSL.html

     NOTE: if using the "Shining Light Productions" version, the "Light"
     download is fine. 32 or 64-bit is also OK (if you have a 64-bit OS.)

   * UnxUtils project:
     http://sourceforge.net/projects/unxutils

 3.2: License of included components

      Text-format copies of these licenses are available in the Licensing/
      directory.

   (A) Easy-RSA 3 is released under a GPLv2 license:
       https://www.gnu.org/licenses/gpl-2.0.html

   (B) mksh/Win32 is under a MirOS license:
       https://www.mirbsd.org/MirOS-Licence.htm

       Additional library components of mksh/Win32 are covered under additional
       licenses. See Licensing/mksh-Win32.txt for details.

   (C) unxutils is released under a GPLv2 license
       The full source for this win32 port can be found here:
       http://sourceforge.net/projects/unxutils/

4. Special Thanks

 4.1: mksh/Win32

    A special thanks is in order to the mksh/Win32 project and its primary
    maintainer, Michael Langguth <mksh-w32@gmx.net>. This shell offers features
    that allow Easy-RSA to run smoothly under Windows; by using mksh/Win32,
    Easy-RSA can deliver the same PKI flexibility to all major platforms.

vim: wrap tw=80 expandtab

================
File: servidor/easy-rsa/distro/README
================
This distro/ directory contains distro/platform specific tools.

Components that are not platform neutral end up here, sorted into further dirs
based on the platform.

================
File: servidor/easy-rsa/doc/EasyRSA-Advanced.md
================
Easy-RSA Advanced Reference
=============================

This is a technical reference for advanced users familiar with PKI processes. If
you need a more detailed description, see the `EasyRSA-Readme` or `Intro-To-PKI`
docs instead.

Configuration Reference
-----------------------

#### Configuration Sources

  There are 3 possible ways to perform external configuration of Easy-RSA,
  selected in the following order where the first defined result wins:

  1. Command-line option
  2. Environmental variable
  3. 'vars' file, if one is present (see `vars Autodetection` below)
  4. Built-in default

  Note that not every possible config option can be set everywhere, although any
  env-var can be added to the 'vars' file even if it's not shown by default.

#### vars Autodetection

  A 'vars' file is a file named simply `vars` (without an extension) that
  Easy-RSA will source for configuration. This file is specifically designed
  *not* to replace variables that have been set with a higher-priority method
  such as CLI opts or env-vars.

  The following locations are checked, in this order, for a vars file. Only the
  first one found is used:

  1. The file referenced by the `--vars` CLI option
  2. The file referenced by the env-var named `EASYRSA_VARS_FILE`
  3. The directory referenced by the `--pki` CLI option (Recommended)
  4. The directory referenced by the `EASYRSA_PKI` env-var
  5. The directory referenced by the `EASYRSA` env-var
  6. The default PKI directory at `$PWD/pki` (See note below)
  7. The default working directory at `$PWD`

  Defining the env-var `EASYRSA_NO_VARS` will override the sourcing of the vars
  file in all cases, including defining it subsequently as a global option.

  Note: If the vars file `$PWD/pki/vars` is sourced then it is forbidden from
        setting/changing the current PKI, as defined by `EASYRSA_PKI` env-var.

#### Use of `--pki` verses `--vars`

  It is recommended to use option `--pki=DIR` to define your PKI at runtime.
  This method will always auto-load the `vars` file found in defined PKI.

  In a multi-PKI installation, use of `--vars` can potentially lead to
  a vars file that is configured to set a PKI which cannot be verified
  as the expected PKI. Use of `--vars` is not recommended.

#### OpenSSL Config

  Easy-RSA is tightly coupled to the OpenSSL config file (.cnf) for the
  flexibility the script provides. It is required that this file be available,
  yet it is possible to use a different OpenSSL config file for a particular
  PKI, or even change it for a particular invocation.

  The OpenSSL config file is searched for in the following order:

  1. The env-var `EASYRSA_SSL_CONF`
  2. The 'vars' file (see `vars Autodetection` above)
  3. The `EASYRSA_PKI` directory with a filename of `openssl-easyrsa.cnf`
  4. The `EASYRSA` directory with a filename of `openssl-easyrsa.cnf`

Advanced extension handling
---------------------------

Normally the cert extensions are selected by the cert type given on the CLI
during signing; this causes the matching file in the x509-types subdirectory to
be processed for OpenSSL extensions to add. This can be overridden in a
particular PKI by placing another x509-types dir inside the `EASYRSA_PKI` dir
which will be used instead.

The file named `COMMON` in the x509-types dir is appended to every cert type;
this is designed for CDP usage, but can be used for any extension that should
apply to every signed cert.

Additionally, the contents of the env-var `EASYRSA_EXTRA_EXTS` is appended with
its raw text added to the OpenSSL extensions. The contents are appended as-is to
the cert extensions; invalid OpenSSL configs will usually result in failure.

Advanced configuration files
----------------------------

The following files are used by Easy-RSA to configure the SSL library:
* openssl-easyrsa.cnf - Configuration for Certificate Authority [CA]
* x509-types: COMMON, ca, server, serverClient, client, codeSigning, email, kdc.
  Each type is used to define an X509 purpose.

Since Easy-RSA version 3.2.0, these files are created on-demand by each command
that requires them.  However, if these files are found in one of the supported
locations then those files are used instead, no temporary files are created.

The supported locations are listed, in order of preference, as follows:
* `EASYRSA_PKI` - Always preferred.
* `EASYRSA` - For Windows.
* `PWD` - For Windows.
* `easyrsa` script directory - DEPRECATED, will be removed. Only for Windows.
* `/usr/local/share/easy-rsa`
* `/usr/share/easy-rsa`
* `/etc/easy-rsa`

The files above can all be created by using command: `easyrsa write legacy <DIR>`
To OVER-WRITE any existing files use command: `eaysrsa write legacy-hard <DIR>`
`<DIR>` is optional, the default is `EASYRSA_PKI`. This will create the files in
the current PKI or `<DIR>`.  If created then these new files may take priority
over system wide versions of the same files.  See `help write` for further details.

Note, Over-writing files:
Only command `write legacy-hard` will over-write files. All other uses of `write`
will leave an existing file intact, without error. If you want to over-write an
existing file using `write` then you must redirect `>foo` the output manually.

Example command: `easyrsa write vars >vars` - This will over-write `./vars`.

Environmental Variables Reference
---------------------------------

A list of env-vars, any matching global option (CLI) to set/override it, and a
short description is shown below:

 *  `EASYRSA` - should point to the Easy-RSA top-level dir, where the easyrsa
    script is located.
 *  `EASYRSA_OPENSSL` - command to invoke openssl
 *  `EASYRSA_SSL_CONF` - the openssl config file to use
 *  `EASYRSA_PKI` (CLI: `--pki-dir`) - dir to use to hold all PKI-specific
    files, defaults to `$PWD/pki`.
 *  `EASYRSA_VARS_FILE` (CLI: `--vars`) - Set the `vars` file to use
 *  `EASYRSA_DN` (CLI: `--dn-mode`) - set to the string `cn_only` or `org` to
    alter the fields to include in the req DN
 *  `EASYRSA_REQ_COUNTRY` (CLI: `--req-c`) - set the DN country with org mode
 *  `EASYRSA_REQ_PROVINCE` (CLI: `--req-st`) - set the DN state/province with
    org mode
 *  `EASYRSA_REQ_CITY` (CLI: `--req-city`) - set the DN city/locality with org
    mode
 *  `EASYRSA_REQ_ORG` (CLI: `--req-org`) - set the DN organization with org mode
 *  `EASYRSA_REQ_EMAIL` (CLI: `--req-email`) - set the DN email with org mode
 *  `EASYRSA_REQ_OU` (CLI: `--req-ou`) - set the DN organizational unit with org
    mode
 *  `EASYRSA_REQ_SERIAL` (CLI: `--req-serial`) - set the DN serialNumber with
    org mode (OID 2.5.4.5)
 *  `EASYRSA_KEY_SIZE` (CLI: `--keysize`) - set the key size in bits to
    generate
 *  `EASYRSA_ALGO` (CLI: `--use-algo`) - set the crypto alg to use: rsa, ec or
    ed
 *  `EASYRSA_CURVE` (CLI: `--curve`) - define the named EC curve to use
 *  `EASYRSA_CA_EXPIRE` (CLI: `--days`) - set the CA expiration time in days
 *  `EASYRSA_CERT_EXPIRE` (CLI: `--days`) - set the issued cert expiration time
    in days
 *  `EASYRSA_CRL_DAYS` (CLI: `--days`) - set the CRL 'next publish' time in days
 *  `EASYRSA_NS_SUPPORT` (CLI: `--ns-cert`) - string 'yes' or 'no' fields to
    include the **deprecated** Netscape extensions
 *  `EASYRSA_NS_COMMENT` (CLI: `--ns-comment`) - string comment to include when
    using the **deprecated** Netscape extensions
 *  `EASYRSA_REQ_CN` (CLI: `--req-cn`) - default CN, can only be used in BATCH
    mode
 *  `EASYRSA_DIGEST` (CLI: `--digest`) - set a hash digest to use for req/cert
    signing
 *  `EASYRSA_BATCH` (CLI: `--batch`) - enable batch (no-prompt) mode; set
    env-var to non-zero string to enable (CLI takes no options)
 *  `EASYRSA_PASSIN` (CLI: `--passin`) - allows to specify a source for
    password using any openssl password options like pass:1234 or env:var
 *  `EASYRSA_PASSOUT` (CLI: `--passout`) - allows to specify a source for
    password using any openssl password options like pass:1234 or env:var
 *  `EASYRSA_NO_PASS` (CLI: `--nopass`) - disable use of passwords
 *  `EASYRSA_UMASK` - safe umask to use for file creation. Defaults to `077`
 *  `EASYRSA_NO_UMASK` - disable safe umask. Files will be created using the
    system's default
 *  `EASYRSA_TEMP_DIR` (CLI: `--tmp-dir`) - a temp directory to use for temporary files
**NOTE:** the global options must be provided before the commands.

================
File: servidor/easy-rsa/doc/EasyRSA-Contributing.md
================
Easy-RSA 3 GitHub Contributions Documentation
=============================================

This document explains how to contribute to Easy-RSA 3.

Please follow these simple steps and make contributing easier.

Intended audience: Everyone.

Contributing Guide
------------------

-   **Do not** edit Easy-RSA `master` branch.

-   **Do not** edit Easy-RSA `master` branch.

    Pull Requests submitted from `master` branch may be squashed or rejected.

### Create a new branch:

-   Select a suitable name for the new branch. eg: `doc-contrib-typo`

    ```
    git checkout -b doc-contrib-typo
    ```

-   Make changes to the new branch.

    Please use tabs to indent the code but only use tabs at the beginning of
    the line.

-   Review the changes:

    ```
    git diff
    ```

-   Stage the changes:

    ```
    git add -A
    ```

-   Show the extent of the changes:

    ```
    git status -v
    ```

-   Commit the changes:

    ```
    git commit -sS
    ```

    Please write a detailed commit message.

    github `help` has details of creating a private key.

    Using github `no-reply` email address is suitable for the `Signed-off-by:`
    line.

-   Push the changes:

    ```
    git push origin doc-contrib-typo
    ```

-   Share the changes:

    ```
    Raise a Pull Request on github.
    ```

Keeping your fork synchronised
-----------------------------

-   Configure the `upstream` remote for your fork:

    ```
    git remote add upstream https://github.com/OpenVPN/easy-rsa.git
    ```

-   Verify the remote sources:

    ```
    git remote -v
    ```

    Remote `origin` will have **your** repository:

    ```
    origin https://github.com/TinCanTech/easy-rsa.git (fetch)
    origin https://github.com/TinCanTech/easy-rsa.git (push)
    ```

    Remote `upstream` will be `Openvpn/easy-rsa`:

    ```
    upstream https://github.com/Openvpn/easy-rsa.git (fetch)
    upstream https://github.com/Openvpn/easy-rsa.git (push)
    ```

### Synchronising your fork:

-   Select `master` branch:

    ```
    git checkout master
    ```

-   Fetch changes in `upstream`:

    ```
    git fetch upstream
    ```

-   Merge changes in `upstream`:

    ```
    git merge upstream/master
    ```

-   Update your fork on github:

    ```
    git push
    ```


    Your fork is now synchronised.

================
File: servidor/easy-rsa/doc/EasyRSA-Readme.md
================
Easy-RSA 3 Documentation Readme
===============================

This document explains how Easy-RSA 3 and each of its assorted features work.

If you are looking for a quickstart with less background or detail, an
implementation-specific How-to or Readme may be available in this (the [`doc/`](./))
directory.

Easy-RSA Overview
-----------------

Easy-RSA is a utility for managing X.509 PKI, or Public Key Infrastructure. A
PKI is based on the notion of trusting a particular authority to authenticate a
remote peer; for more background on how PKI works, see the [Intro-To-PKI](Intro-To-PKI.md)
document.

The code is written in platform-neutral POSIX shell, allowing use on a wide
range of host systems. The official Windows release also comes bundled with the
programs necessary to use Easy-RSA. The shell code attempts to limit the number
of external programs it depends on. Crypto-related tasks use openssl as the
functional backend.

Feature Highlights
------------------

Here's a non-exhaustive list of the more notable Easy-RSA features:

 *  Easy-RSA is able to manage multiple PKIs, each with their own independent
    configuration, storage directory, and X.509 extension handling.
 *  Multiple Subject Name (X.509 DN field) formatting options are supported. For
    VPNs, this means a cleaner commonName only setup can be used.
 *  A single backend is used across all supported platforms, ensuring that no
    platform is 'left out' of the rich features. Unix-alikes (BSD, Linux, etc)
    and Windows are all supported.
 *  Easy-RSA's X.509 support includes CRL, CDP, keyUsage/eKu attributes, and
    additional features. The included support can be changed or extended as an
    advanced feature.
 *  Interactive and automated (batch) modes of operation
 *  Flexible configuration: features can be enabled through command-line
    options, environment variables, a config file, or a combination of these.
 *  Built-in defaults allow Easy-RSA to be used without first editing a config
    file.

Obtaining and Using Easy-RSA
----------------------------

#### Download and extraction (installation)

  Easy-RSA's main program is a script, supported by a couple of config files. As
  such, there is no formal "installation" required. Preparing to use Easy-RSA is
  as simple as downloading the compressed package (.tar.gz for Linux/Unix or
  .zip for Windows) and extract it to a location of your choosing. There is no
  compiling or OS-dependent setup required.

  You should install and run Easy-RSA as a non-root (non-Administrator) account
  as root access is not required.

#### Running Easy-RSA

  Invoking Easy-RSA is done through your preferred shell. Under Windows, you
  will use the `EasyRSA Start.bat` program to provide a POSIX-shell environment
  suitable for using Easy-RSA.

  The basic format for running commands is:

    ./easyrsa command [ cmd-opts ]

  where `command` is the name of a command to run, and `cmd-opts` are any
  options to supply to the command. Some commands have mandatory or optional
  cmd-opts. Note the leading `./` component of the command: this is required in
  Unix-like environments and may be a new concept to some Windows users.

  General usage and command help can be shown with:

    ./easyrsa help [ command ]

  When run without any command, general usage and a list of available commands
  are shown; when a command is supplied, detailed help output for that command
  is shown.

Configuring Easy-RSA
--------------------

Easy-RSA 3 no longer needs any configuration file prior to operation, unlike
earlier versions. However, the `vars.example` file contains many commented
options that can be used to control non-default behavior as required. Reading
this file will provide an idea of the basic configuration available. Note that
a vars file must be named just `vars` (without an extension) to actively use it.

Additionally, some options can be defined at runtime with options on the
command-line. A full list can be shown with:

    ./easyrsa help options

Any of these options can appear before the command as required as shown below:

    ./easyrsa [options] command [ cmd-opts ]

For experts, additional configuration with env-vars and custom X.509 extensions
is possible. Consult the [EasyRSA-Advanced](EasyRSA-Advanced.md) documentation for details.

Getting Started: The Basics
---------------------------

Some of the terms used here will be common to those familiar with how PKI works.
Instead of describing PKI basics, please consult the document [Intro-To-PKI](Intro-To-PKI.md) if
you need a more basic description of how a PKI works.

#### Creating an Easy-RSA PKI

  In order to do something useful, Easy-RSA needs to first initialize a
  directory for the PKI. Multiple PKIs can be managed with a single installation
  of Easy-RSA, but the default directory is called simply "pki" unless otherwise
  specified.

  To create or clear out (re-initialize) a new PKI, use the command:

    ./easyrsa init-pki

  which will create a new, blank PKI structure ready to be used. Once created,
  this PKI can be used to make a new CA or generate keypairs.

#### The PKI Directory Structure

  An Easy-RSA PKI contains the following directory structure:

  * `private/` - dir with private keys generated on this host
  * `reqs/` - dir with locally generated certificate requests (for a CA imported
    requests are stored here)

  In a clean PKI no files exist yet, just the bare directories. Commands called
  later will create the necessary files depending on the operation.

  When building a CA, a number of new files are created by a combination of
  Easy-RSA and (indirectly) openssl. The important CA files are:

  * `ca.crt` - This is the CA certificate
  * `index.txt` - This is the "master database" of all issued certs
  * `serial` - Stores the next serial number (serial numbers increment)
  * `private/ca.key` - This is the CA private key (security-critical)
  * `certs_by_serial/` - dir with all CA-signed certs by serial number
  * `issued/` - dir with issued certs by commonName

#### After Creating a PKI

  Once you have created a PKI, the next useful step will be to either create a
  CA, or generate keypairs for a system that needs them. Continue with the
  relevant section below.

Using Easy-RSA as a CA
----------------------

#### Building the CA

  In order to sign requests to produce certificates, you need a CA. To create a
  new CA in the PKI you have created, run:

    ./easyrsa build-ca

  Be sure to use a strong passphrase to protect the CA private key. Note that
  you must supply this passphrase in the future when performing signing
  operations with your CA, so be sure to remember it.

  During the creation process, you will also select a name for the CA called the
  Common Name (CN.) This name is purely for display purposes and can be set as
  you like.

#### Importing requests to the CA

  Once a CA is built, the PKI is intended to be used to import requests from
  external systems that are requesting a signed certificate from this CA. In
  order to sign the request, it must first be imported so Easy-RSA knows about
  it. This request file must be a standard CSR in PKCS#10 format.

  Regardless of the file name to import, Easy-RSA uses a "short name" defined
  during import to refer to this request. Importing works like this:

    ./easyrsa import-req /path/to/request.req nameOfRequest

  The nameOfRequest should normally refer to the system or person making the
  request.

#### Signing a request

  Once Easy-RSA has imported a request, it can be reviewed and signed:

    ./easyrsa sign-req <type> nameOfRequest

  Every certificate needs a `type` which controls what extensions the certificate
  gets.

  Easy-RSA ships with 4 possible "types":

  * `client` - A TLS client, suitable for a VPN user or web browser (web client)
  * `server` - A TLS server, suitable for a VPN or web server
  * `ca` - A intermediate CA, used when chaining multiple CAs together
  * `serverClient` - A TLS server and TLS client

  Additional types of certs may be defined by local sites as needed; see the
  advanced documentation for details.

#### Revoking and publishing Certificate Revocation Lists (CRLs)

  If an issue certificate needs to be revoked, this can be done as follows:

    ./easyrsa revoke nameOfRequest

  To generate a CRL suitable for publishing to systems that use it, run:

    ./easyrsa gen-crl

  Note that this will need to be published or sent to systems that rely on an
  up-to-date CRL as the certificate is still valid otherwise.

Using Easy-RSA to generate keypairs & requests
----------------------------------------------

Easy-RSA can generate a keypair and certificate request in PKCS#10 format. This
request is what a CA needs in order to generate and return a signed certificate.

Ideally you should never generate entity keypairs for a client or server in a
PKI you are using for your CA. It is best to separate this process and generate
keypairs only on the systems you plan to use them.

Easy-RSA can generate a keypair and request with the following command:

    ./easyrsa gen-req nameOfRequest

You will then be given a chance to modify the Subject details of your request.
Easy-RSA uses the short name supplied on the command-line by default, though you
are free to change it if necessary. After providing a passphrase and Subject
details, the keypair and request files will be shown.

In order to obtain a signed certificate, the request file must be sent to the
CA for signing; this step is obviously not required if a single PKI is used as
both the CA and keypair/request generation as the generated request is already
"imported."

================
File: servidor/easy-rsa/doc/EasyRSA-Renew-and-Revoke.md
================
Easy-RSA 3 Certificate Renewal and Revocation Documentation
===========================================================

This document explains how the **differing versions** of Easy-RSA 3 work
with regard to Renewal and Revocation of Certificates.

## In summary:

**Easy-RSA Version 3.1.7** provides the most flexible support of renewal.
This includes command `rewind-renew`, which is required to recover certificates
renewed by `renew` command version 1. However, this does **not** include renewing
any supported certificate attributes.

**Easy-RSA Version 3.2.1** is preferred for future support.

----

Reason codes available for revoke commands
------------------------------------------

The follow is an exhaustive list of available `reason` codes, with abbreviations:

- `us | uns* | unspecified`
- `kc | key* | keyCompromise`
- `cc | ca*  | CACompromise`
- `ac | aff* | affiliationChanged`
- `ss | sup* | superseded`
- `co | ces* | cessationOfOperation`
- `ch | cer* | certificateHold`

  `reason` must be one of these abbreviations/codes, otherwise not be used.

----

Easy-RSA version 3.2.x
======================
For **Easy-RSA Version 3.2.0**, command `renew` is NOT supported.

Please upgrade to Easy-RSA Version 3.2.1

For **Easy-RSA Version 3.2.1+**, command `renew` is supported.

The command `renew` has been rewritten and now supports the renewal of
supported attributes. During renewal, the certificate is inspected and all
supported attributes are applied to the renewed certificate, as they were
in the original.

User added attributes from `$EASYRSA_EXTRA_EXTS`, that are not supported,
are dropped.

If the renewed certificate requires unsupported attibutes or changing the
`commonName` then the following process, that of expiry and then signing a
new certificate from the original request file, is required.

The expiry and signing process is as follows:
1. Command `expire <NAME>`

   This will move an existing certificate from `pki/issued` to `pki/expired`,
   so that a new certificate can be signed, using the original request.

   Generally, renewing is required ONLY when a certificate is due to expire.
   This means that certificates moved to `pki/expired` are expected to be expired
   or to expire in the near future, however, this is not a requirement.

2. Command `sign-req <TYPE> <NAME>`

   Sign a new certificate. This allows ALL command line customisations to be used.

3. If required, command `revoke-expired` can be used to revoke an
   expired certificate in the `pki/expired` directory.

This approach allows original certificates, which have been edited during `sign-req`,
to be edited the same way.

----

Easy-RSA version 3.1.x
======================

Command Details: `renew`
------------------------

    easyrsa renew file-name-base [ cmd-opts ]

`renew` is **only** available since Easy-RSA version `3.0.6`

#### `renew` has three different versions:

 *  `renew` **Version 1**: Easy-RSA versions `3.0.6`, `3.0.7` and `3.0.8`.
    - Both certificate and private key are rebuilt.
    - Once a certificate has been renewed it **cannot** be revoked.

 *  `renew` **Version 2**: Easy-RSA versions `3.0.9` and `3.1.0`.
    - Both certificate and private key are rebuilt.
    - Once a certificate has been renewed it **can** be revoked.
    - Use command:

        `revoke-renewed file-name-base [ reason ]`

 *  `renew` **Version 3**: Easy-RSA versions `3.1.1` through `3.1.7`.
    - Only certificate is renewed.
    - The original `renew` command has been renamed to `rebuild`, which
      rebuilds both certificate and private key.

 *  `renew` **Version 4**: Easy-RSA version `3.2.0+`.
    - Only certificate is renewed.
    - Supports standard Easy-RSA X509 extension duplication.


Resolving issues with `renew` version 1
---------------------------------------

#### Upgrade Easy-RSA to version `3.1.1+` is required.

`renew` version 1 **rebuilds** the certificate and private key.

Once a certificate has been renewed by version 1, the files are saved in the
`renewed/` storage area by `serialNumber`. These files must be recovered by
using command:

    easyrsa rewind-renew serialNumber

Command `rewind-renew` is only available in Easy-RSA version `3.1.1` to `3.1.7`.

Once `rewind-renew` has recovered the files, the certificate can be revoked:

    easyrsa revoke-renewed file-name-base [ reason ]


Using `renew` version 2
-----------------------

#### Upgrade Easy-RSA to version `3.1.1+` is required.

`renew` version 2 **rebuilds** the certificate and private key.

Renewed certificate can be revoked:

    easyrsa revoke-renewed file-name-base [ reason ]


Using `renew` version 3
-----------------------

#### Upgrade Easy-RSA to version `3.1.1+` is required.

`renew` version 3 **renews** the certificate only.

Renewed certificate can be revoked:

    easyrsa revoke-renewed file-name-base [ reason ]

This is the preferred method to renew a certificate because the original
private key is still valid.

Using `renew` version 4
-----------------------

#### Upgrade Easy-RSA to version `3.2.0+` is required.

This is the most comprensive version of `renew`, which supports automatic
copying of Easy-RSA X509 extensions.


----

Easy-RSA Reporting tools for certificate status
-----------------------------------------------

Easy-RSA version `3.1.x`, also has the following tools to keep track of
certificate status:

    easyrsa [ --days=# ] show-expire [ file-name-base ]

  `show-expire` shows all certificates which will expire in given `--days`.

    easyrsa show-renew [ file-name-base ]

  `show-renew` shows all certificates which have been renewed, where the old
  certificate has not been revoked.

    easyrsa show-revoke [ file-name-base ]

  `show-revoke` shows all certificates which have been revoked.

----

About command `rebuild`
-----------------------

If `rebuild` is used then the output directory of old certificate, key and
request is also the `renewed` directory.  Use **`revoke-renewed`** to revoke
an old certificate/key pair, which has been _rebuilt_ by command `rebuild`.

----

Renew CA Certificate
====================

Easy-RSA Version `3.2.2+ includes command `renew-ca`, which will create a new
CA certificate using the original CA key.  This new certificate will completely
replace the previous CA certificate.  This command can be safely tested without
disturbing your current PKI. The command requires user confirmation before
installing the new CA certificate.  The old CA certificate is archived to the
file 'pki/expired-ca.list'.


Easy-RSA Version `3.2.1+` supports a simple way to effectively renew a CA Certificate.

**Preamble** - Specifically for use with OpenVPN:

When a CA certificate expires it must be replaced, this is unavoidable.
No matter what method is used to create a new or renewed CA certificate,
that CA certificate must be distributed to all of your servers and clients.

Please consider the method outlined here, which requires very little work:

1. **Before you do anything else -- Make a BACKUP of your current PKI.**

2. Use command `init-pki soft`

   This will reset your current PKI but will keep your `vars` setting file
   and your current Request files [CSR], in the `pki/reqs` directory.

   If you have an Easy-RSA generated TLS key for OpenVPN, that will also be
   preserved. However, it will NOT be used for new `inline` files. The file
   `pki/private/easyrsa-tls.key` will be moved to `pki/easyrsa-keepsafe-tls.key`,
   for safe keeping. Easy-RSA will display a warning that this key is still
   valid and possibly in use, before allowing another TLS key to be generated.

3. Use command `build-ca`

   (With or without password and other preferences)

   This will build a completely new CA Certificate and private key.

   Use option `--days` to extend the lifetime of your new CA.

4. Use command `sign-req <TYPE> <NAME>`

   (With or without other preferences, password is not relevant)

   This will use an existing Request to sign a new Certificate.

   This will NOT generate a new Private Key for each new Certificate.

   This will generate new `inline` files that can be distributed publicly.
   These `inline` files will not contain any security sensitive data.

   This means that you will have a new CA certificate and private key.
   And signed certificates for all of your users, including servers.

5. Distribute the new `inline` files to all members of your PKI/VPN.

   These new `inline` files will not contain the user private key or the
   OpenVPN Pre-shared TLS key.

   These new `inline` files can be used by OpenVPN, examples below:

   * specify: `--config <INLNE-FILE>` in the OpenVPN user config file.
   * Use copy/paste to add the new details to the OpenVPN user config file.
   * Use `cat` to append the `inline` file to the OpenVPN user config file.

   Note:
   `inline` files in the `pki/inline/private` directory include security keys,
   which MUST only be transmitted over a secure connection, such as `https`.

================
File: servidor/easy-rsa/doc/EasyRSA-Upgrade-Notes.md
================
Upgrading to Easy-RSA 3 from earlier versions
=========

People upgrading to Easy-RSA 3 from a 2.x version should note some important
changes starting with version 3. For a better overview of version 3 in general,
see the Readme in the doc/ directory.

Easy-RSA 3 comes with an automated upgrade utility to convert an existing 2.x
PKI to version 3. For details, see [this article on the OpenVPN
wiki](https://community.openvpn.net/openvpn/wiki/easyrsa-upgrade).

List of important changes
----

 * nsCertType extensions are no longer included by default. Use of such
   "Netscape" attributes have been deprecated upstream and their use is
   discouraged. Configure `EASYRSA_NS_SUPPORT` in vars if you want to enable
   this legacy behavior.

   Notably, this is important for OpenVPN deployments relying on the
   `--ns-cert-type` directive. Either have OpenVPN use the preferred
   `--remote-cert-tls` option, or enable legacy NS extensions.

 * The default request Subject (or DN, Distinguished Name) includes just the
   commonName. This is more suitable for VPNs and environments that don't wish
   to include info about the Country/State/City/Org/OU in certs. Configure
   `EASYRSA_DN` in vars if you want to enable the legacy behavior.

 * The 3.0 release lacks PKCS#11 (smartcard/token) support. This is anticipated
   to be supported in a future point-release to target each platform's need.

 * The -utf8 option has been added for all supported commands.  This should be
   backwards compatible with ASCII strings.

 * The default private key encryption has been changed from 3des to aes256.


Some new concepts
----

Easy-RSA 3 has some new concepts compared to the prior v2 series.

### Request-Import-Sign workflow

  v3 is now designed to support keypairs generated on the target system where
  they will be used, thus improving security as no keys need to be transferred
  between hosts. The old workflow of generating everything in a single PKI is
  still supported as well.

  The recommended workflow when using Easy-RSA as a CA is to import requests,
  sign them, and return the issued & CA certs. Each requesting system can use
  Easy-RSA without a CA to generate keypairs & requests.

### "Org"-style DN flexibility

  When using Easy-RSA in the "org" DN mode, it is no longer required to match
  some of the field values. This improves flexibility, and enables easier remote
  generation as the requester doesn't need to know the CA's values in advance.

  Previously in v2, the Country, State, and Org values all had to match or a
  request couldn't be signed. If you want the old behavior you can change the
  OpenSSL config to require it or simply look over the DN at signing time.

================
File: servidor/easy-rsa/doc/Hacking.md
================
Easy-RSA 3 Hacking Guide
===

This document is aimed at programmers looking to improve on the existing
codebase.

Compatibility
---

The `easyrsa` code is written in POSIX shell (and any cases where it is not is
considered a bug to be fixed.) The only exceptions are the `local` keyword and
the construct `export FOO=baz`, both well-supported.

As such, modifications to the code should also be POSIX; platform-specific code
should be placed under the `distro/` dir and listed by target platform.

Coding conventions
---

While there aren't strict syntax standards associated with the project, please
follow the existing format and flow when possible; however, specific exceptions
can be made if there is a significant reason or benefit.

Do try to:

  * Keep variables locally-scoped when possible
  * Comment sections of code for readability
  * Use the conventions for prefixes on global variables
  * Set editors for tab stops of 8 spaces
  * Use tabs for code indents; use aligned spaces for console text

Keeping code, docs, and examples in sync
---

Changes that adjust, add, or remove features should have relevant docs, help
output, and examples updated at the same time.

Release versioning
---

A point-release bump (eg: 3.0 to 3.1) is required when the frontend interface
changes in a non-backwards compatible way. Always assume someone has an
automated process that relies on the current functionality for official
(non-beta, non-rc) releases. A possible exception exists for bugfixes that do
break backwards-compatibility; caution is to be used in such cases.

The addition of a new command may or may not require a point-release depending
on the significance of the feature; the same holds true for additional optional
arguments to commands.

Project layout
---

The project's files are structured as follows:

  * `easyrsa3/` is the primary project code. On Linux/Unix-alikes, all the core
    code and supporting files are stored here.
  * `Licensing/` is for license docs.
  * `build/` is for build information and scripts.
  * `contrib/` is for externally-contributed files, such as useful external
    scripts or interfaces for other systems/languages.
  * `distro/` is for distro-specific supporting files, such as the Windows
    frontend wrappers. Code components that are not platform-neutral should go
    here.
  * `doc/` is for documentation. Much of this is in Markdown format which can be
    easily converted to HTML for easy viewing under Windows.
  * `release-keys/` list current and former KeyIDs used to sign release packages
    (not necessarily git tags) available for download.
  * The top-level dir includes files for basic project info and reference
    appropriate locations for more detail.

As a brief note, it is actually possible to take just the easyrsa3/ dir and end
up with a functional project; the remaining structure includes docs, build prep,
distro-specific wrappers, and contributed files.

Git conventions
---

As of Easy-RSA 3, the following git conventions should be used. These are mostly
useful for people with repo access in order to keep a standard meaning to commit
messages and merge actions.

### Signed-off-by: and related commit message lines

  Committers with push access should ensure a `Signed-off-by:` line exists at
  the end of the commit message with their name on it. This indicates that the
  committer has reviewed the changes to the commit in question and approve of
  the feature and code in question. It also helps verify the code came from an
  acceptable source that won't cause issues with the license.

  This can be automatically added by git using `git commit -s`.

  Additional references can be included as well. If multiple people reviewed the
  change, the committer may add their names in additional `Signed-off-by:`
  lines; do get permission from that person before using their name, however ;)

  The following references may be useful as well:

  * `Signed-off-by:` -- discussed above, indicates review of the commit
  * `Author:` -- references an author of a particular feature, in full or
    significant part
  * `Changes-by:` -- indicates the listed party contributed changes or
    modifications to a feature
  * `Acked-by:` -- indicates review of the feature, code, and/or functional
    correctness

### Merging from external sources (forks, patches, etc)

  Contributions can come in many forms: GitHub "pull requests" from cloned
  repos, references to external repos, patches to the ML, or others. Those won't
  necessarily have `Signed-off-by:` lines or may contain less info in the commit
  message than is desirable to explain the changes.

  The committing author to this project should make a merge-commit in this case
  with the appropriate details provided there. If additional code changes are
  necessary, this can be done on a local branch prior to merging back into the
  mainline branch.

  This merge-commit should list involved contributors with `Author:` or similar
  lines as required. The individual commits involved in a merge also retain the
  original committer; regardless, the merge-commit message should give a clear
  indication of what the entire set of commits does as a whole.

### Tagging

  Tags should follow the convention:

    vM.m.p

  where `M` is the major version, `m` is the minor "point-release" version, and
  `p` is the patch-level. Suffixes of `-rc#`, `-beta#`, etc can be added for
  pre-release versions as required.

  Currently tags are taken from the mainline development branch in question. The
  ChangeLog should thus be updated prior to tagging. Tags should also be
  annotated with an appropriate commit message and signed-off. This can be done
  as shown below (don't use `-s` unless you intend to use GPG with git.)

    git tag -a v1.2.3

  Corresponding release downloads can be uploaded to release distribution points
  as required.

================
File: servidor/easy-rsa/doc/Intro-To-PKI.md
================
Introduction to PKI
===================

This document is designed to give you a brief introduction into how a PKI, or
Public Key Infrastructure, works.

Terminology Used
----------------

To avoid confusion, the following terms will be used throughout the Easy-RSA
documentation. Short forms may be substituted for longer forms as convenient.

 *  **PKI**: Public Key Infrastructure. This describes the collection of files
    and associations between the CA, keypairs, requests, and certificates.
 *  **CA**: Certificate Authority. This is the "master cert" at the root of a
    PKI.
 *  **cert**: Certificate. A certificate is a request that has been signed by a
    CA. The certificate contains the public key, some details describing the
    cert itself, and a digital signature from the CA.
 *  **request**: Certificate Request (optionally 'req'.) This is a request for a
    certificate that is then sent to a CA for signing. A request contains the
    desired cert information along with a digital signature from the private
    key.
 *  **keypair**: A keypair is an asymmetric cryptographic pair of keys. These
    keys are split into two parts: the public and private keys. The public key
    is included in a request and certificate.

The CA
------

The heart of a PKI is the CA, or Certificate Authority, and this is also the
most security-sensitive. The CA private key is used to sign all issued
certificates, so its security is critical in keeping the entire PKI safe. For
this reason, it is highly recommended that the CA PKI structure be kept on a
system dedicated for such secure usage; it is not a great idea to keep the CA
PKI mixed in with one used to generate end-entity certificates, such as clients
or servers (VPN or web servers.)

To start a new PKI, the CA is first created on the secure environment.
Depending on security needs, this could be managed under a locked down account,
dedicated system, or even a completely offline system or using removable media
to improve security (after all, you can't suffer an online break-in if your
system or PKI is not online.) The exact steps to create a CA are described in a
separate section. When creating a new CA, the CA keypair (private and public
keys) are created, as well as the file structure necessary to support signing
issued certificates.

Once a CA has been created, it can receive certificate requests from
end-entities. These entity certificates are issued to consumers of X509
certificates, such as a client or server of a VPN, web, or email system.  The
certificate requests and certificates are not security-sensitive, and can be
transferred in whatever means convenient, such as email, flash drive, etc. For
better security, it is a good idea to verify the received request matches the
sender's copy, such as by verifying the expected checksum against the sender's
original.

Keypairs and requests
---------------------

Individual end-entities do not need a full CA set up and will only need to
create a keypair and associated certificate request. The private key is not used
anywhere except on this entity, and should never leave that system. It is wise
to secure this private key with a strong passphrase, because if lost or stolen
the holder of the private key can make connections appearing as the certificate
holder.

Once a keypair is generated, the certificate request is created and digitally
signed using the private key. This request will be sent to a CA for signing, and
a signed certificate will be returned.

How requests become certificates
--------------------------------

After a CA signs the certificate request, a signed certificate is produced. In
this step, the CA's private key is used to digitally sign the entity's public
key so that any system trusting the CA certificate can implicitly trust the
newly issued certificate. This signed certificate is then sent back to the
requesting entity. The issued certificate is not security-sensitive and can be
sent over plaintext transmission methods.

Verifying an issued certificate
-------------------------------

After 2 entities have created keypairs, sent their requests to the CA, and
received a copy of their signed certificates and the CA's own certificate, they
can mutually authenticate with one-another. This process does not require the 2
entities to have previously exchanged any kind of security information directly.

During a TLS handshake each side of the connection presents their own cert chain
to the remote end. Each side checks the validity of the cert received against
their own copy of the CA cert. By trusting the CA root cert, the peer they are
talking to can be authenticated.

The remote end proves it "really is" the entity identified by the cert by
signing a bit of data using its own private key. Only the holder of the private
key is able to do this, allowing the remote end to verify the authenticity of
the system being connected to.

================
File: servidor/easy-rsa/doc/TODO
================
Easy-RSA 3 TODO / wishlist

Feature support:
    * makefile
        * It may be useful to port the Makefile from the 2.x series
        * This may be desirable for building and downstream packaging
    * add pkcs11 support
        * Much of this may be distro-dependent
        * Keep platform-specific tools separate from platform-neutral code
    * add detection for duplicate CN prior to OpenSSL failure
        * This gets tricky if `updatedb` requires a CA passphrase
    * It would help to warn users before OpenSSL throws errors

Longer term wishlist:
    * Support openssl's -password source mechanism:
        * allow for batching currently "unbatchable" operations, like pkcs12
        * support one password input that can apply to multiple operations
        * support a variety of password sources (interactive, pipe, file, etc)

================
File: servidor/easy-rsa/easyrsa3/x509-types/ca
================
# X509 extensions for a ca

# Note that basicConstraints will be overridden by Easy-RSA when defining a
# CA_PATH_LEN for CA path length limits. You could also do this here
# manually as in the following example in place of the existing line:
#
# basicConstraints = CA:TRUE, pathlen:1

basicConstraints = CA:TRUE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer:always
keyUsage = cRLSign, keyCertSign

================
File: servidor/easy-rsa/easyrsa3/x509-types/client
================
# X509 extensions for a client

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = clientAuth
keyUsage = digitalSignature

================
File: servidor/easy-rsa/easyrsa3/x509-types/code-signing
================
# X509 extensions for a client

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = codeSigning
keyUsage = digitalSignature

================
File: servidor/easy-rsa/easyrsa3/x509-types/COMMON
================
# X509 extensions added to every signed cert

# This file is included for every cert signed, and by default does nothing.
# It could be used to add values every cert should have, such as a CDP as
# demonstrated in the following example:

#crlDistributionPoints = URI:http://example.net/pki/my_ca.crl

# The authority information access extension gives details about how to access
# certain information relating to the CA.

#authorityInfoAccess = caIssuers;URI:http://example.net/pki/my_ca.crt

================
File: servidor/easy-rsa/easyrsa3/x509-types/email
================
# X509 extensions for email

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = emailProtection
keyUsage = digitalSignature,keyEncipherment,nonRepudiation

================
File: servidor/easy-rsa/easyrsa3/x509-types/kdc
================
# X509 extensions for a KDC server certificate

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = 1.3.6.1.5.2.3.5
keyUsage = nonRepudiation,digitalSignature,keyEncipherment,keyAgreement
issuerAltName = issuer:copy
subjectAltName = otherName:1.3.6.1.5.2.2;SEQUENCE:kdc_princ_name

[kdc_princ_name]
realm = EXP:0,GeneralString:${ENV::EASYRSA_KDC_REALM}
principal_name = EXP:1,SEQUENCE:kdc_principal_seq

[kdc_principal_seq]
name_type = EXP:0,INTEGER:1
name_string = EXP:1,SEQUENCE:kdc_principals

[kdc_principals]
princ1 = GeneralString:krbtgt
princ2 = GeneralString:${ENV::EASYRSA_KDC_REALM}

================
File: servidor/easy-rsa/easyrsa3/x509-types/server
================
# X509 extensions for a server

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = serverAuth
keyUsage = digitalSignature,keyEncipherment

================
File: servidor/easy-rsa/easyrsa3/x509-types/serverClient
================
# X509 extensions for a client/server

basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = serverAuth,clientAuth
keyUsage = digitalSignature,keyEncipherment

================
File: servidor/easy-rsa/easyrsa3/easyrsa
================
#!/bin/sh

# Easy-RSA 3 -- A Shell-based CA Utility
#
# Copyright (C) 2024 - The Open-Source OpenVPN development community.
# A full list of contributors can be found on Github at:
#   https://github.com/OpenVPN/easy-rsa/graphs/contributors
#
# This code released under version 2 of the GNU GPL; see COPYING
# and the Licensing/ directory of this project for full licensing
# details.

# Help/usage output to stdout
usage() {
	# command help:
	information "
Easy-RSA 3 usage and overview

$easyrsa_help_title

To get detailed usage and help for a command, use:
  ./easyrsa help COMMAND

For a list of global-options, use:
  ./easyrsa help options

For a list of utility commands, use:
  ./easyrsa help util

A list of commands is shown below:
  init-pki [ cmd-opts ]
  self-sign-server <file_name_base> [ cmd-opts ]
  self-sign-client <file_name_base> [ cmd-opts ]
  build-ca [ cmd-opts ]
  gen-dh
  gen-req <file_name_base> [ cmd-opts ]
  sign-req <type> <file_name_base> [ cmd-opts ]
  build-client-full <file_name_base> [ cmd-opts ]
  build-server-full <file_name_base> [ cmd-opts ]
  build-serverClient-full <file_name_base> [ cmd-opts ]
  inline <file_name_base>
  expire <file_name_base>
  renew-ca
  renew <file_name_base>
  revoke <file_name_base> [ cmd-opts ] #(DEPRECATED)
  revoke-issued <file_name_base> [ cmd-opts ] #(REPLACEMENT)
  revoke-expired <file_name_base> [ cmd-opts ]
  revoke-renewed <file_name_base> [ cmd-opts ]
  gen-crl
  update-db
  show-req <file_name_base> [ cmd-opts ]
  show-cert <file_name_base> [ cmd-opts ]
  show-ca [ cmd-opts ]
  show-crl
  verify-cert <file_name_base>
  import-req <request_file_path> <short_name_base>
  export-p1 <file_name_base> [ cmd-opts ]
  export-p7 <file_name_base> [ cmd-opts ]
  export-p8 <file_name_base> [ cmd-opts ]
  export-p12 <file_name_base> [ cmd-opts ]
  set-pass <file_name_base> [ cmd-opts ]
  gen-tls-auth-key / gen-tls-crypt-key
  write <type> [ cmd-opts ]"

	# collect/show dir status:
	text_only=1
	work_dir="${EASYRSA:-undefined}"
	pki_dir="${EASYRSA_PKI:-undefined}"

	# check for vars changing PKI unexpectedly!
	if [ "$invalid_vars" ]; then
		ivmsg="
   *WARNING*: \
Invalid vars setting for EASYRSA and/or EASYRSA_PKI${NL}"
	else
		unset -v ivmsg
	fi

	# Print details
	information "
DIRECTORY STATUS (commands would take effect on these locations)
     EASYRSA: $work_dir
         PKI: $pki_dir
   vars-file: ${EASYRSA_VARS_FILE:-Missing or undefined}${ivmsg}"

	# CA Status
	if verify_ca_init test; then
		if [ -z "$EASYRSA_SILENT" ]; then
			# Show SSL output directly, with easyrsa header
			printf '%s' "   CA status: OK${NL}${NL}    "
			"$EASYRSA_OPENSSL" x509 -in "$EASYRSA_PKI/ca.crt" \
				-noout -subject -nameopt utf8,multiline
			print "" # for a clean line
		fi
	else
		information "   CA status: CA has not been built${NL}"
	fi

	# verbose info
	verbose "ssl-cnf: ${EASYRSA_SSL_CONF:-built-in}"
	verbose "x509-types: ${EASYRSA_EXT_DIR:-built-in}"
	if [ -d "$EASYRSA_TEMP_DIR" ]; then
		verbose "temp-dir: Found: $EASYRSA_TEMP_DIR"
	else
		verbose "temp-dir: Missing: ${EASYRSA_TEMP_DIR:-undefined}"
	fi
} # => usage()

# Detailed command help
# When called with no args, calls usage(),
# otherwise shows help for a command
# Please maintain strict indentation rules.
# Commands are TAB indented, while text is SPACE indented.
# 'case' indentation is minimalistic.
cmd_help() {
	easyrsa_help_title="\
Usage: easyrsa [ OPTIONS.. ] <COMMAND> <TARGET> [ cmd-opts.. ]"
	unset -v text err_text opts text_only

	case "$1" in
	init-pki|clean-all)
		text="
* init-pki [ cmd-opts ]

      Removes & re-initializes the PKI directory for a new PKI"

		opts="
      * hard    - Recursively delete the ENTIRE PKI directory (default).
      * soft    - Keep the named PKI directory and PKI 'vars' file intact.
                  Also keep the current Request files,
                  to be signed by a new CA (Partial CA renewal)."
	;;
	self-sign*)
		text="
* self-sign-server|self-sign-client <file_name_base> [ cmd-opts ]

      Creates a new self-signed server|client key pair"

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')"
	;;
	build-ca)
		text="
* build-ca [ cmd-opts ]

      Creates a new CA"

		opts="
      * raw-ca  - ONLY use SSL binary to input CA password
        raw       (Equivalent to global option '--raw-ca')

      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')

      * subca   - Create an intermediate CA keypair and request
        intca     (default is a root CA)"
	;;
	gen-dh)
		text="
* gen-dh

      Generates DH (Diffie-Hellman) parameters file"
	;;
	gen-req)
		text="
* gen-req <file_name_base> [ cmd-opts ]

      Generate a standalone-private-key and certificate-signing-request

      This request is suitable for sending to a remote CA for signing."

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')
      * text    - Include certificate text in request"
	;;
	sign|sign-req)
		text="
* sign-req <type> <file_name_base> [ cmd-opts ]

      Sign a certificate request of the defined type.

      <type> must be a known type.
      eg: 'client', 'server', 'serverClient', 'ca' or a user-added type.
      All supported types are listed in the x509-types directory.

      This request file must exist in the reqs/ dir and have a .req file
      extension. See 'import-req' for importing from other sources."
		opts="
      * newsubj  - Replace subject. See 'help subject'.
      * preserve - Use the DN-field order of the CSR not the CA."
	;;
	build|build-client-full|build-server-full|build-serverClient-full)
		text="
* build-client-full <file_name_base> [ cmd-opts ]
* build-server-full <file_name_base> [ cmd-opts ]
* build-serverClient-full <file_name_base> [ cmd-opts ]

      Generate a keypair and sign locally.

      This mode uses the <file_name_base> as the X509 commonName."

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')"
	;;
	inline)
		text="
* inline <file_name_base>

      Create inline file for <file_name_base>."
	;;
	revoke*)
		text="
* revoke <file_name_base> [ reason ]

Commmand 'revoke' is DEPRECATED and can ONLY be used in batch mode.
Commmand 'revoke-issued' REPLACES command 'revoke'.

      Revoke a certificate specified by the <file_name_base>,
      with an optional revocation [ reason ].

      Values accepted for option [ reason ]:
         us | uns* | unspecified
         kc | key* | keyCompromise
         cc | ca*  | CACompromise
         ac | aff* | affiliationChanged
         ss | sup* | superseded
         co | ces* | cessationOfOperation
         ch | cer* | certificateHold

      Commands 'revoke-expired' and 'revoke-renewed' are functionally
      equivalent to 'revoke-issued', however, they are used to revoke
      certificates which have been either 'expired' or 'renewed' by
      other EasyRSA commands.

Commmand 'revoke' is DEPRECATED and can ONLY be used in batch mode.
Commmand 'revoke-issued' REPLACES command 'revoke'.

REQUIRED COMMANDS:

* 'revoke-issued' <file_name_base> [ reason ]
  Revoke a current, issued certificate.

* 'revoke-expired' <file_name_base> [ reason ]
  Revoke an old, expired certificate.

* 'revoke-renewed' <file_name_base> [ reason ]
  Revoke an old, renewed certificate."
		opts="
      * [ reason ]${NL}
      Values accepted for option [ reason ]: Details above."
	;;
	expire)
		text="
* expire <file_name_base>

      Move a certificate specified by <file_name_base>
      to the 'pki/expired' directory.

      Allows an existing request to be signed again."
	;;
	renew-ca)
		text="
* renew-ca

      Renew CA certificate.

      This will build a new CA certificate and archive the old one.
      Before changes are made to the current PKI, user confirmation
      is required."
	;;
	renew)
		text="
* renew <file_name_base>

      Renew a certificate specified by <file_name_base>"
	;;
	gen-crl)
		text="
* gen-crl

      Generate a certificate revocation list [CRL]"
	;;
	update-db)
		text="
* update-db

      Update the index.txt database

      This command will use the system time to update the status of
      issued certificates."
	;;
	show-req|show-cert)
		text="
* show-req  <file_name_base> [ cmd-opts ]
* show-cert <file_name_base> [ cmd-opts ]

      Shows details of the req or cert referenced by <file_name_base>

      Human-readable output is shown, including any requested cert
      options when showing a request."

		opts="
      * full    - show full req/cert info, including pubkey/sig data"
	;;
	show-ca)
		text="
* show-ca [ cmd-opts ]

      Shows details of the Certificate Authority [CA] certificate

      Human-readable output is shown."

		opts="
      * full    - show full CA info, including pubkey/sig data"
	;;
	show-crl)
		text="
* show-crl

      Shows details of the current certificate revocation list (CRL)

      Human-readable output is shown."
	;;
	verify|verify-cert)
		text="
* verify-cert <file_name_base> [ cmd-opts ]

      Verify certificate against CA

      Returns the current validity of the certificate."

		opts="
      * batch   - On failure to verify, return error (1) to caller"
	;;
	import-req)
		text="
* import-req <request_file_path> <short_name_base>

      Import a certificate request from a file

      This will copy the specified file into the reqs/ dir in
      preparation for signing.

      The <short_name_base> is the <file_name_base> to create.

      Example usage:
        import-req /some/where/bob_request.req bob"
	;;
	export-p12)
		text="
* export-p12 <file_name_base> [ cmd-opts ]

      Export a PKCS#12 file with the keypair,
      specified by <file_name_base>"

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')
      * noca    - Do not include the ca.crt file in the PKCS12 output
      * nokey   - Do not include the private key in the PKCS12 output
      * nofn    - Do not set 'friendlyName'
                  For more, see: 'easyrsa help friendly'
      * legacy  - Use legacy algorithm: RC2_CBC or 3DES_CBC + MAC: SHA1
                  (Default algorithm: AES-256-CBC + MAC: SHA256)"
	;;
	friendly)
		text_only=1
		text="
* export-p12: Internal file label 'friendlyName'

      The 'friendlyname' is always set to the file-name-base.

      An alternate friendlyName can be configured by using:
      * Global option '--usefn=<friendlyName>'

      Fallback to previous behavior can be configured by using:
      * Command option 'nofn' ('friendlyname' will not be set)"
	;;
	export-p7)
		text="
* export-p7 <file_name_base> [ cmd-opts ]

      Export a PKCS#7 file with the pubkey,
      specified by <file_name_base>"

		opts="
      * noca    - Do not include the ca.crt file in the PKCS7 output"
	;;
	export-p8)
		text="
* export-p8 <file_name_base> [ cmd-opts ]

      Export a PKCS#8 file with the private key,
      specified by <file_name_base>"

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')"
	;;
	export-p1)
		text="
* export-p1 <file_name_base> [ cmd-opts ]

      Export a PKCS#1 (RSA format) file with the pubkey,
      specified by <file_name_base>"

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')"
	;;
	set-pass|set-ed-pass|set-rsa-pass|set-ec-pass)
		text="
* set-pass <file_name_base> [ cmd-opts ]

      Set a new passphrase for the private key specified by <file_name_base>

  DEPRECATED: 'set-rsa-pass' and 'set-ec-pass'"

		opts="
      * nopass  - Do not encrypt the private key (Default: encrypted)
                  (Equivalent to global option '--nopass|--no-pass')
      * file    - (Advanced) Treat the file as a raw path, not a short-name"
	;;
	write)
		text="
* write <type> [<filename>] ['overwrite']

      Write <type> data to stdout or <filename>

      Types:
      * ssl-cnf  - Write EasyRSA SSL config file.
      * safe-cnf - Write expanded EasyRSA SSL config file for LibreSSL.
      * COMMON|ca|server|serverClient|client|codeSigning|email|kdc
                 - Write x509-type <type> file.
      * legacy   - Write ALL support files (above) to the PKI directory.
                   Will create '\$EASYRSA_PKI/x509-types' directory.
      * legacy-hard
                 - Same as 'legacy' plus OVER-WRITE files.
      * vars     - Write vars.example file."

		opts="
      * filename - If <filename> is specified then it is the output
                   is directed to the named file.
                   Otherwise, the data is sent to stdout
      * overwrite - Overwrite the <filename>.
                   <filename> is always preserved without 'overwrite'."
	;;
	--san|--subject-alt-name|altname|subjectaltname|san)
		text_only=1
		text="
* Global Option: --subject-alt-name=SAN_FORMAT_STRING

      This global option adds a subjectAltName to the request or issued
      certificate. It MUST be in a valid format accepted by openssl or
      req/cert generation will fail. NOTE: --san can be specified more
      than once on the command line.

      The following two command line examples are equivalent:
      1. --san=DNS:server1,DNS:serverA,IP:10.0.0.1
      2. --san=DNS:server1 --san=DNS:serverA --san=IP:10.0.0.1

      Examples of the SAN_FORMAT_STRING shown below:

      * DNS:alternate.example.net
      * DNS:primary.example.net,DNS:alternate.example.net
      * IP:203.0.113.29
      * email:alternate@example.net"
	;;
	--copy-ext|copy-ext|copyext)
		text_only=1
		text="
* Global Option: How to use --copy-ext and --san=<SAN>

    These are the only commands that support --copy-ext and/or --san.

    Command 'gen-req':
      --san: Add SAN extension to the request file.

    Command 'sign-req':
      --copy-ext: Copy all request extensions to the signed certificate.
      --san: Over write the request SAN with option SAN.

    Command 'build-*-full':
      --copy-ext: Always enabled.
      --san: Add SAN extension to the request and signed certificate.

    See 'help san' for option --san full syntax."
	;;
	--days|days)
		text_only=1
		text="
* Global Option: --days=DAYS

      This global option is an alias for one of the following:
      * Expiry days for a new CA.
        eg: '--days=3650 build-ca'
      * Expiry days for new/renewed certificate.
        eg: '--days=1095 renew server'
      * Expiry days for certificate revocation list.
        eg: '--days=180 gen-crl'
      * Cutoff days for command: show-expire.
        eg: '--days=90 show-expire'"
	;;
	--new-subj*|new-subj*|newsubj*|subject)
		text_only=1
		text="
* Global Option: --new-subject=<SUBJECT>

      This global option is used to set the new certificate subject,
      when signing a new certificate

* REQUIRES Command option: 'newsubj', for command 'sign-req'

      Using command 'sign-req', add command option 'newsubj',
      to FORCE the --new-subject to be used.

      Example:
      --new-subject='/CN=foo' sign-req client bar newsubj

      See OpenSSL command 'ca', option -subj, for full details."
	;;
	tool*|util*|more)
		# Test features
		text_only=1
		text="
NOTE:
These commands are safe to test and will NOT effect your PKI.

  Check <SERIAL> number is unique:
    serial|check-serial <SERIAL>

  Display DN of request or certificate: <form> = req|x509
    display-dn <form> <DIR/FILE_NAME>

  Display EKU of certificate:
    show-eku <file_name_base>|<DIR/FILE_NAME>

  Generate random hex:
    rand <decimal_number>

These commands require easyrsa-tools.lib to be installed:

  show-expire <file_name_base> (Optional)
  show-revoke <file_name_base> (Optional)
  show-renew <file_name_base> (Optional)"
	;;
	gen-tls*)
		text_only=1
		text="
Generate TLS keys for use with OpenVPN:

  gen-tls-auth-key    : Generate OpenVPN TLS-AUTH key
  gen-tls-crypt-key   : Generate OpenVPN TLS-CRYPT-V1 key (Preferred)

Only ONE TLS key is allowed to exist. (pki/private/easyrsa-tls.key)
This TLS key will be automatically added to inline files."
	;;
	opts|options)
		opt_usage
		cleanup ok
	;;
	"")
		usage
		cleanup ok
	;;
	*)
		err_text="
  Unknown command: '$1' \
(try without commands for a list of commands)"
		easyrsa_exit_with_error=1
	esac

	if [ "$err_text" ]; then
		print "$easyrsa_help_title"
		print "${err_text}"
	else
		# display the help text
		print "$easyrsa_help_title"
		[ "$text" ] && print "$text"

		if [ "$text_only" ]; then
			: # ok - No opts message required
		else
			print "
    Available command options [ cmd-opts ]:
${opts:-
      * No supported command options}"
		fi
	fi
	print
} # => cmd_help()

# Options usage
opt_usage() {
	text_only=1
	information "
Easy-RSA Global Option Flags

The following global-options may be provided before the command.
Options specified at runtime override env-vars and any 'vars'
file in use.

Unless noted, non-empty values to options are mandatory.

General options:

--version       : Prints EasyRSA version and build information
--batch         : Set automatic (no-prompts when possible) mode
--silent|-s     : Disable all warnings, notices and information
--sbatch        : Combined --silent and --batch operating mode
--silent-ssl|-S : Silence SSL output (Requires batch mode)

--nopass|no-pass: Do not use passwords
                  Can NOT be used with --passin or --passout
--passin=ARG    : Set -passin ARG for openssl (eg: pass:xEasyRSAy)
--passout=ARG   : Set -passout ARG for openssl (eg: pass:xEasyRSAy)
--raw-ca        : Build CA with password via RAW SSL input

--vars=FILE     : Define a specific 'vars' file to use for Easy-RSA config
                  (Default vars file is in the current working directory)
--pki=DIR       : Declare the PKI directory
                  (Default PKI directory is sub-directory 'pki')
                  See Advanced.md for in depth usage.

--ssl-cnf=FILE  : Define a specific OpenSSL config file for Easy-RSA to use
                  (Default config file is in the EasyRSA PKI directory)
--force-safe-ssl: Always generate a safe SSL config file
                  (Default: Generate Safe SSL config once per instance)

--tools=FILE    : Declare the full easyrsa-tools.lib file-name
--tmp-dir=DIR   : Declare the temporary directory
                  (Default temporary directory is the EasyRSA PKI directory)
--keep-tmp=NAME : Keep the original temporary session by name: NAME
                  NAME is a sub-directory of the dir declared by --tmp-dir
                  This option ALWAYS over-writes a sub-dir of the same name.

Certificate & Request options: (these impact cert/req field values)

--notext|no-text: Create certificates without human readable text
--days=#        : Sets the signing validity to the specified number of days
                  Applies to other commands. For details, see: 'help days'
--startdate=DATE: Sets the SSL option '-startdate' (Format 'YYYYMMDDhhmmssZ')
--enddate=DATE  : Sets the SSL option '-enddate' (Format 'YYYYMMDDhhmmssZ')

--digest=ALG    : Digest to use in the requests & certificates
--keysize=#     : Size in bits of keypair to generate (RSA Only)
--use-algo=ALG  : Crypto alg to use: choose rsa (default), ec or ed
--curve=NAME    : For elliptic curve, sets the named curve
                  (Default: algo ec: secp384r1, algo ed: ed25519)

--subca-len=#   : Path length of signed intermediate CA certificates
--copy-ext      : Copy included request X509 extensions (namely subjAltName)
                  For more info, see: 'easyrsa help copyext'

--san|--subject-alt-name=SUBJECT_ALT_NAME
                : Add a subjectAltName. Can be used multiple times.
                  For more info and syntax, see: 'easyrsa help altname'
--auto-san      : Use commonName as subjectAltName: 'DNS:commonName'
                  If commonName is 'n.n.n.n' then set 'IP:commonName'

--san-crit      : Mark X509v3 subjectAltName as critical
--bc-crit       : Add X509 'basicContraints = critical' attribute.
--ku-crit       : Add X509 'keyUsage = critical' attribute.
--eku-crit      : Add X509 'extendedKeyUsage = critical' attribute.

--new-subject='SUBJECT'
                : Specify a new subject field to sign a request with.
                  For more info and syntax, see: 'easyrsa help subject'

--usefn=NAME    : export-p12, set 'friendlyName' to NAME
                  For more, see: 'easyrsa help friendly'

Distinguished Name mode:

--dn-mode=MODE  : Distinguished Name mode to use 'cn_only' (Default) or 'org'

--req-cn=NAME   : Request commonName

  Distinguished Name Organizational options: (only used with '--dn-mode=org')
  --req-c=CC           : Country code (2-letters)
  --req-st=NAME        : State/Province
  --req-city=NAME      : City/Locality
  --req-org=NAME       : Organization
  --req-email=NAME     : Email addresses
  --req-ou=NAME        : Organizational Unit
  --req-serial=VALUE   : Entity serial number (Only used when declared)

Deprecated features:

--ns-cert             : Include deprecated Netscape extensions
--ns-comment=COMMENT  : Include deprecated Netscape comment (may be blank)"
} # => opt_usage()

# Wrapper around printf - clobber print since it's not POSIX anyway
# print() is used internally, so MUST NOT be silenced.
# shellcheck disable=SC1117 # printf format - print()
print() {
	printf '%s\n' "$*"
} # => print()

# Exit fatally with a message to stderr
# present even with EASYRSA_BATCH as these are fatal problems
die() {
	print "
Easy-RSA error:

$*${NL}"

	# error_info is for hard-to-spot errors!
	if [ "$error_info" ]; then
		print "  * $cmd: ${error_info}${NL}"
	fi

	# show host info
	show_host

	# exit to cleanup()
	exit "${2:-1}"
} # => die()

# User errors, less noise than die()
user_error() {
	print "
EasyRSA version $EASYRSA_version

Error
-----
$*${NL}"

	easyrsa_exit_with_error=1
	cleanup
} # => user_error()

# verbose information
verbose() {
	[ "$EASYRSA_VERBOSE" ] || return 0
	print "  # $*"
} # => verbose()

# non-fatal warning output
warn() {
	[ "$EASYRSA_SILENT" ] && return
	print "
WARNING
=======
$*${NL}"
} # => warn()

# informational notices to stdout
notice() {
	[ "$EASYRSA_SILENT" ] && return
	print "
Notice
------
$*${NL}"
} # => notice()

# Helpful information
information() {
	[ "$EASYRSA_SILENT" ] && return
	print "$*"
} # => information()

# intent confirmation helper func
# returns without prompting in EASYRSA_BATCH
confirm() {
	[ "$EASYRSA_BATCH" ] && return
	prompt="$1"
	value="$2"
	msg="$3"
	input=""
	print "\
$msg

Type the word '$value' to continue, or any other input to abort."
	printf %s "  $prompt"
	# shellcheck disable=SC2162 # read without -r - confirm()
	read input
	printf '\n'
	[ "$input" = "$value" ] && return
	easyrsa_exit_with_error=1
	unset -v EASYRSA_SILENT
	notice "Aborting without confirmation."
	cleanup
} # => confirm()

# Generate random hex
easyrsa_random() {
	case "$1" in
		*[!1234567890]*|0*|"")
			die "easyrsa_random - input"
	esac

	if rand_hex="$(
			"$EASYRSA_OPENSSL" rand -hex "$1" 2>/dev/null
		)"
	then
		if [ "$2" ]; then
			force_set_var "$2" "$rand_hex"
		else
			print "$rand_hex"
		fi
		unset -v rand_hex
		return 0
	fi

	die "easyrsa_random failed"
} # => easyrsa_random()

# Create session directory atomically or fail
secure_session() {
	# Session must not be defined
	[ -z "$secured_session" ] || die "session overload"

	# Temporary directory must exist
	[ -d "$EASYRSA_TEMP_DIR" ] || die "\
secure_session - Missing temporary directory:
* $EASYRSA_TEMP_DIR"

	for i in 1 2 3; do
		session=
		easyrsa_random 4 session
		secured_session="${EASYRSA_TEMP_DIR}/${session}"

		# atomic:
		# ONLY effects Windows 11 "broken" mkdir.exe
		# The procedure now is a "poor man's" version
		# of an atomic directory creation call.
		# The "race condition" still exists but is minimized.
		# What remains is equivalent to 32bit hash collision.
		[ -d "$secured_session" ] && continue
		if mkdir "$secured_session"; then
			# Check mkdir.exe has created the directory
			[ -d "$secured_session" ] || \
				die "secure_session - mkdir FAILED"
			[ -f "$secured_session"/temp.0.1 ] && \
				die "secure_session - temp-file EXISTS"

			# New session requires safe-ssl conf
			unset -v session OPENSSL_CONF \
				working_safe_ssl_conf working_safe_org_conf

			easyrsa_err_log="$secured_session/error.log"
			verbose "\
secure_session: CREATED: $secured_session"
			return
		fi
	done
	die "secure_session failed"
} # => secure_session()

# Remove secure session
remove_secure_session() {
	[ -d "$secured_session" ] || return 0
	if rm -rf "$secured_session"; then
		verbose "\
remove_secure_session: DELETED: $secured_session"

		# Restore original EASYRSA_SSL_CONF
		EASYRSA_SSL_CONF="$original_ssl_cnf"

		unset -v secured_session OPENSSL_CONF \
			working_safe_ssl_conf working_safe_org_conf
		return
	fi
	die "remove_secure_session Failed: $secured_session"
} # => remove_secure_session()

# 'mkdir' wrapper, broken by win11, which fails without error
easyrsa_mkdir() {
	[ "$2" ] && die "easyrsa_mkdir - excess input"
	[ "$1" ] || die "easyrsa_mkdir - input"
	[ -d "$1" ] && return
	mkdir "$1" 2>/dev/null
	[ -d "$1" ] && return
	die "easyrsa_mkdir - FAIL: $1"
} # => easyrsa_mkdir()

# Create temp-file atomically or fail
# WARNING: Running easyrsa_openssl in a subshell
# will hide error message and verbose messages
# from easyrsa_mktemp()
easyrsa_mktemp() {
	if [ -z "$1" ] || [ "$2" ]; then
		die "easyrsa_mktemp - input error"
	fi

	# session directory must exist
	[ -d "$secured_session" ] || die "\
easyrsa_mktemp - Temporary session undefined (--tmp-dir)"

	# Force noclobber
	if [ "$easyrsa_host_os" = win ]; then
		set -o noclobber
	else
		set -C
	fi

	# Assign internal temp-file name
	tmp_fname="${secured_session}/temp.${mktemp_counter}"

	# Create shotfile
	for shot_try in x y z; do
		shotfile="${tmp_fname}.${shot_try}"
		if [ -f "$shotfile" ]; then
			verbose "\
easyrsa_mktemp: shotfile EXISTS: $shotfile"
			continue
		else
			printf "" > "$shotfile" || die "\
easyrsa_mktemp: create shotfile failed (1) $1"

			# Create temp-file or die
			# subshells do not update mktemp_counter,
			# which is why this extension is required.
			# Current max required is 1 attempt
			for ext_try in 1 2 3 4 5 6 7 8 9; do
				want_tmp_file="${tmp_fname}.${ext_try}"

				# Warn to error log file for max reached
				if [ "$EASYRSA_MAX_TEMP" -lt "$ext_try" ]; then
					print "\
Max temp-file limit $ext_try, hit for: $1" > "$easyrsa_err_log"
					die "EASYRSA_MAX_TEMP exceeded"
				fi

				if [ -f "$want_tmp_file" ]; then
					verbose "\
easyrsa_mktemp: temp-file EXISTS: $want_tmp_file"
					continue
				else
					# atomic:
					if mv "$shotfile" "$want_tmp_file"; then
						# Assign external temp-file name
						if force_set_var "$1" "$want_tmp_file"
						then
							verbose "\
: easyrsa_mktemp: $1 OK: $want_tmp_file"

							# unset noclobber
							if [ "$easyrsa_host_os" = win ]; then
								set +o noclobber
							else
								set +C
							fi

							# Update counter
							mktemp_counter="$((mktemp_counter+1))"

							unset -v tmp_fname \
								shotfile shot_try \
								want_tmp_file ext_try
							return
						else
							die "\
easyrsa_mktemp - force_set_var $1 failed"
						fi
					fi
				fi
			done
		fi
	done

	# unset noclobber
	if [ "$easyrsa_host_os" = win ]; then
		set +o noclobber
	else
		set +C
	fi

	# In case of subshell abuse, report to error log
	err_msg="\
easyrsa_mktemp - failed for: $1 @ attempt=$ext_try
want_tmp_file: $want_tmp_file"
	print "$err_msg" > "$easyrsa_err_log"
	die "$err_msg"
} # => easyrsa_mktemp()

# remove temp files and do terminal cleanups
cleanup() {
	# In case of subshell abuse, display error log file
	if [ -f "$easyrsa_err_log" ]; then
		print; cat "$easyrsa_err_log"; print
	fi

	# undo changes BEFORE delete temp-dir
	# Remove files when build_full()->sign_req() is interrupted
	[ "$error_build_full_cleanup" ] && \
		rm -f "$crt_out" "$req_out" "$key_out"

	# Restore files when renew is interrupted
	[ "$error_undo_renew_move" ] && renew_restore_move

	# Remove temp-session or create temp-snapshot
	if [ -d "$secured_session" ]; then
		if [ "$EASYRSA_KEEP_TEMP" ]; then
			# skip on black-listed directory names, with a warning
			# Use '-e' for directory or file name
			if [ -e "$EASYRSA_TEMP_DIR/$EASYRSA_KEEP_TEMP" ]
			then
				warn "\
Prohibited value for --keep-tmp: '$EASYRSA_KEEP_TEMP'
Temporary session not preserved."
			else
				# create temp-snapshot
				keep_tmp="$EASYRSA_TEMP_DIR/tmp/$EASYRSA_KEEP_TEMP"
				easyrsa_mkdir "$EASYRSA_TEMP_DIR"/tmp
				easyrsa_mkdir "$keep_tmp"
				rm -rf "$keep_tmp"
				mv -f "$secured_session" "$keep_tmp"
				information "Temp session preserved: $keep_tmp"
				unset -v secured_session
			fi
		fi

		# remove temp-session
		remove_secure_session
		verbose "mktemp_counter: $mktemp_counter uses"
	fi

	# When prompt is disabled then restore prompt
	case "$prompt_restore" in
		0) : ;; # Not required
		1)
			[ -t 1 ] && stty echo
			[ "$EASYRSA_SILENT" ] || print
		;;
		2)
			# shellcheck disable=SC3040 # POSIX set -o
			set -o echo
			[ "$EASYRSA_SILENT" ] || print
		;;
		*) warn "Unknown prompt_restore: '$prompt_restore'"
	esac

	# Clear traps
	trap - 0 1 2 3 6 15

	# Exit: Known errors
	# -> confirm(): aborted
	# -> verify_cert(): verify failed --batch mode
	# -> check_serial_unique(): not unique --batch mode
	# -> user_error(): User errors but not die()
	if [ "$easyrsa_exit_with_error" ]; then
		verbose "Exit: Known errors = true"
		exit 1
	elif [ "$1" = 2 ]; then
		verbose "exit SIGINT = true"
		kill -2 "$$" # Exit: SIGINT
	elif [ "$1" = ok ]; then
		verbose "Exit: Final Success = true"
		exit 0 # Exit: Final Success
	fi

	# if 'cleanup' is called without 'ok' then an error occurred
	verbose "Exit: Final Fail = true"
	exit 1 # Exit: Final Fail, unknown error
} # => cleanup()

# Escape hazardous characters
# Auto-escape hazardous characters:
# '&' - Workaround 'sed' behavior
# '$' - Workaround 'easyrsa' based limitation
# This is required for all SSL libs, otherwise,
# there are unacceptable differences in behavior
escape_hazard() {
	if [ "$EASYRSA_FORCE_SAFE_SSL" ]; then # Always run
		verbose "escape_hazard: FORCED"
	elif [ "$working_safe_org_conf" ]; then # Has run once
		verbose "escape_hazard: BYPASSED"
		return
	else # Run once
		verbose "escape_hazard: RUN-ONCE"
		working_safe_org_conf=1 # Set run once
	fi

	# Assign temp-file
	escape_hazard_tmp=""
	easyrsa_mktemp escape_hazard_tmp || die \
		"escape_hazard - easyrsa_mktemp escape_hazard_tmp"

	# write org fields to org temp-file and escape '&' and '$'
	print "\
export EASYRSA_REQ_COUNTRY=\"$EASYRSA_REQ_COUNTRY\"
export EASYRSA_REQ_PROVINCE=\"$EASYRSA_REQ_PROVINCE\"
export EASYRSA_REQ_CITY=\"$EASYRSA_REQ_CITY\"
export EASYRSA_REQ_ORG=\"$EASYRSA_REQ_ORG\"
export EASYRSA_REQ_OU=\"$EASYRSA_REQ_OU\"
export EASYRSA_REQ_EMAIL=\"$EASYRSA_REQ_EMAIL\"
export EASYRSA_REQ_SERIAL=\"$EASYRSA_REQ_SERIAL\"\
" | sed -e s\`'\&'\`'\\\&'\`g \
		-e s\`'\$'\`'\\\$'\`g > "$escape_hazard_tmp" || \
			die "escape_hazard - Failed to write temp-file"

	# Reload fields from fully escaped temp-file
	# shellcheck disable=1090 # Non-constant source
	. "$escape_hazard_tmp"
	verbose "escape_hazard: COMPLETED"
} # => escape_hazard()

# Replace environment variable names with current value
# and write to temp-file or return error from sed
expand_ssl_config() {
	if [ "$EASYRSA_FORCE_SAFE_SSL" ]; then # Always run
		verbose "expand_ssl_config: FORCED"
	elif [ "$working_safe_ssl_conf" ]; then # Has run once
		verbose "expand_ssl_config: BYPASSED"
		return
	elif [ "$ssl_lib" = libressl ]; then # LibreSSL Always run
		verbose "expand_ssl_config: REQUIRED"
	elif [ "$ssl_lib" = openssl ]; then # OpenSSL not required
		verbose "expand_ssl_config: IGNORED"
		return
	else
		die "expand_ssl_config: EXCEPTION" # do NOT Run
	fi

	# Set run once
	working_safe_ssl_conf=1
	verbose "expand_ssl_config: RUN-ONCE"

	# Assign temp-file
	safe_ssl_cnf_tmp=""
	easyrsa_mktemp safe_ssl_cnf_tmp || die \
		"expand_ssl_config - easyrsa_mktemp safe_ssl_cnf_tmp"

	# Rewrite
	# shellcheck disable=SC2016 # No expand ''
	if sed \
\
-e s\`'$dir'\`\
\""$EASYRSA_PKI"\"\`g \
\
-e s\`'$ENV::EASYRSA_PKI'\`\
\""$EASYRSA_PKI"\"\`g \
\
-e s\`'$ENV::EASYRSA_CERT_EXPIRE'\`\
\""$EASYRSA_CERT_EXPIRE"\"\`g \
\
-e s\`'$ENV::EASYRSA_CRL_DAYS'\`\
\""$EASYRSA_CRL_DAYS"\"\`g \
\
-e s\`'$ENV::EASYRSA_DIGEST'\`\
\""$EASYRSA_DIGEST"\"\`g \
\
-e s\`'$ENV::EASYRSA_KEY_SIZE'\`\
\""$EASYRSA_KEY_SIZE"\"\`g \
\
-e s\`'$ENV::EASYRSA_DN'\`\
\""$EASYRSA_DN"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_CN'\`\
\""$EASYRSA_REQ_CN"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_COUNTRY'\`\
\""$EASYRSA_REQ_COUNTRY"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_PROVINCE'\`\
\""$EASYRSA_REQ_PROVINCE"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_CITY'\`\
\""$EASYRSA_REQ_CITY"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_ORG'\`\
\""$EASYRSA_REQ_ORG"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_OU'\`\
\""$EASYRSA_REQ_OU"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_EMAIL'\`\
\""$EASYRSA_REQ_EMAIL"\"\`g \
\
-e s\`'$ENV::EASYRSA_REQ_SERIAL'\`\
\""$EASYRSA_REQ_SERIAL"\"\`g \
\
			"$EASYRSA_SSL_CONF" > "$safe_ssl_cnf_tmp"
		then
			verbose "expand_ssl_config: via 'sed' COMPLETED"
		else
			return 1
		fi

	export EASYRSA_SSL_CONF="$safe_ssl_cnf_tmp"
	unset -v safe_ssl_cnf_tmp
	verbose \
		"expand_ssl_config: EASYRSA_SSL_CONF = $EASYRSA_SSL_CONF"
} # => expand_ssl_config()

# Easy-RSA meta-wrapper for SSL
# WARNING: Running easyrsa_openssl in a subshell
# will hide error message and verbose messages
easyrsa_openssl() {
	openssl_command="$1"; shift

	if [ "$EASYRSA_DEBUG" ]; then
		verbose "= easyrsa_openssl - BEGIN $openssl_command $*"
	else
		verbose "= easyrsa_openssl - BEGIN $openssl_command"
	fi

	# Do not allow 'rand' here, see easyrsa_random()
	case "$openssl_command" in
		rand) die "easyrsa_openssl: Illegal SSL command: rand"
	esac

	# Use $EASYRSA_SSL_CONF (local) or $OPENSSL_CONF (global)
	if [ -f "$EASYRSA_SSL_CONF" ]; then
		export OPENSSL_CONF="$EASYRSA_SSL_CONF"
	elif [ -f "$OPENSSL_CONF" ]; then
		export OPENSSL_CONF
	else
		die "easyrsa_openssl - OPENSSL_CONF undefined"
	fi
	verbose "= easyrsa_openssl: OPENSSL_CONF = $OPENSSL_CONF"

	# Exec SSL
	if [ "$EASYRSA_SILENT_SSL" ] && [ "$EASYRSA_BATCH" ]
	then
		if "$EASYRSA_OPENSSL" "$openssl_command" "$@" \
			2>/dev/null
		then
			verbose "= easyrsa_openssl - END $openssl_command"
			return
		fi
	else
		if "$EASYRSA_OPENSSL" "$openssl_command" "$@"
		then
			verbose "= easyrsa_openssl - END $openssl_command"
			return
		fi
	fi

	# Always fail here
	die "\
easyrsa_openssl - Command has failed:
* $EASYRSA_OPENSSL $openssl_command $*"
} # => easyrsa_openssl()

# Verify the SSL library is functional
# and establish version dependencies
verify_ssl_lib() {
	# Run once only
	[ "$verify_ssl_lib_ok" ] && return
	verify_ssl_lib_ok=1
	unset -v openssl_v3

	# redirect std-err, ignore missing ssl/openssl.cnf
	val="$(
			"$EASYRSA_OPENSSL" version 2>/dev/null
		)"
	ssl_version="$val"

	# SSL lib name
	case "${val%% *}" in
		OpenSSL)
			ssl_lib=openssl
			# Honor EASYRSA_FORCE_SAFE_SSL
			if [ "$EASYRSA_FORCE_SAFE_SSL" ]; then
				ssl_cnf_type=safe-cnf
			else
				ssl_cnf_type=ssl-cnf
			fi
			;;
		LibreSSL)
			ssl_lib=libressl
			ssl_cnf_type=safe-cnf
			;;
		*)
			error_msg="$("$EASYRSA_OPENSSL" version 2>&1)"
			user_error "\
* OpenSSL must either exist in your PATH
  or be defined in your vars file.

Invalid SSL output for 'version':

$error_msg"
	esac

	# Set SSL version dependent $no_password option
	osslv_major="${val#* }"
	osslv_major="${osslv_major%%.*}"
	case "$osslv_major" in
		1) no_password='-nodes' ;;
		2) no_password='-nodes' ;;
		3|4)
			case "$ssl_lib" in
				openssl)
					openssl_v3=1
					no_password='-noenc'
					;;
				libressl)
					no_password='-nodes'
					;;
				*) die "Unexpected SSL library: $ssl_lib"
			esac
			;;
		*) die "Unexpected SSL version: $osslv_major"
	esac

	# Message
	verbose "verify_ssl_lib(): $ssl_version ($EASYRSA_OPENSSL)"
} # => verify_ssl_lib()

# Basic sanity-check of PKI init and complain if missing
verify_pki_init() {
	help_note="\
Run easyrsa without commands for usage and command help."

	# Check for defined EASYRSA_PKI
	[ "$EASYRSA_PKI" ] || die "\
EASYRSA_PKI env-var undefined"

	# check that the pki dir exists
	[ -d "$EASYRSA_PKI" ] || user_error "\
EASYRSA_PKI does not exist (perhaps you need to run init-pki)?
Expected to find the EASYRSA_PKI at:
* $EASYRSA_PKI

$help_note"

	# verify expected dirs present:
	for i in private reqs; do
		[ -d "$EASYRSA_PKI/$i" ] || user_error "\
Missing expected directory: $i

(perhaps you need to run init-pki?)

$help_note"
	done
	unset -v help_note
} # => verify_pki_init()

# Verify core CA files present
verify_ca_init() {
	verify_ca_help_note="\
Run easyrsa without commands for usage and command help."

	# Verify expected files are present.
	# Allow files to be regular files (or symlinks),
	# but also pipes, for flexibility with ca.key
	for i in ca.crt private/ca.key index.txt serial; do
		if [ ! -f "$EASYRSA_PKI/$i" ] && \
			[ ! -p "$EASYRSA_PKI/$i" ]
		then
			# Used by usage() and export-p12/p7
			[ "$1" = "test" ] && return 1

			user_error "\
Missing expected CA file: $i

(perhaps you need to run build-ca?)

$verify_ca_help_note"
		fi
	done

	# When operating in 'test' mode, return success.
	# test callers don't care about CA-specific dir structure
	[ "$1" = "test" ] && return 0

	# verify expected CA-specific dirs:
	for i in issued certs_by_serial; do
		[ -d "$EASYRSA_PKI/$i" ] || user_error "\
Missing expected CA dir: $i

(perhaps you need to run build-ca?)

$verify_ca_help_note"
	done
} # => verify_ca_init()

# init-pki backend:
init_pki() {
	# Process command options
	reset="hard"
	while [ "$1" ]; do
		case "$1" in
			hard-reset|hard)
				reset="hard"
				confirm_msg=
			;;
			soft-reset|soft)
				reset="soft"
				confirm_msg='PARTIALLY '
			;;
			*) warn "Ignoring unknown command option: '$1'"
		esac
		shift
	done

	# EasyRSA will NOT do 'rm -rf /'
	case "$EASYRSA_PKI" in
		.|..|./|../|.//*|..//*|/|//*|\\|?:|'')
			user_error "Invalid PKI: $EASYRSA_PKI"
	esac

	# If EASYRSA_PKI exists, confirm before deletion
	if [ -d "$EASYRSA_PKI" ]; then
		confirm "Confirm removal: " "yes" "
WARNING!!!

You are about to ${confirm_msg}remove the EASYRSA_PKI at:
* $EASYRSA_PKI

and initialize a fresh PKI here."

		# now remove it:
		case "$reset" in
		hard)
			# Promote use of 'init-pki soft':
			confirm "
  WARNING: COMPLETELY DESTROY current PKI (NOT recommended) ?

    [yes/NO]: " yes "\
         ******************************************
         * SECOND WARNING - STOP - SECOND WARNING *
         ******************************************

  To keep your current 'pki/vars' settings use 'init-pki soft'.
  To keep your current Request files use 'init-pki soft'
  The Requests can then be signed by a new CA (Partial CA renewal)
  To keep your current Easy-RSA TLS Key use 'init-pki soft'
  This private key file is in use by your current VPN.

       ** USE OF   'init-pki soft'   IS RECOMMENDED **${NL}"

			# # # shellcheck disable=SC2115 # Use "${var:?}"
			rm -rf "$EASYRSA_PKI" || \
				die "init-pki hard reset failed."
		;;
		soft)
		# There is no unit test for a soft reset
		# Save existing TLS key
			tls_key_file="$EASYRSA_PKI"/private/easyrsa-tls.key
			old_tls_key_file="$EASYRSA_PKI"/easyrsa-keepsafe-tls.key

			# If both keys exist then they must be the same
			if [ -f "$old_tls_key_file" ]; then
				if [ -f "$tls_key_file" ]; then
					# Match by hash
					tls_key_hash="$(
						"$EASYRSA_OPENSSL" dgst -sha256 \
							"$tls_key_file")"
					tls_key_hash="${tls_key_hash##* }"
					old_tls_key_hash="$(
						"$EASYRSA_OPENSSL" dgst -sha256 \
							"$old_tls_key_file")"
					old_tls_key_hash="${old_tls_key_hash##* }"
					[ "$tls_key_hash" = "$old_tls_key_hash" ] || \
						user_error "\
Easy-RSA TLS Keys do not match, only ONE of these files is valid:
* $tls_key_file
* $old_tls_key_file

Please delete the key above that is no longer in use."
				fi
			fi

			# Save existing TLS key
			if [ -f "$tls_key_file" ]; then
				tls_key_data="$(cat "$tls_key_file")"
			else
				tls_key_data=
			fi

			# Do NOT remove pki/reqs sub-dir, for "renew ca"
			for i in ca.crt crl.pem \
				issued private inline revoked renewed expired \
				serial serial.old index.txt index.txt.old \
				index.txt.attr index.txt.attr.old certs_by_serial
			do
				# # # shellcheck disable=SC2115 # Use "${var:?}"
				target="$EASYRSA_PKI/$i"
				if [ "${target%/*}" ]; then
					rm -rf "$target" || \
						die "init-pki soft reset(1) failed!"
				else
					die "init-pki soft reset(2) failed!"
				fi
			done
		;;
		*)
			user_error "Unknown reset type: $reset"
		esac
	fi

	# new dirs:
	easyrsa_mkdir "$EASYRSA_PKI"
	for i in issued private reqs; do
		easyrsa_mkdir "${EASYRSA_PKI}/$i"
	done

	# If one existed then recreate old TLS key backup file
	if [ "$tls_key_data" ]; then
		header="# Easy-RSA TLS Key: $(date)${NL}# DO NOT DELETE"
		printf '%s\n\n%s\n' "$header" "$tls_key_data" \
			> "$old_tls_key_file"
		tls_msg="${NL}
Previous Easy-RSA TLS key saved to:
* $old_tls_key_file${NL}"
	else
		# if an OLD TLS key still exists then notify user
		if [ -f "$old_tls_key_file" ]; then
			tls_msg="${NL}
Existing Easy-RSA TLS key preserved:
* $old_tls_key_file${NL}"
		else
			tls_msg=
		fi
	fi

	# write pki/vars.example - no temp-file because no session
	write_legacy_file_v2 \
		vars "$EASYRSA_PKI"/vars.example overwrite || \
			warn "init-pki - Failed to create vars.example"

	# User notice
	notice "\
'init-pki' complete; you may now create a CA or requests.

Your newly created PKI dir is:
* $EASYRSA_PKI"

	# Select and show vars file
	unset -v EASYRSA_VARS_FILE
	select_vars
	information "\
Using Easy-RSA configuration:
* ${EASYRSA_VARS_FILE:-undefined}${tls_msg}"
} # => init_pki()

# Find support files from various sources
# Declare in preferred order, first wins
# beaten by command line.
# If these files are not found here then they
# will be built on-demand by the selected command.
locate_support_files() {
	# Set required sources
	ssl_cnf_file='openssl-easyrsa.cnf'
	x509_types_dir='x509-types'
	easyrsa_tools='easyrsa-tools.lib'

	# Find data-files
	for area in \
		"$EASYRSA_PKI" \
		"$EASYRSA" \
		"$PWD" \
		"${0%/*}" \
		'/usr/local/share/easy-rsa' \
		'/usr/share/easy-rsa' \
		'/etc/easy-rsa' \
		# EOL
	do
		# Find x509-types
		if [ -d "${area}/${x509_types_dir}" ]; then
			set_var EASYRSA_EXT_DIR "${area}/${x509_types_dir}"
		fi

		# Find openssl-easyrsa.cnf
		if [ -f "${area}/${ssl_cnf_file}" ]; then
			set_var EASYRSA_SSL_CONF "${area}/${ssl_cnf_file}"
		fi

		# Find easyrsa-tools.lib
		if [ -f "${area}/${easyrsa_tools}" ]; then
			set_var EASYRSA_TOOLS_LIB "${area}/${easyrsa_tools}"
		fi
	done

	verbose ": EASYRSA_EXT_DIR: ${EASYRSA_EXT_DIR:-built-in}"
	verbose ": EASYRSA_SSL_CONF: ${EASYRSA_SSL_CONF:-built-in}"
	verbose ": EASYRSA_TOOLS_LIB: ${EASYRSA_TOOLS_LIB:-undefined}"
	verbose "locate_support_files: COMPLETED"
} # => locate_support_files()

# Disable terminal echo, if possible, otherwise warn
hide_read_pass() {
	# 3040 - In POSIX sh, set option [name] is undefined
	# 3045 - In POSIX sh, some-command-with-flag is undefined
	# 3061 - In POSIX sh, read without a variable is undefined.
	# shellcheck disable=SC3040,SC3045,SC3061
	if stty -echo 2>/dev/null; then
		prompt_restore=1
		read -r "$@"
		stty echo
	elif (set +o echo 2>/dev/null); then
		prompt_restore=2
		set +o echo
		read -r "$@"
		set -o echo
	elif (echo | read -r -s 2>/dev/null) ; then
		read -r -s "$@"
	else
		warn "\
Could not disable echo. Password will be shown on screen!"
		read -r "$@"
	fi
	prompt_restore=0
} # => hide_read_pass()

# Get passphrase
get_passphrase() {
	t="$1"; shift || die "password malfunction"
	while :; do
		r=""
		printf '\n%s' "$*"
		hide_read_pass r

		if [ "${#r}" -lt 4 ]; then
			printf '\n%s\n' \
				"Passphrase must be at least 4 characters!"
		else
			# shellcheck disable=SC2229 # does not read 't'
			read -r "$t" <<- SECRET
				$r
				SECRET

			unset -v r t
			print
			return 0
		fi
	done
} # => get_passphrase()

# build-ca backend:
build_ca() {
	cipher="-aes256"
	unset -v sub_ca date_stamp x509 error_info \
		ca_password_via_cmdline

	while [ "$1" ]; do
		case "$1" in
			intca|subca)
				sub_ca=1
				;;
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			raw*)
				EASYRSA_RAW_CA=1
				;;
			*) user_error "Unknown command option: '$1'"
		esac
		shift
	done

	out_key="$EASYRSA_PKI/private/ca.key"
	# setup for an intermediate CA
	if [ "$sub_ca" ]; then
		# Generate a CSR
		out_file="$EASYRSA_PKI/reqs/ca.req"
	else
		# Generate a certificate
		out_file="$EASYRSA_PKI/ca.crt"
		date_stamp=1
		x509=1
	fi

	# RAW mode must take priority
	if [ "$EASYRSA_RAW_CA" ]; then
		unset -v EASYRSA_NO_PASS EASYRSA_PASSOUT EASYRSA_PASSIN
		verbose "build-ca: CA password RAW method"
	else
		# If encrypted then create the CA key with AES256 cipher
		if [ "$EASYRSA_NO_PASS" ]; then
			unset -v cipher
		else
			unset -v no_password
		fi
	fi

	# Test for existing CA, and complain if already present
	if verify_ca_init test; then
		user_error "\
Unable to create a CA as you already seem to have one set up.
If you intended to start a new CA, run init-pki first."
	fi

	# If a private key exists, an intermediate ca was created
	# but not signed.
	# Notify user and require a signed ca.crt or a init-pki:
	if [ -f "$out_key" ]; then
		user_error "\
A CA private key exists but no ca.crt is found in your PKI:
* $EASYRSA_PKI

Refusing to create a new CA as this would overwrite your
current CA. To start a new CA, run init-pki first."
	fi

	# create necessary dirs:
	err_msg="\
Unable to create necessary PKI files (permissions?)"

	easyrsa_mkdir "${EASYRSA_PKI}"/certs_by_serial
	easyrsa_mkdir "${EASYRSA_PKI}"/revoked
	easyrsa_mkdir "${EASYRSA_PKI}"/revoked/certs_by_serial
	easyrsa_mkdir "${EASYRSA_PKI}"/revoked/private_by_serial

	# create necessary files:
	printf "" > \
		"$EASYRSA_PKI/index.txt" || die "$err_msg"
	printf '%s\n' "01" \
		> "$EASYRSA_PKI/serial" || die "$err_msg"
	unset -v err_msg

	# If one exists then recreate TLS Key
	tls_key_file="$EASYRSA_PKI"/private/easyrsa-tls.key
	old_tls_key_file="$EASYRSA_PKI"/easyrsa-keepsafe-tls.key
	if [ -f "$old_tls_key_file" ]; then
		confirm "Re-install existing Easy-RSA TLS Key ? " yes "
An Easy-RSA TLS Key, saved by 'init-pki soft', has been found.
This TLS Key is in use by your VPN, it is recommended that you
re-install this TLS Key.

Note:
This is a private key and will NOT be added to new inline files.

To create a new Easy-RSA TLS Key, delete this old TLS Key above."
		cp "$old_tls_key_file" "$tls_key_file" || \
			warn "Failed to install TLS Key!"
		tls_key_msg="${NL}
NOTICE: The previous Easy-RSA TLS Key has been installed:
* $tls_key_file

This TLS Key will NOT be added to new inline files. These new
inline files can then be easily distributed to your servers and
clients. The TLS Key that your servers and clients have previously
received, can be added to the inline file manually.

To re-enable automatically adding this TLS Key to inline files,
simply delete the backup TLS Key at:
* $old_tls_key_file

To create a new Easy-RSA TLS Key, delete both TLS Keys above."
	else
		tls_key_msg="${NL}
Create an OpenVPN TLS-AUTH|TLS-CRYPT-V1 key now: See 'help gen-tls'"
	fi

	# Set ssl batch mode, as required
	[ "$EASYRSA_BATCH" ] && ssl_batch=1

	# Default CA commonName
	if [ "$EASYRSA_REQ_CN" = ChangeMe ]; then
		if [ "$sub_ca" ]; then
			export EASYRSA_REQ_CN="Easy-RSA Sub-CA"
		else
			export EASYRSA_REQ_CN="Easy-RSA CA"
		fi
	fi

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	# Assign cert and key temp files
	out_key_tmp=""
	easyrsa_mktemp out_key_tmp || \
		die "build_ca - easyrsa_mktemp out_key_tmp"
	out_file_tmp=""
	easyrsa_mktemp out_file_tmp || \
		die "build_ca - easyrsa_mktemp out_file_tmp"

	# Get passphrase from user if necessary
	if [ "$EASYRSA_RAW_CA" ]
	then
		# Passphrase will be provided
		confirm "
       Accept ?  " yes "\
Raw CA mode
===========

  CA password must be input THREE times:

    1. Set the password.
    2. Confirm the password.
    3. Use the password. (Create the Root CA)"

	elif [ "$EASYRSA_NO_PASS" ]
	then
		: # No passphrase required

	elif [ "$EASYRSA_PASSOUT" ] && [ "$EASYRSA_PASSIN" ]
	then
		# passphrase defined on command line
		# Both --passout and --passin
		# must be defined for a CA with a password
		ca_password_via_cmdline=1

	else
		# Assign passphrase vars
		# Heed shellcheck SC2154
		p=""
		q=""

		# Get passphrase p
		get_passphrase p \
			"Enter New CA Key Passphrase: "

		# Confirm passphrase q
		get_passphrase q \
			"Confirm New CA Key Passphrase: "

		# Validate passphrase
		if [ "$p" ] && [ "$p" = "$q" ]; then
			# CA password via temp-files
			in_key_pass_tmp=""
			easyrsa_mktemp in_key_pass_tmp || \
				die "build_ca - in_key_pass_tmp"
			out_key_pass_tmp=""
			easyrsa_mktemp out_key_pass_tmp || \
				die "build_ca - out_key_pass_tmp"
			printf "%s" "$p" > "$in_key_pass_tmp" || \
				die "in_key_pass_tmp: write"
			printf "%s" "$p" > "$out_key_pass_tmp" || \
				die "out_key_pass_tmp: write"
			unset -v p q
		else
			unset -v p q
			user_error "Passphrases do not match!"
		fi
	fi

	# Find or create x509 CA file
	if [ -f "$EASYRSA_EXT_DIR/ca" ]; then
		# Use the x509-types/ca file
		x509_type_file="$EASYRSA_EXT_DIR/ca"
	else
		# Use a temp file
		write_x509_type_tmp ca
		x509_type_file="$write_x509_file_tmp"
	fi

	# keyUsage critical
	if [ "$EASYRSA_KU_CRIT" ]; then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "build-ca - easyrsa_mktemp KU crit_tmp"

		add_critical_attrib keyUsage "$x509_type_file" \
			"$crit_tmp" || die "build-ca - KU add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		verbose "build_ca: keyUsage critical OK"
	fi

	# basicConstraints critical
	if [ "$EASYRSA_BC_CRIT" ]; then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "build-ca - easyrsa_mktemp BC crit_tmp"

		add_critical_attrib basicConstraints "$x509_type_file" \
			"$crit_tmp" || die "build-ca - BC add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		verbose "build_ca: basicConstraints critical OK"
	fi

	# Find or create x509 COMMON file
	if [ -f "$EASYRSA_EXT_DIR/COMMON" ]; then
		# Use the x509-types/COMMON file
		x509_COMMON_file="$EASYRSA_EXT_DIR/COMMON"
	else
		# Use a temp file
		write_x509_type_tmp COMMON
		x509_COMMON_file="$write_x509_file_tmp"
	fi

	# Check for insert-marker in ssl config file
	if ! grep -q '^#%CA_X509_TYPES_EXTRA_EXTS%' \
		"$EASYRSA_SSL_CONF"
	then
		die "\
This openssl config file does not support X509-type 'ca'.
* $EASYRSA_SSL_CONF

Please update 'openssl-easyrsa.cnf' to the latest Easy-RSA release."
	fi

	# Assign awkscript to insert EASYRSA_EXTRA_EXTS
	# shellcheck disable=SC2016 # No expand '' - build_ca()
	awkscript='\
{if ( match($0, "^#%CA_X509_TYPES_EXTRA_EXTS%") )
{ while ( getline<"/dev/stdin" ) {print} next }
{print}
}'

	# Assign tmp-file for config
	adjusted_ssl_cnf_tmp=""
	easyrsa_mktemp adjusted_ssl_cnf_tmp || \
		die "build_ca - easyrsa_mktemp adjusted_ssl_cnf_tmp"

	# Insert x509-types COMMON and 'ca' and EASYRSA_EXTRA_EXTS
	{
		# X509 files
		cat "$x509_type_file" "$x509_COMMON_file"

		# User extensions
		[ "$EASYRSA_EXTRA_EXTS" ] && \
			print "$EASYRSA_EXTRA_EXTS"

	} | awk "$awkscript" "$EASYRSA_SSL_CONF" \
			> "$adjusted_ssl_cnf_tmp" || \
				die "Copying X509_TYPES to config file failed"
	verbose "build-ca: insert x509 and extensions OK"

	# Use this new SSL config for the rest of this function
	EASYRSA_SSL_CONF="$adjusted_ssl_cnf_tmp"

	# Generate CA Key
	case "$EASYRSA_ALGO" in
	rsa)
	easyrsa_openssl genpkey \
		-algorithm "$EASYRSA_ALGO" \
		-pkeyopt rsa_keygen_bits:"$EASYRSA_ALGO_PARAMS" \
		-out "$out_key_tmp" \
		${cipher:+ "$cipher"} \
		${EASYRSA_PASSOUT:+ -pass "$EASYRSA_PASSOUT"} \
		${out_key_pass_tmp:+ -pass file:"$out_key_pass_tmp"} \
			|| die "Failed create CA private key"
	;;
	ec)
	easyrsa_openssl genpkey \
		-paramfile "$EASYRSA_ALGO_PARAMS" \
		-out "$out_key_tmp" \
		${cipher:+ "$cipher"} \
		${EASYRSA_PASSOUT:+ -pass "$EASYRSA_PASSOUT"} \
		${out_key_pass_tmp:+ -pass file:"$out_key_pass_tmp"} \
			|| die "Failed create CA private key"
	;;
	ed)
	easyrsa_openssl genpkey \
		-algorithm "$EASYRSA_CURVE" \
		-out "$out_key_tmp" \
		${cipher:+ "$cipher"} \
		${EASYRSA_PASSOUT:+ -pass "$EASYRSA_PASSOUT"} \
		${out_key_pass_tmp:+ -pass file:"$out_key_pass_tmp"} \
			|| die "Failed create CA private key"
	;;
	*) die "Unknown algorithm: $EASYRSA_ALGO"
	esac

	# verbose notice
	if [ "$EASYRSA_RAW_CA" ]; then
		verbose "\
build_ca: CA key password created via RAW"
	else
		if [ "$ca_password_via_cmdline" ]; then
			verbose "\
build_ca: CA key password created via command options"
		else
			if [ "$EASYRSA_NO_PASS" ]; then
				verbose "\
build_ca: CA key has no password"
			else
				verbose "\
build_ca: CA key password created via temp-files"
			fi
		fi
	fi

	# Generate the CA keypair:
	easyrsa_openssl req -utf8 -new \
		-key "$out_key_tmp" \
		-out "$out_file_tmp" \
		${ssl_batch:+ -batch} \
		${x509:+ -x509} \
		${date_stamp:+ -days "$EASYRSA_CA_EXPIRE"} \
		${EASYRSA_DIGEST:+ -"$EASYRSA_DIGEST"} \
		${EASYRSA_NO_PASS:+ "$no_password"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
		${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} \
		${in_key_pass_tmp:+ -passin file:"$in_key_pass_tmp"} \
		${out_key_pass_tmp:+ -passout file:"$out_key_pass_tmp"} \
			|| die "Failed to build the CA keypair"

	# Move temp-files to target-files
	mv "$out_key_tmp" "$out_key" || mv_temp_error=1
	mv "$out_file_tmp" "$out_file" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		rm -f "$out_key" "$out_file"
		die "Failed to move new CA files."
	fi

	# Success messages
	if [ "$sub_ca" ]; then
		notice "\
Your intermediate CA request is at:
* $out_file
  and now must be sent to your parent CA for signing.

Prior to signing operations, place your resulting Sub-CA cert at:
* $EASYRSA_PKI/ca.crt"
	else
		notice "\
CA creation complete. Your new CA certificate is at:
* $out_file${tls_key_msg}

Build-ca completed successfully."
	fi
} # => build_ca()

# Build self signed key pair
self_sign() {
	# Define x509 type
	case "$1" in
		server)
			selfsign_eku=serverAuth
			crt_type=self-signed-server
			;;
		client)
			selfsign_eku=clientAuth
			crt_type=self-signed-client
			;;
		*)
			die "self_sign: Unknown EKU '$1'"
	esac
	shift

	# pull $file_name_base
	[ "$1" ] || user_error "\
Error: didn't find a file base name as the first argument.
Run easyrsa without commands for usage and command help."

	file_name_base="$1"
	shift

	# Prohibit --req-cn
	[ "$EASYRSA_REQ_CN" = ChangeMe ] || user_error "\
Option conflict --req-cn:
* '$cmd' does not support setting an external commonName"

	# Enforce commonName
	export EASYRSA_REQ_CN="$file_name_base"

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	# Refuse option as name
	case "$file_name_base" in
		nopass)
			user_error "Refusing '$file_name_base' as name."
	esac

	# function opts support
	while [ "$1" ]; do
		case "$1" in
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			*)
				user_error "Unknown command option: '$1'"
		esac
		shift
	done

	# Assign output files
	key_out="$EASYRSA_PKI/private/${file_name_base}.key"
	crt_out="$EASYRSA_PKI/issued/${file_name_base}.crt"
	inline_out="$EASYRSA_PKI/inline/${file_name_base}.inline"

	# key file must NOT exist
	[ -f "$key_out" ] && user_error "\
Cannot self-sign this request for '$file_name_base'.
Conflicting key exists at:
* $key_out"

	# Certificate file must NOT exist
	[ -f "$crt_out" ] && user_error "\
Cannot self-sign this request for '$file_name_base'.
Conflicting certificate exists at:
* $crt_out"

	# Check algo and curve
	case "$EASYRSA_ALGO" in
		rsa|ec)
			# Silently use ec instead of rsa
			export EASYRSA_ALGO=ec
			# Selectively set --curve=secp384r1
			set_var EASYRSA_CURVE secp384r1

			# temp-file for params-file
			selfsign_params_file=""
			easyrsa_mktemp selfsign_params_file || \
				die "self_sign - easyrsa_mktemp selfsign_params_file"

			# params-file
			"$EASYRSA_OPENSSL" ecparam \
				-name "$EASYRSA_CURVE" \
				-out "$selfsign_params_file" || \
					die "self_sign - params-file failed"

			newkey_params="$EASYRSA_ALGO":"$selfsign_params_file"
			;;
		ed)
			# Selectively set --curve=ed25519
			set_var EASYRSA_CURVE ed25519
			newkey_params="$EASYRSA_CURVE"
			;;
		*)
			user_error "Unrecognised algorithm: '$EASYRSA_ALGO'"
	esac

	verbose "\
self-sign: Use ALGO:'$EASYRSA_ALGO' / CURVE:'$EASYRSA_CURVE'"

	# Assign tmp-file for config
	adjusted_ssl_cnf_tmp=""
	easyrsa_mktemp adjusted_ssl_cnf_tmp || \
		die "self_sign - easyrsa_mktemp adjusted_ssl_cnf_tmp"

	# Assign awkscript to insert EASYRSA_EXTRA_EXTS
	# shellcheck disable=SC2016 # No expand '' - build_ca()
	awkscript='\
{if ( match($0, "^#%CA_X509_TYPES_EXTRA_EXTS%") )
	{ while ( getline<"/dev/stdin" ) {print} next }
 {print}
}'

	# Find or create x509 selfsign file
	if [ -f "$EASYRSA_EXT_DIR/selfsign" ]; then
		# Use the x509-types/selfsign file
		x509_selfsign_file="$EASYRSA_EXT_DIR/selfsign"
	else
		# Use a temp file
		write_x509_type_tmp selfsign
		x509_selfsign_file="$write_x509_file_tmp"
	fi

	# Find or create x509 COMMON file
	if [ -f "$EASYRSA_EXT_DIR/COMMON" ]; then
		# Use the x509-types/COMMON file
		x509_COMMON_file="$EASYRSA_EXT_DIR/COMMON"
	else
		# Use a temp file
		write_x509_type_tmp COMMON
		x509_COMMON_file="$write_x509_file_tmp"
	fi

	# Insert x509-types COMMON and 'selfsign' and EASYRSA_EXTRA_EXTS
	{
		# X509 files
		cat "$x509_selfsign_file" "$x509_COMMON_file"

		# User extensions
		[ "$EASYRSA_EXTRA_EXTS" ] && \
			print "$EASYRSA_EXTRA_EXTS"

	} | awk "$awkscript" "$EASYRSA_SSL_CONF" \
			> "$adjusted_ssl_cnf_tmp" || \
				die "Copying X509_TYPES to config file failed"
	verbose "self_sign: insert x509 and extensions OK"

	# Use this new SSL config for the rest of this function
	EASYRSA_SSL_CONF="$adjusted_ssl_cnf_tmp"

	# Create temp-files for output
	tmp_key_out=""
	easyrsa_mktemp tmp_key_out || \
		die "self_sign - easyrsa_mktemp tmp_key_out"

	tmp_crt_out=""
	easyrsa_mktemp tmp_crt_out || \
		die "self_sign - easyrsa_mktemp tmp_crt_out"

	# create self-signed key pair
	easyrsa_openssl req -x509 -utf8 -sha256 -text \
		-newkey "$newkey_params" \
		-keyout "$tmp_key_out" \
		-out "$tmp_crt_out" \
		-subj "/CN=$file_name_base" \
		${EASYRSA_NO_PASS:+ "$no_password"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
		${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} \
		${EASYRSA_CERT_EXPIRE:+ -days "$EASYRSA_CERT_EXPIRE"} \
		${EASYRSA_START_DATE:+ -startdate "$EASYRSA_START_DATE"} \
		${EASYRSA_END_DATE:+ -enddate "$EASYRSA_END_DATE"}

	# Move temp-files to target-files
	mv "$tmp_key_out" "$key_out" || mv_temp_error=1
	mv "$tmp_crt_out" "$crt_out" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		rm -f "$key_out" "$crt_out"
		die "Failed to move new key/cert files."
	fi

	# inline key/cert/fingerprint
	inline_file "$file_name_base"

	# User info
	notice "\
Self-signed '$EASYRSA_ALGO/$EASYRSA_CURVE' \
key and certificate created:
* $key_out
* $crt_out"
} # => self_sign()

# gen-dh backend:
gen_dh() {
	out_file="$EASYRSA_PKI/dh.pem"

	# check to see if we already have a dh parameters file
	if [ -f "$out_file" ]; then
		if [ "$EASYRSA_BATCH" ]; then
			# if batch is enabled, die
			user_error "\
DH parameters file already exists
at: $out_file"
		else
			# warn the user, allow to force overwrite
			confirm "Overwrite?  " "yes" "\
DH parameters file already exists
at: $out_file"
		fi
	fi

	# Create a temp file
	# otherwise user abort leaves an incomplete dh.pem
	tmp_dh_file=""
	easyrsa_mktemp tmp_dh_file || \
		die "gen_dh - easyrsa_mktemp tmp_dh_file"

	# Generate dh.pem
	easyrsa_openssl dhparam -out "$tmp_dh_file" \
		"$EASYRSA_KEY_SIZE" || die "Failed to generate DH params"

	# Validate dh.pem
	easyrsa_openssl dhparam -in "$tmp_dh_file" \
		-check -noout || die "Failed to validate DH params"

	# Move temp-files to target-files
	mv "$tmp_dh_file" "$out_file" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		rm -f "$out_file"
		die "Failed to move temp DH file."
	fi

	notice "
DH parameters of size $EASYRSA_KEY_SIZE created at:
* $out_file"
} # => gen_dh()

# gen-req and key backend:
gen_req() {
	# pull filename, use as default interactive CommonName
	[ "$1" ] || user_error "\
Error: gen-req must have a file-name-base as the first argument.
Run easyrsa without commands for usage and commands."

	file_name_base="$1"
	shift # scrape off file-name-base

	# Set ssl batch mode as required
	[ "$EASYRSA_BATCH" ] && ssl_batch=1

	# Set commonName
	if [ "$EASYRSA_REQ_CN" = ChangeMe ]; then
		export EASYRSA_REQ_CN="$file_name_base"
	fi

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	# Output files
	key_out="$EASYRSA_PKI/private/${file_name_base}.key"
	req_out="$EASYRSA_PKI/reqs/${file_name_base}.req"

	# function opts support
	while [ "$1" ]; do
		case "$1" in
			text)
				text=1
				;;
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			# batch flag supports internal caller build_full()
			batch)
				ssl_batch=1
				;;
			*) user_error "Unknown command option: '$1'"
		esac
		shift
	done

	# don't wipe out an existing request without confirmation
	[ -f "$req_out" ] && confirm "Confirm request overwrite: " "yes" "\

WARNING!!!

An existing request file was found at
* $req_out

Continuing with key generation will replace this request."

	# don't wipe out an existing private key without confirmation
	[ -f "$key_out" ] && confirm "Confirm key overwrite: " "yes" "\

WARNING!!!

An existing private key was found at
* $key_out

Continuing with key generation will replace this key."

	# When EASYRSA_EXTRA_EXTS is defined,
	# append it to openssl's [req] section:
	if [ "$EASYRSA_EXTRA_EXTS" ]; then
		# Check for insert-marker in ssl config file
		if ! grep -q '^#%EXTRA_EXTS%' "$EASYRSA_SSL_CONF"
		then
			die "\
This openssl config file does \
does not support EASYRSA_EXTRA_EXTS.
* $EASYRSA_SSL_CONF

Please update 'openssl-easyrsa.cnf' \
to the latest Easy-RSA release."
		fi

		# Setup & insert the extra ext data keyed by magic line
		extra_exts="
req_extensions = req_extra
[ req_extra ]
$EASYRSA_EXTRA_EXTS"
		# shellcheck disable=SC2016 # No expand '' - gen_req()
		awkscript='
{if ( match($0, "^#%EXTRA_EXTS%") )
	{ while ( getline<"/dev/stdin" ) {print} next }
 {print}
}'
		# Assign temp-file for config
		adjusted_ssl_cnf_tmp=""
		easyrsa_mktemp adjusted_ssl_cnf_tmp || \
			die "gen_req - easyrsa_mktemp adjusted_ssl_cnf_tmp"

		# Insert $extra_exts @ %EXTRA_EXTS% in SSL Config
		print "$extra_exts" | \
			awk "$awkscript" "$EASYRSA_SSL_CONF" \
			> "$adjusted_ssl_cnf_tmp" || \
				die "Writing SSL config to temp file failed"

		[ "${EASYRSA_SAN_CRIT}" ] && \
			verbose "gen-req: SAN critical OK"

		# Use this SSL config for the rest of this function
		EASYRSA_SSL_CONF="$adjusted_ssl_cnf_tmp"
	fi

	# Name temp files
	key_out_tmp=""
	easyrsa_mktemp key_out_tmp || \
		die "gen_req - easyrsa_mktemp key_out_tmp"
	req_out_tmp=""
	easyrsa_mktemp req_out_tmp || \
		die "gen_req - easyrsa_mktemp req_out_tmp"

	# Set algorithm options
	algo_opts=""
	case "$EASYRSA_ALGO" in
		rsa|ec)
			# Set elliptic curve parameters-file
			# or RSA bit-length
			algo_opts="$EASYRSA_ALGO:$EASYRSA_ALGO_PARAMS"
			;;
		ed)
			# Set Edwards curve name
			algo_opts="$EASYRSA_CURVE"
			;;
		*)
			die "gen_req - Unknown algorithm: $EASYRSA_ALGO"
	esac

	# Generate request
	if easyrsa_openssl req -utf8 -new -newkey "$algo_opts" \
		-keyout "$key_out_tmp" \
		-out "$req_out_tmp" \
		${EASYRSA_NO_PASS:+ "$no_password"} \
		${text:+ -text} \
		${ssl_batch:+ -batch} \
		${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"}
	then
		: # ok
	else
		die "Failed to generate request"
	fi

	# Move temp-files to target-files
	mv "$key_out_tmp" "$key_out" || mv_temp_error=1
	mv "$req_out_tmp" "$req_out" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		rm -f "$key_out" "$req_out"
		die "Failed to move temp key/req file."
	fi

	# Success messages
	notice "\
Private-Key and Public-Certificate-Request files created.
Your files are:
* req: $req_out
* key: $key_out${do_build_full:+ $NL}"
} # => gen_req()

# common signing backend
sign_req() {
	crt_type="$1"
	file_name_base="$2"

	# Verify $crt_type is valid
	case "$crt_type" in
		ca|server|serverClient|client|codeSigning|email|kdc)
			: # All known types plus CA for sub-ca
		;;
		*)
			warn "\
Unrecognised x509-type: '$crt_type'

In order to sign a custom X509 Type certificate, there must be a
corresponding SSL configuration file in the 'x509-types' folder."
	esac

	# Check argument sanity:
	[ "$file_name_base" ] || user_error "\
Incorrect number of arguments provided to sign-req:
expected 2, got $# (see command help for usage)"

	req_in="$EASYRSA_PKI/reqs/$file_name_base.req"
	crt_out="$EASYRSA_PKI/issued/$file_name_base.crt"
	shift 2

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	# Check optional subject
	force_subj=
	while [ "$1" ]; do
		case "$1" in
			nopass)
				warn "Ignoring option '$1'"
				;;
			newsubj*)
				# verify force_subj opts are used correctly
				[ "$EASYRSA_NEW_SUBJECT" ] || user_error "\
To force a new certificate subject, global option --new-subject
must also be specified."
				force_subj="$EASYRSA_NEW_SUBJECT"
				;;
			preserve*)
				export EASYRSA_PRESERVE_DN=1
				;;
			*)
				user_error "Unknown option '$1'"
		esac
		shift
	done

	# verify force_subj opts are used correctly
	if [ "$EASYRSA_NEW_SUBJECT" ]; then
		[ "$force_subj" ] || user_error "\
To force a new certificate subject, command option 'newsubj'
must also be specified."
	fi

	# Cert type must NOT be COMMON
	[ "$crt_type" = COMMON ] && user_error "\
Invalid certificate type: '$crt_type'"

	# Request file must exist
	[ -f "$req_in" ] || user_error "\
No request found for the input: '$file_name_base'
Expected to find the request at:
* $req_in"

	# Certificate file must NOT exist
	[ -f "$crt_out" ] && user_error "\
Cannot sign this request for '$file_name_base'.
Conflicting certificate exists at:
* $crt_out"

	# Confirm input is a cert req
	verify_file req "$req_in" || user_error "\
The certificate request file is not in a valid X509 format:
* $req_in"

	# Randomize Serial number
	if [ "$EASYRSA_RAND_SN" != no ]; then
		serial=""
		check_serial=""
		unset -v serial_is_unique
		for i in 1 2 3 4 5; do
			easyrsa_random 16 serial

			# Require 128bit serial number
			[ "$serial" = "${serial#00}" ] || continue

			# Check for duplicate serial in CA db
			if check_serial_unique "$serial" batch; then
				serial_is_unique=1
				break
			fi
		done

		# Check for unique_serial
		[ "$serial_is_unique" ] || die "\
sign_req - Randomize Serial number failed:

$check_serial"

		# Print random $serial to pki/serial file
		# for use by SSL config
		print "$serial" > "$EASYRSA_PKI/serial" || \
			die "sign_req - write serial to file"
		unset -v serial check_serial serial_is_unique
	fi

	# When EASYRSA_CP_EXT is defined,
	# adjust openssl's [default_ca] section:
	if [ "$EASYRSA_CP_EXT" ]; then
		# Check for insert-marker in ssl config file
		if ! grep -q '^#%COPY_EXTS%' "$EASYRSA_SSL_CONF"
		then
			die "\
This openssl config file does \
not support option '--copy-ext'.
* $EASYRSA_SSL_CONF

Please update 'openssl-easyrsa.cnf' \
to the latest Easy-RSA release."
		fi

		# Setup & insert the copy_extensions data
		# keyed by a magic line
		copy_exts="copy_extensions = copy"
		# shellcheck disable=SC2016 # No expand '' - sign_req()
		awkscript='
{if ( match($0, "^#%COPY_EXTS%") )
	{ while ( getline<"/dev/stdin" ) {print} next }
 {print}
}'
		# Assign temp-file for config
		adjusted_ssl_cnf_tmp=""
		easyrsa_mktemp adjusted_ssl_cnf_tmp || \
			die "sign_req - easyrsa_mktemp adjusted_ssl_cnf_tmp"

		print "$copy_exts" | \
			awk "$awkscript" "$EASYRSA_SSL_CONF" \
				> "$adjusted_ssl_cnf_tmp" || die "\
Writing 'copy_exts' to SSL config temp-file failed"

		# Use this SSL config for the rest of this function
		EASYRSA_SSL_CONF="$adjusted_ssl_cnf_tmp"
		verbose "sign_req: Using '$copy_exts'"
		verbose "sign_req: EASYRSA_SSL_CONF = $EASYRSA_SSL_CONF"
	fi

	# Find or create x509-type file
	if [ -f "$EASYRSA_EXT_DIR/$crt_type" ]; then
		# Use the x509-types/$crt_type file
		x509_type_file="$EASYRSA_EXT_DIR/$crt_type"
	else
		# Use a temp file
		write_x509_type_tmp "$crt_type"
		x509_type_file="$write_x509_file_tmp"
	fi

	# keyUsage critical
	confirm_ku_crit=
	if [ "$EASYRSA_KU_CRIT" ]; then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "sign-req - easyrsa_mktemp KU crit_tmp"

		add_critical_attrib keyUsage "$x509_type_file" \
			"$crit_tmp" || die "sign-req - KU add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		confirm_ku_crit="  keyUsage:         'critical'${NL}"
		verbose "sign_req: keyUsage critical OK"
	fi

	# basicConstraints critical
	confirm_bc_crit=
	if [ "$EASYRSA_BC_CRIT" ]; then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "sign-req - easyrsa_mktemp BC crit_tmp"

		add_critical_attrib basicConstraints "$x509_type_file" \
			"$crit_tmp" || die "sign-req - BC add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		confirm_bc_crit="  basicConstraints: 'critical'${NL}"
		verbose "sign_req: basicConstraints critical OK"
	fi

	# extendedKeyUsage critical
	confirm_eku_crit=
	if [ "$EASYRSA_EKU_CRIT" ]; then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "sign-req - easyrsa_mktemp EKU crit_tmp"

		add_critical_attrib extendedKeyUsage "$x509_type_file" \
			"$crit_tmp" || die "sign-req - EKU add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		confirm_eku_crit="  extendedKeyUsage: 'critical'${NL}"
		verbose "sign_req: extendedKeyUsage critical OK"
	fi

	# Find or create x509 COMMON file
	if [ -f "$EASYRSA_EXT_DIR/COMMON" ]; then
		# Use the x509-types/COMMON file
		x509_COMMON_file="$EASYRSA_EXT_DIR/COMMON"
	else
		# Use a temp file
		write_x509_type_tmp COMMON
		x509_COMMON_file="$write_x509_file_tmp"
	fi

	# Support a dynamic CA path length when present:
	unset -v basicConstraints confirm_bc_len
	if [ "$crt_type" = "ca" ] && [ "$EASYRSA_SUBCA_LEN" ]
	then
		# Print the last occurrence of basicConstraints in
		# x509-types/ca
		# If basicConstraints is not defined then bail
		# shellcheck disable=SC2016 # No expand '' - sign_req()
		awkscript='\
/^[[:blank:]]*basicConstraints[[:blank:]]*=/ { bC=$0 }
END { if (length(bC) == 0 ) exit 1; print bC }'
		basicConstraints="$(
			awk "$awkscript" "$x509_type_file"
			)" || die "\
basicConstraints is not defined, cannot use 'pathlen'"
		confirm_pathlen="
  Path length:      '$EASYRSA_SUBCA_LEN'${NL}"
		verbose "sign_req: Using basicConstraints pathlen"
	fi

	# Deprecated Netscape extension support
	case "$EASYRSA_NS_SUPPORT" in
	[yY][eE][sS])

		confirm "Confirm use of Netscape extensions: " yes \
			"WARNING: Netscape extensions are DEPRECATED!"

		# Netscape extension
		case "$crt_type" in
			serverClient)
				ns_cert_type="nsCertType = serverClient" ;;
			server)
				ns_cert_type="nsCertType = server" ;;
			client)
				ns_cert_type="nsCertType = client" ;;
			ca)
				ns_cert_type="nsCertType = sslCA" ;;
			*)
				ns_cert_type="nsCertType = $crt_type"
		esac
		verbose "sign_req: Using $ns_cert_type"
		;;
	*)
		# ok No NS support required
		unset -v ns_cert_type
	esac

	# Get request CN
	# EASYRSA_REQ_CN MUST always be set to the CSR CN
	# or use --new-subect
	EASYRSA_REQ_CN="$(
		"$EASYRSA_OPENSSL" req -utf8 -in "$req_in" -noout \
			-subject -nameopt multiline | grep 'commonName'
	)" || warn "sign-req - EASYRSA_REQ_CN FAILED"
	EASYRSA_REQ_CN="${EASYRSA_REQ_CN##*= }"

	# Add auto SAN, if EASYRSA_AUTO_SAN is enabled
	if [ -z "$EASYRSA_SAN" ] && [ "$EASYRSA_AUTO_SAN" ]; then
		# Choose DNS:san or IP:san
		if print "$EASYRSA_REQ_CN" | grep -q \
			'^[0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+$'
		then
			EASYRSA_SAN="IP:${EASYRSA_REQ_CN}"
		else
			EASYRSA_SAN="DNS:${EASYRSA_REQ_CN}"
		fi

		# Add auto SAN to EASYRSA_EXTRA_EXTS
		EASYRSA_EXTRA_EXTS="\
$EASYRSA_EXTRA_EXTS
subjectAltName = ${EASYRSA_SAN_CRIT}${EASYRSA_SAN}"
		verbose "sign-req: Auto SAN: ${EASYRSA_SAN}"
	fi

	# confirm SAN critical
	confirm_san_crit=
	if [ "${EASYRSA_SAN_CRIT}" ]; then
		confirm_san_crit="  subjectAltName:   'critical'${NL}"
		verbose "sign-req: SAN critical OK"
	fi

	# Generate the extensions file for this cert:
	ext_tmp=""
	easyrsa_mktemp ext_tmp || \
		die "sign_req - easyrsa_mktemp ext_tmp"

	# Begin output redirect
	{
		# Append $cert-type extensions
		cat "$x509_COMMON_file" "$x509_type_file"

		# Support a dynamic CA path length when present:
		if [ "$basicConstraints" ]; then
			print "$basicConstraints, pathlen:$EASYRSA_SUBCA_LEN"
		fi

		# Deprecated Netscape extension support
		if [ "$ns_cert_type" ]; then
			print "$ns_cert_type"
			print "nsComment = \"$EASYRSA_NS_COMMENT\""
		fi

		# Add user supplied extra extensions
		# and/or SAN extension
		if [ "$EASYRSA_EXTRA_EXTS" ]; then
			print "$EASYRSA_EXTRA_EXTS"
		fi
	} > "$ext_tmp" || die "\
Failed to create temp extension file (bad permissions?) at:
* $ext_tmp"
	verbose "sign_req: Generated extensions file OK"

	# Set confirm CN
	confirm_CN="  Requested CN:     '$EASYRSA_REQ_CN'"

	# Set confirm type
	confirm_type="  Requested type:   '$crt_type'"

	# Set confirm valid_period message
	if [ "$EASYRSA_END_DATE" ]; then
		confirm_period="  Valid until:      '$EASYRSA_END_DATE'"
	else
		confirm_period="  Valid for:        '$EASYRSA_CERT_EXPIRE' days"
	fi

	# Set confirm DN
	if [ "$force_subj" ]; then
		confirm_dn="${NL}* Forced Subject:   '$force_subj'${NL}"
	else
		confirm_dn="${NL}$(display_dn req "$req_in")" || \
			die "sign-req: display_dn"
	fi

	# Set confirm SAN
	# SAN from .req
	if [ "$EASYRSA_CP_EXT" ]; then
		# capture complete CSR
		req_text="$(
			"$EASYRSA_OPENSSL" req -utf8 -in "$req_in" -noout -text
			)" || die "sign-req: openssl: req_text"

		# Check CSR for any requested SAN
		if echo "$req_text" | \
			grep -q 'X509v3 Subject Alternative Name'
		then
			# extract requested SAN
			# 'grep -A' may not be strictly POSIX, die on error
			req_x509_san="$(
				echo "$req_text" | \
					grep -A 1 'X509v3 Subject Alternative Name'
			)" || die "sign-req: req_x509_san: grep -A 1 (POSIX)"
		else
			# No requested SAN
			req_x509_san=
		fi
	fi

	# Set confirm details
	confirm_critical_attribs="
${confirm_bc_crit}${confirm_ku_crit}\
${confirm_eku_crit}${confirm_san_crit}"

	confirm_details="\
${confirm_CN}
${confirm_type}${confirm_pathlen}
${confirm_period}
${confirm_critical_attribs}${confirm_dn}"

	# --san takes priority over req SAN and --copy-ext
	if [ "$EASYRSA_SAN" ]; then
		confirm_san="\
            X509v3 Subject Alternative Name:
                ${EASYRSA_SAN_CRIT}${EASYRSA_SAN}"
	else
		confirm_san="$req_x509_san"
	fi

	# Set confirm SAN
	if [ "$EASYRSA_SAN" ] || [ "$req_x509_san" ]; then
		confirm_details="$confirm_details${NL}${NL}$confirm_san"
	fi

	# Display the request subject in an easy-to-read format
	# Confirm the user wishes to sign this request
	# The foreign_request confirmation is not required
	# for build_full:
	if [ "$local_request" ]; then
		unset -v foreign_request
	else
		foreign_request="\
Please check over the details shown below for accuracy. \
Note that this request
has not been cryptographically verified. Please be sure \
it came from a trusted
source or that you have verified the request checksum \
with the sender.$NL"
	fi

	# Request FINAL user confirmation
	confirm "Confirm requested details: " "yes" "\
${foreign_request}You are about to sign the following certificate:

$confirm_details" # => confirm end

	# Assign temp cert file
	crt_out_tmp=""
	easyrsa_mktemp crt_out_tmp || \
		die "sign_req - easyrsa_mktemp crt_out_tmp"

	# sign request
	easyrsa_openssl ca -utf8 -batch \
		-in "$req_in" -out "$crt_out_tmp" \
		-extfile "$ext_tmp" \
		${EASYRSA_PRESERVE_DN:+ -preserveDN} \
		${force_subj:+ -subj "$force_subj"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
		${EASYRSA_NO_TEXT:+ -notext} \
		${EASYRSA_CERT_EXPIRE:+ -days "$EASYRSA_CERT_EXPIRE"} \
		${EASYRSA_START_DATE:+ -startdate "$EASYRSA_START_DATE"} \
		${EASYRSA_END_DATE:+ -enddate "$EASYRSA_END_DATE"} \
			|| die "\
Signing failed (openssl output above may have more detail)"
	verbose "sign_req: signed cert '$file_name_base' OK"

	# Move temp-files to target-files
	mv "$crt_out_tmp" "$crt_out" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		rm -f "$crt_out"
		die "Failed to move temp certificate file."
	fi

	# inline file
	inline_file "$file_name_base"

	# Success messages
	notice "\
Certificate created at:
* $crt_out"
} # => sign_req()

# Add 'critical' attribute to X509-type file
add_critical_attrib() {
	case "$1" in
		basicConstraints|keyUsage|extendedKeyUsage) : ;; # ok
		*) die "add_critical_attrib - usage: '$1'"
	esac

	[ -f "$2" ] || die "add_critical_attrib - file-2: '$2'"
	[ -f "$3" ] || die "add_critical_attrib - file-3: '$3'"

	sed s/"$1 = "/"$1 = critical,"/g "$2" > "$3"
} # => add_critical_attrib()

# Check serial in db
check_serial_unique() {
	[ "$1" ] || user_error "Serial number required!"
	case "$1" in
		(*[!1234567890abcdef]*)
			user_error "Invalid serial number: '$1'"
	esac

	# Check for openssl -status of serial number
	# Always errors out - Do not capture error
	check_serial="$(
			"$EASYRSA_OPENSSL" ca -status "$1" 2>&1
		)" || :

	# Check for duplicate serial in CA db
	case "$check_serial" in
		(*"not present in db"*)
			unique_serial_true=1
			verbose "check_serial_unique: unique_serial=true"
			;;
		*)
			unique_serial_true=
			verbose "check_serial_unique: unique_serial=false"
	esac

	# In batch mode return result only
	if [ "$2" = batch ] || [ "$EASYRSA_BATCH" ]; then
		if [ "$unique_serial_true" ]; then
			return 0
		else
			return 1
		fi
	fi

	# Otherwise, show result to user
	# and do not return any error code
	print "
check_serial_status RESULT:
========================================

$check_serial

========================================
COMPLETE"
} # => check_serial_unique()

# common build backend
# used to generate+sign in 1 step
build_full() {
	# pull filename base:
	[ "$2" ] || user_error "\
Error: didn't find a file base name as the first argument.
Run easyrsa without commands for usage and commands."

	crt_type="$1"
	name="$2"
	shift 2

	req_out="$EASYRSA_PKI/reqs/$name.req"
	key_out="$EASYRSA_PKI/private/$name.key"
	crt_out="$EASYRSA_PKI/issued/$name.crt"

	# function opts support
	while [ "$1" ]; do
		case "$1" in
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			*) user_error "Unknown command option: '$1'"
		esac
		shift
	done

	# abort on existing req/key/crt files
	err_exists="\
file already exists. Aborting build to avoid overwriting this file.
If you wish to continue, please use a different name.
Conflicting file found at:
*"
	[ -f "$req_out" ] && \
		user_error "Request $err_exists $req_out"
	[ -f "$key_out" ] && \
		user_error "Key $err_exists $key_out"
	[ -f "$crt_out" ] && \
		user_error "Certificate $err_exists $crt_out"
	unset -v err_exists

	# create request
	verbose "build_full: BEGIN gen_req"
	gen_req "$name" batch
	verbose "build_full: END gen_req"

	# Set to modify sign-req confirmation message
	local_request=1

	# Recreate temp-session and
	# drop edits to SSL Conf file
	remove_secure_session
	secure_session
	locate_support_files
	write_global_safe_ssl_cnf_tmp

	# Require --copy-ext
	export EASYRSA_CP_EXT=1

	# Sign it
	verbose "build_full: BEGIN sign_req"
	error_build_full_cleanup=1
	if sign_req "$crt_type" "$name"; then
		unset -v error_build_full_cleanup do_build_full
	else
		die "\
Failed to sign '$name' - \
See error messages above for details."
	fi
	verbose "build_full: END sign_req"
} # => build_full()

# Generate inline file V2
inline_file() {
	# Allow complete disable
	[ "$EASYRSA_DISABLE_INLINE" ] && return

	# definitive source
	[ "$1" ] || die "inline_file - Missing file_name_base"

	# make inline dirs
	easyrsa_mkdir "$EASYRSA_PKI"/inline
	easyrsa_mkdir "$EASYRSA_PKI"/inline/private

	# Source files
	crt_source="${EASYRSA_PKI}/issued/${1}.crt"
	key_source="${EASYRSA_PKI}/private/${1}.key"
	ca_source="$EASYRSA_PKI"/ca.crt
	tls_source="$EASYRSA_PKI"/private/easyrsa-tls.key
	old_tls_key_file="$EASYRSA_PKI"/easyrsa-keepsafe-tls.key

	# output
	inline_out="${EASYRSA_PKI}/inline/${1}.inline"
	print "\
# Inline files in the 'private' directory contain security keys which
# MUST only be transmitted over a secure connection, such as 'scp'." \
		> "$EASYRSA_PKI"/inline/private/README.inline.private
	inline_incomplete=
	inline_private=

	# Generate Inline data
	# Certificate
	if [ -f "$crt_source" ]; then
		crt_data="\
<cert>
$(cat "$crt_source")
</cert>"

		# Calculate decimal value for serial number
		# because openvpn uses decimal serial ?!?
		# for '--crl-verify /path/to/dir dir'
		# For reasons unknown..
		if which bc >/dev/null; then
			crt_serial="$(
				"$EASYRSA_OPENSSL" x509 -in "$crt_source" \
					-noout -serial
				)" || die "inline_file - SSL -serial failed"
			crt_serial="${crt_serial#*=}"
			crt_serial_dec="$(
					echo "ibase=16; $crt_serial" | bc
				)" || die "inline_file - HEX to DEC failed"
		else
			crt_serial_dec="Unavailable"
		fi

		# Generate fingerprint
		crt_fingerprint="$(
			"$EASYRSA_OPENSSL" x509 -in "$crt_source" \
				-noout -sha256 -fingerprint
			)" || die "inline_file - Failed -fingerprint"
		# strip prefix
		crt_fingerprint="${crt_fingerprint#*=}"

		# Certificate type
		if [ -z "$crt_type" ]; then
			ssl_cert_x509v3_eku "$crt_source" crt_type || \
				die "inline_file: Failed to set crt_type"
		fi

		# commonName
		crt_CN="$(
			display_dn x509 "$crt_source" | grep 'commonName'
		)" || die "inline_file: Failed to set crt_CN"
		# strip prefix
		crt_CN="${crt_CN#*= }"
	else
		inline_incomplete=1
		crt_data="\
# When you recieve your signed certificate place it in the
# 'pki/issued' sub-dir of your PKI and use command 'inline'
# to rebuild this inline file with your certificate.
# <cert>
# * Paste your user certificate here *
# </cert>"

		crt_fingerprint=unknown
		crt_type=unknown
		crt_CN=unknown
	fi

	# Private key
	if [ -f "$key_source" ]; then
		inline_private=1
		key_data="\
<key>
$(cat "$key_source")
</key>"
	else
		inline_incomplete=1
		key_data="\
# When you recieve your key place it in the
# 'pki/private' sub-dir of your PKI and use command 'inline'
# to rebuild this inline file with your key.
# <key>
# * Paste your private key here *
# </key>"
	fi

	# CA certificate
	if [ -f "$ca_source" ]; then
		ca_data="\
<ca>
$(cat "$ca_source")
</ca>"
	else
		inline_incomplete=1
		ca_data="\
# When you recieve your CA certificate place it in the
# 'pki' sub-dir of your PKI and use command 'inline'
# to rebuild this inline file with your CA certificate.
# <ca>
# * Paste your CA certificate here *
# </ca>"
	fi

	# TLS KEY - Set TLS auth|crypt key inline label
	if [ -f "$tls_source" ]; then
		tls_key_data="$(cat "$tls_source")"
		case "$tls_key_data" in
			*'TLS-AUTH'*) tls_key_label=tls-auth ;;
			*'TLS-CRYPT'*) tls_key_label=tls-crypt ;;
			*) tls_key_label=
		esac
	fi

	# Do NOT add TLS key if OLD TLS key exists
	# because this PSK has already been shared.
	if [ -f "$old_tls_key_file" ]; then
		tls_data="\
# Add the existing TLS AUTH/CRYPT-V1 Key here:
# <${tls_key_label}>
# * Paste The existing pre-shared TLS key here *
# </${tls_key_label}>"

		# Add --key-direction for TLS-AUTH
		[ "$tls_key_label" = tls-auth ] && \
			tls_data="$tls_data
#
# Add the required 'key-direction 0|1' here:
# key-direction 1"
		unset -v tls_key_data tls_key_label
	else
		# Add standard TLS key details
		if [ -f "$tls_source" ]; then
			inline_private=1
			if [ "$tls_key_label" ]; then
				tls_data="\
<${tls_key_label}>
${tls_key_data}
</${tls_key_label}>"
			else
				inline_incomplete=1
				tls_data="# Easy-RSA TLS Key not recognised!"
			fi
		else
			#inline_incomplete=1
			tls_data="# Easy-RSA TLS Key not found!"
		fi
	fi

	# Only support inline TLS keys for OpenVPN server/client use
	case "$crt_type" in
		server) key_direction="key-direction 0" ;;
		client) key_direction="key-direction 1" ;;
		*)
		verbose "inline: Unsupported certificate type: $crt_type"
		tls_key_label=
		key_direction=
		tls_data="# No TLS Key support for cert-type: $crt_type"
	esac

	# Add --key-direction for TLS-AUTH
	if [ "$tls_key_label" = tls-auth ]; then
		tls_data="${tls_data}${NL}${NL}${key_direction}"
	fi

	# If inline file has keys then redirect to 'private' dir
	[ "$inline_private" ] && \
		inline_out="${EASYRSA_PKI}/inline/private/${1}.inline"

	# Print data
	print "\
# Easy-RSA Inline file
# Certificate type: $crt_type
# commonName: $crt_CN
# SHA256 fingerprint:
# $crt_fingerprint
# Decimal serial number: $crt_serial_dec

$crt_data

$key_data

$ca_data

$tls_data
" > "$inline_out"

	# user info
	if [ "$inline_incomplete" ]; then
		warn "\
INCOMPLETE Inline file created:
* $inline_out"
	else
		notice "\
Inline file created:
* $inline_out"
	fi
} # => inline_file()

# revoke backend
revoke() {
	# Set cert directory (IE. type) to revoke
	cert_dir="$1"
	shift

	# pull filename base:
	[ "$1" ] || user_error "\
Error: didn't find a file base name as the first argument.
Run easyrsa without commands for usage and command help."

	# Assign file_name_base and dust off!
	file_name_base="$1"
	shift

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	in_dir="$EASYRSA_PKI"
	key_in="$in_dir/private/${file_name_base}.key"
	req_in="$in_dir/reqs/${file_name_base}.req"
	inline_pub="$in_dir/inline/${file_name_base}.inline"
	inline_pri="$in_dir/inline/private/${file_name_base}.inline"

	# input cert for revocation: issued, expired or renewed
	crt_in="${in_dir}/${cert_dir}/${file_name_base}.crt"

	# Assign possible "crl_reason"
	if [ "$1" ]; then
		crl_reason="$1"
		shift

		case "$crl_reason" in
			us|uns*) crl_reason=unspecified ;;
			kc|key*) crl_reason=keyCompromise ;;
			cc|[Cc][Aa]*) crl_reason=CACompromise ;;
			ac|aff*) crl_reason=affiliationChanged ;;
			ss|sup*) crl_reason=superseded ;;
			co|ces*) crl_reason=cessationOfOperation ;;
			ch|cer*) crl_reason=certificateHold ;;
			*) user_error "\
Unexpected reason: '$crl_reason'. See 'help revoke' for valid reasons."
		esac
	else
		unset -v crl_reason
	fi

	# Enforce syntax
	if [ "$1" ]; then
		user_error "Syntax error: $1"
	fi

	# referenced cert must exist:
	[ -f "$crt_in" ] || user_error "\
Unable to revoke as no certificate was found.
Certificate was expected at:
* $crt_in"

	# Set conflicting cert files: issued/ VS expired/ renewed/
	crt_iss="$EASYRSA_PKI/issued/${file_name_base}.crt"
	crt_exp="$EASYRSA_PKI/expired/${file_name_base}.crt"
	crt_ren="$EASYRSA_PKI/renewed/issued/${file_name_base}.crt"

	# If the command is 'revoke' then
	# if an issued cert exists then check that the others do not
	# To ensure that 'revoke' is not called accidentally
	if [ "$cmd" = revoke ] && [ -f "$crt_iss" ]; then
		if [ -f "$crt_exp" ] || [ -f "$crt_ren" ]; then
			msg=
			[ -f "$crt_exp" ] && msg="${NL}[Expired] $crt_exp"
			[ -f "$crt_ren" ] && msg="${msg}${NL}[Renewed] $crt_ren"

			# Force user to select revoke type
			[ "$EASYRSA_BATCH" ] || user_error "\
Conflicting file(s) found:${msg}

Please select which type of 'revoke' command is required:
* 'revoke-issued' will revoke a current certificate.
* 'revoke-expired' will revoke an old cert, which has been expired.
* 'revoke-renewed' will revoke an old cert, which has been renewed."
		fi
	fi
	# Clear variables no longer in use
	unset -v crt_iss crt_exp crt_ren

	# Verify certificate
	verify_file x509 "$crt_in" || user_error "\
Unable to revoke as the input-file is not a valid certificate.
Certificate was expected at:
* $crt_in"

	# Forbid self-signed cert from being expired/renewed/revoked
	if forbid_selfsign "$crt_in"; then
		user_error "Cannot $cmd a self-signed certificate."
	fi

	# Verify request
	if [ -f "$req_in" ]; then
		verify_file req "$req_in" || user_error "\
Unable to verify request. The file is not a valid request.
Request was expected at:
* $req_in"
	fi

	# get the serial number of the certificate
	cert_serial=
	ssl_cert_serial "$crt_in" cert_serial || \
		die "$cmd: Failed to get cert serial number!"

	# Set out_dir
	out_dir="$EASYRSA_PKI/revoked"
	crt_out="$out_dir/certs_by_serial/${cert_serial}.crt"
	key_out="$out_dir/private_by_serial/${cert_serial}.key"
	req_out="$out_dir/reqs_by_serial/${cert_serial}.req"

	# NEVER over-write a revoked cert, serial must be unique
	deny_msg="\
Cannot revoke this certificate, a conflicting file exists.
*"
	[ -f "$crt_out" ] && \
		user_error "$deny_msg certificate: $crt_out"
	[ -f "$key_out" ] && \
		user_error "$deny_msg private key: $key_out"
	[ -f "$req_out" ] && \
		user_error "$deny_msg request    : $req_out"
	unset -v deny_msg

	# Check for key and request files
	unset -v if_exist_key_in if_exist_req_in
	if [ "$move_req_and_key" ] && [ -f "$key_in" ]; then
		if_exist_key_in="
* $key_in"
	fi

	if [ "$move_req_and_key" ] && [ -f "$req_in" ]; then
		if_exist_req_in="
* $req_in"
	fi

	# Set confirm DN and serial
	confirm_dn="$(display_dn x509 "$crt_in")" || \
		die "revoke: display_dn"
	confirm_sn="    serial-number             = $cert_serial"

	# confirm operation by displaying DN:
	warn "\
This process is destructive!

These files will be MOVED to the 'revoked' sub-directory:
* $crt_in${if_exist_key_in}${if_exist_req_in}

These files will be DELETED:
All PKCS files for commonName: $file_name_base

The inline credentials files:
* $inline_pub
* $inline_pri"

	# now confirm
	confirm "  Continue with revocation: " "yes" "
Please confirm that you wish to revoke the certificate
with the following subject:

$confirm_dn
$confirm_sn

    Reason: ${crl_reason:-None given}"

	# Revoke certificate
	easyrsa_openssl ca -utf8 -revoke "$crt_in" \
		${crl_reason:+ -crl_reason "$crl_reason"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
			|| die "\
Failed to revoke certificate: revocation command failed."

	# move revoked files
	# so we can reissue certificates with the same name
	revoke_move

	notice "\
                    * IMPORTANT *

Revocation was successful. You must run 'gen-crl' and upload
a new CRL to your infrastructure in order to prevent the revoked
certificate from being accepted."
} # => revoke()

# revoke_move
# moves revoked certificates to the 'revoked' folder
# allows reissuing certificates with the same name
revoke_move() {
	easyrsa_mkdir "$EASYRSA_PKI"/revoked
	easyrsa_mkdir "$EASYRSA_PKI"/revoked/reqs_by_serial
	easyrsa_mkdir "$EASYRSA_PKI"/revoked/certs_by_serial
	easyrsa_mkdir "$EASYRSA_PKI"/revoked/private_by_serial

	# only move the req when revoking an issued cert
	# and if we have the req
	if [ "$move_req_and_key" ] && [ -f "$req_in" ]; then
		mv "$req_in" "$req_out" || warn "Failed to move: $req_in"
	fi

	# move crt to revoked folder
	mv "$crt_in" "$crt_out" || die "Failed to move: $crt_in"

	# only move the key when revoking an issued cert
	# and if we have the key
	if [ "$move_req_and_key" ] && [ -f "$key_in" ]; then
		mv "$key_in" "$key_out" || warn "Failed to move: $key_in"
	fi

	# remove any pkcs files
	for pkcs in p12 p7b p8 p1; do
		if [ -f "$in_dir/issued/$file_name_base.$pkcs" ]; then
			# issued
			rm "$in_dir/issued/$file_name_base.$pkcs" ||
				warn "Failed to remove: $file_name_base.$pkcs"
		fi

		if [ -f "$in_dir/private/$file_name_base.$pkcs" ]; then
			# private
			rm "$in_dir/private/$file_name_base.$pkcs" ||
				warn "Failed to remove: $file_name_base.$pkcs"
		fi
	done

	# remove inline files
	rm -f "$inline_pub" "$inline_pri" || warn \
		"revoke_move - Error trying to remove inline files."
} # => revoke_move()

# Move expired cert out of pki/issued to pki/expired
# to allow renewal
expire_cert() {
	# pull filename base:
	[ "$1" ] || user_error "\
Error: didn't find a file base name as the first argument.
Run easyrsa without commands for usage and command help."

	# Assign file_name_base and dust off!
	file_name_base="$1"
	shift

	# input
	in_dir="$EASYRSA_PKI/issued"
	crt_in="$in_dir/$file_name_base.crt"
	#key_in="$in_dir/private/$file_name_base.key"
	#req_in="$in_dir/reqs/$file_name_base.req"

	# output
	out_dir="$EASYRSA_PKI/expired"
	crt_out="$out_dir/$file_name_base.crt"

	# make output folder
	easyrsa_mkdir "$EASYRSA_PKI"/expired

	# Do not over write existing cert
	if [ -f "$crt_out" ]; then
		user_error "\
Cannot expire this certificate, a conflicting file exists:
* certificate: $crt_out

Use command 'revoke-exired' to revoke this certificate."
	fi

	# deprecate ALL options
	while [ "$1" ]; do
		case "$1" in
			nopass)
				warn "\
Option 'nopass' is not supported by command '$cmd'."
				;;
			*) user_error "Unknown option: $1"
		esac
		shift
	done

	# Verify certificate
	if [ -f "$crt_in" ]; then
		verify_file x509 "$crt_in" || user_error "\
Input file is not a valid certificate:
* $crt_in"
	else
		user_error "\
Missing certificate file:
* $crt_in"
	fi

	# Forbid self-signed cert from being expired/renewed/revoked
	if forbid_selfsign "$crt_in"; then
		user_error "Cannot $cmd a self-signed certificate."
	fi

	# get the serial number of the certificate
	cert_serial=
	ssl_cert_serial "$crt_in" cert_serial || \
		die "$cmd: Failed to get cert serial number!"

	# Set confirm DN and serial
	confirm_dn="$(display_dn x509 "$crt_in")" || \
		die "expire: display_dn"
	confirm_sn="    serial-number             = $cert_serial"

	# date of expiry
	# Equal to: easyrsa-tools.lib - ssl_cert_not_after_date()
	# This is left as a reminder that easyrsa does not handle
	# dates well and they should be avoided, at all cost.
	# This is for confirmation purposes ONLY.
	crt_expire="$(
		"$EASYRSA_OPENSSL" x509 -in "$crt_in" -noout -enddate
		)" || die "expire: enddate"
	confirm_ex="    notAfter date             = ${crt_expire#*=}"

	# confirm
	confirm "  Continue with expiry: " yes "
Please confirm you wish to expire the certificate
with the following subject:

$confirm_dn

$confirm_sn

$confirm_ex" # => End confirm

	# move cert to expired dir
	mv "$crt_in" "$crt_out" || die "failed to move expired: $crt_in"

	# User message
	notice "\
Certificate has been successfully moved to the expired directory.
* $crt_out

This certificate is still valid, until it expires.
It can be revoked with command 'revoke-expired'.

It is now possible to sign a new certificate for '$file_name_base'"
} # => expire_cert()

# Forbid a self-signed cert from being expired/renewed/revoked
# by a CA that has nothing to do with the cert
forbid_selfsign() {
	# cert temp-file
	forbid_selfsign_tmp=
	easyrsa_mktemp forbid_selfsign_tmp || \
		die "easyrsa_mktemp forbid_selfsign_tmp"

	# SSL text
	"$EASYRSA_OPENSSL" x509 -in "$1" -noout -text \
		> "$forbid_selfsign_tmp" || \
			die "forbid_selfsign - ssl text"

	# test for CA:TRUE
	grep -q "^[[:blank:]]*CA:TRUE$" "$forbid_selfsign_tmp"
} # => forbid_selfsign()

# gen-crl backend
gen_crl() {
	out_file="$EASYRSA_PKI/crl.pem"
	out_der="$EASYRSA_PKI/crl.der"

	out_file_tmp=""
	easyrsa_mktemp out_file_tmp || \
		die "gen_crl - easyrsa_mktemp out_file_tmp"

	if [ -r "$out_file" ]; then
		cp -p "$out_file" "$out_file_tmp" || \
			warn "Failed to preserve CRL file permissions."
	fi

	easyrsa_openssl ca -utf8 -gencrl -out "$out_file_tmp" \
		${EASYRSA_CRL_DAYS:+ -crldays "$EASYRSA_CRL_DAYS"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} || \
			die "CRL Generation failed."

	# Move temp-files to target-files
	mv "$out_file_tmp" "$out_file" || mv_temp_error=1
	if [ "$mv_temp_error" ]; then
		#rm -f "$out_file"
		die "Failed to move temp CRL file."
	fi

	# Copy to DER - As published by OpenSSL
	if "$EASYRSA_OPENSSL" crl -in "$out_file" -out "$out_der" \
		-outform DER
	then
		crl_der_note="An updated CRL DER copy has been created:
* $out_der"
	else
		crl_der_note="Failed to create CRL DER copy!"
	fi

	notice "\
$crl_der_note

An updated CRL has been created:
* $out_file

IMPORTANT: When the CRL expires, an OpenVPN Server which uses a
CRL will reject ALL new connections, until the CRL is replaced."
} # => gen_crl()

# import-req backend
import_req() {
	# pull passed paths
	in_req="$1"
	short_name="$2"
	out_req="$EASYRSA_PKI/reqs/$2.req"

	[ "$short_name" ] || user_error "\
Unable to import: incorrect command syntax.
Run easyrsa without commands for usage and command help."

	# Request file must exist
	[ -f "$in_req" ] || user_error "\
No request found for the input: '$2'
Expected to find the request at:
* $in_req"

	verify_file req "$in_req" || user_error "\
The certificate request file is not in a valid X509 format:
* $in_req"

	# destination must not exist
	[ -f "$out_req" ] && user_error "\
Please choose a different name for your imported request file.
Conflicting file already exists at:
* $out_req"

	# now import it
	cp "$in_req" "$out_req"

	notice "\
Request successfully imported with short-name: $short_name
This request is now ready to be signed."
} # => import_req()

# export pkcs#12, pkcs#7, pkcs#8 or pkcs#1
export_pkcs() {
	pkcs_type="$1"
	shift

	[ "$1" ] || user_error "\
Unable to export '$pkcs_type': incorrect command syntax.
Run easyrsa without commands for usage and command help."

	file_name_base="$1"
	shift

	crt_in="$EASYRSA_PKI/issued/$file_name_base.crt"
	key_in="$EASYRSA_PKI/private/$file_name_base.key"
	crt_ca="$EASYRSA_PKI/ca.crt"

	# Always set a friendly_name
	set_var EASYRSA_P12_FR_NAME "$file_name_base"
	friendly_name="$EASYRSA_P12_FR_NAME"

	# opts support
	cipher=-aes256
	want_ca=1
	want_key=1
	unset -v nokeys legacy

	# Under OpenSSL 1.1, use the PBE/MAC algorithms OpenSSL 3.0 uses,
	# unless "legacy" is set.  This makes the .p12 files readable by
	# OpenSSL 3.0 without needing '-legacy'.
	if [ "$openssl_v3" ]; then
		# No cipher opts required
		p12_cipher_opts=""
	else
		# Upgrade PBE & MAC opts - Reset by option 'legacy'
		p12_cipher_opts="-keypbe AES-256-CBC -certpbe AES-256-CBC"
		p12_cipher_opts="${p12_cipher_opts} -macalg sha256"
	fi

	while [ "$1" ]; do
		case "$1" in
			noca)
				want_ca=""
				;;
			nokey)
				want_key=""
				# Undocumented OpenSSL feature: option
				# -nokeys will ignore missing -inkey file
				# No doubt, the reason for the extra -inkey
				nokeys=-nokeys
				;;
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			nofn)
				friendly_name=""
				;;
			legacy)
				if [ "$openssl_v3" ]; then
					legacy=-legacy
				else
					# Downgrade PBE & MAC opts
					p12_cipher_opts=""
				fi
				;;
			*)
				user_error "Unknown command option: '$1'"
		esac
		shift
	done

	# Required options - PKCS, rhymes with mess
	case "$pkcs_type" in
		p12|p7)
			: # ok
			;;
		p8|p1)
			want_key=1
			;;
		*) die "Unknown PKCS type: $pkcs_type"
	esac

	# Check for CA, if required
	if [ "$want_ca" ]; then
		case "$pkcs_type" in
		p12|p7)
			# verify_ca_init() here, otherwise not required
			if verify_ca_init test; then
				: # ok
			else
				warn "\
Missing CA Certificate, expected at:
* $crt_ca"
				confirm "
  Continue without CA Certificate (EG: option 'noca') ? " yes "
Your PKI does not include a CA Certificate.
You can export your User Certificate to a $pkcs_type file
but the CA Certificate will not be included."

				# --batch mode does not allow
				# on-the-fly command changes
				if [ "$EASYRSA_BATCH" ]; then
					die "export-$pkcs_type: Missing CA"
				fi
				want_ca=""
			fi
			;;
		p8|p1)
			: # Not required
			;;
		*) die "Unknown PKCS type: $pkcs_type"
		esac
	fi

	# Check for key, if required
	if [ "$want_key" ]; then
		if [ -f "$key_in" ]; then
			: #ok
		else
			case "$pkcs_type" in
			p12)
				warn "\
Missing Private Key, expected at:
* $key_in"
				confirm "
  Continue without Private Key (EG: option 'nokey') ? " yes "
Your PKI does not include a Private Key for '$file_name_base'.
You can export your User Certificate to a '$pkcs_type' file
but the Private Key will not be included."

				# --batch mode does not allow
				# on-the-fly command changes
				if [ "$EASYRSA_BATCH" ]; then
					die "export-$pkcs_type: Missing key"
				fi
				nokeys=-nokeys
				;;
			p8|p1)
				user_error "\
Missing Private Key, expected at:
* $key_in"
				;;
			p7)
				: # Not required
				;;
			*) die "Unknown PKCS type: $pkcs_type"
			esac
		fi
	fi

	# Check for certificate, if required
	if [ -f "$crt_in" ]; then
		: # ok
	else
		case "$pkcs_type" in
		p12|p7)
			user_error "\
Missing User Certificate, expected at:
* $crt_in"
			;;
		p8|p1)
			: # Not required
			;;
		*) die "Unknown PKCS type: $pkcs_type"
		esac
	fi

	# For 'nopass' PKCS requires an explicit empty password
	if [ "$EASYRSA_NO_PASS" ]; then
		EASYRSA_PASSIN=pass:
		EASYRSA_PASSOUT=pass:
		unset -v cipher # pkcs#1 only
	fi

	# Complete export
	inline_out=
	inline_msg=
	case "$pkcs_type" in
	p12)
		pkcs_out="$EASYRSA_PKI/private/$file_name_base.p12"
		inline_out="$EASYRSA_PKI/inline/$file_name_base-p12.inline"

		[ "$legacy" ] && \
			error_info="SSL library may not support -legacy mode"

		# export the p12:
		# shellcheck disable=2086 # Double quote p12_cipher_opts
		easyrsa_openssl pkcs12 -export \
			-in "$crt_in" \
			-out "$pkcs_out" \
			-inkey "$key_in" \
			${nokeys} \
			${legacy} \
			${p12_cipher_opts} \
			${friendly_name:+ -name "$friendly_name"} \
			${want_ca:+ -certfile "$crt_ca"} \
			${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
			${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} \
				|| die "Failed to export PKCS#12"

		# Inline .p12 only
		# Get cert CN
		inline_CN="$(
			"$EASYRSA_OPENSSL" x509 -in "$crt_in" -noout -subject \
				-nameopt multiline,-esc_msb | grep 'commonName'
		)" || die "export_pkcs - inline_CN FAILED"
		inline_CN="${inline_CN##*= }"

		# BASE64 encode pkcs12
		inline_tmp=
		easyrsa_mktemp inline_tmp || die "export_pkcs - inline_tmp"
		if "$EASYRSA_OPENSSL" enc -a -in "$pkcs_out" > "$inline_tmp"
		then
			# make inline file
			{
				print "\
# Easy-RSA inline file: pkcs12
# commonName: ${inline_CN}${NL}"
				print "<pkcs12>"
				cat "$inline_tmp"
				print "</pkcs12>"
			} > "$inline_out" || die "export_pkcs - make inline"

			inline_msg="\
A BASE64 encoded inline file has also been created at:
* ${inline_out}${NL}"
		else
			inline_msg="\
Failed to create a BASE64 encoded inline file${NL}"
		fi
		;;
	p7)
		pkcs_out="$EASYRSA_PKI/issued/$file_name_base.p7b"

		# export the p7:
		easyrsa_openssl crl2pkcs7 -nocrl \
			-certfile "$crt_in" \
			-out "$pkcs_out" \
			${want_ca:+ -certfile "$crt_ca"} \
				|| die "Failed to export PKCS#7"
		;;
	p8)
		pkcs_out="$EASYRSA_PKI/private/$file_name_base.p8"

		# export the p8:
		easyrsa_openssl pkcs8 -topk8 \
			-in "$key_in" \
			-out "$pkcs_out" \
			${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
			${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} \
				|| die "Failed to export PKCS#8"
		;;
	p1)
		pkcs_out="$EASYRSA_PKI/private/$file_name_base.p1"

		# OpenSSLv3 requires -traditional for PKCS#1
		# Otherwise, OpenSSLv3 outputs PKCS#8
		[ "$verify_ssl_lib_ok" ] || \
			die "export_pkcs.p1: verify_ssl_lib_ok FAIL"

		if [ "$openssl_v3" ]; then
			traditional=-traditional
		else
			unset -v traditional
		fi

		# export the p1:
		easyrsa_openssl rsa \
			-in "$key_in" \
			-out "$pkcs_out" \
			${traditional} \
			${cipher} \
			${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
			${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} \
				|| die "Failed to export PKCS#1"
	;;
	*) die "Unknown PKCS type: $pkcs_type"
	esac

	# User messages
	notice "\
Successful export of $pkcs_type file. Your exported file is at:
* $pkcs_out"
	[ "$inline_msg" ] && print "$inline_msg"

	return 0
} # => export_pkcs()

# set-pass backend
set_pass() {
	# values supplied by the user:
	raw_file="$1"
	file="$EASYRSA_PKI/private/$raw_file.key"

	if [ "$raw_file" ]; then
		shift
	else
		user_error "\
Missing argument: no name/file supplied."
	fi

	# parse command options
	cipher="-aes256"
	while [ "$1" ]; do
		case "$1" in
			nopass)
				[ "$prohibit_no_pass" ] || EASYRSA_NO_PASS=1
				;;
			file)
				file="$raw_file"
				;;
			*) user_error "Unknown command option: '$1'"
		esac
		shift
	done

	# If nopass then do not encrypt else encrypt with password.
	if [ "$EASYRSA_NO_PASS" ]; then
		unset -v cipher
	fi

	[ -f "$file" ] || user_error "\
Missing private key: expected to find the private key file at:
* $file"

	notice "\
If the key is encrypted then you must supply the current password.
${cipher:+You will then enter a new password for this key.$NL}"

	# Set password
	out_key_tmp=""
	easyrsa_mktemp out_key_tmp || \
		die "set_pass - easyrsa_mktemp out_key_tmp"

	easyrsa_openssl pkey -in "$file" -out "$out_key_tmp" \
		${cipher:+ "$cipher"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
		${EASYRSA_PASSOUT:+ -passout "$EASYRSA_PASSOUT"} || \
			die "Failed to change the private key passphrase."

	# Move old key-file out of the way
	mv "$file" "${file}.tmp" || \
		die "Failed to move the old-key file."

	# Move new key-file into place
	if mv "$out_key_tmp" "$file"; then
		rm -f "${file}.tmp"
	else
		mv -f "${file}.tmp" "$file"
		die "Failed to update the private key file."
	fi

	key_update=changed
	[ "$EASYRSA_NO_PASS" ] && key_update=removed
	notice "Key passphrase successfully $key_update"
} # => set_pass()

# Verify OpenVPN binary
verify_openvpn() {
	# Try to find openvpn
	set_var EASYRSA_OPENVPN "$(which openvpn)"
	if [ -f "$EASYRSA_OPENVPN" ]; then
		verbose \
			"verify_openvpn - EASYRSA_OPENVPN='$EASYRSA_OPENVPN'"
	else
		user_error "Cannot find an OpenVPN binary."
	fi
} # => verify_openvpn()

# OpenVPN TLS Auth/Crypt Key
tls_key_gen() {
	case "$1" in
		tls-crypt-v2)
			print "Unavailable."
			cleanup
		;;
		tls-crypt) tls_key_type=TLS-CRYPT ;;
		tls-auth) tls_key_type=TLS-AUTH ;;
		*) die "Unknown key type: '$1'"
	esac

	# Over write error message
	tls_key_error_msg="
If this file is changed then it MUST be redistributed to ALL servers
AND clients, to be in effect. Do NOT change this existing file."

	# Assign possible TLS key sources
	tls_key_file="$EASYRSA_PKI"/private/easyrsa-tls.key
	old_tls_key_file="$EASYRSA_PKI"/easyrsa-keepsafe-tls.key

	# Forbid overwrite - default TLS key
	if [ -f "$tls_key_file" ]; then
		tls_key_data="$(cat "$tls_key_file")"
		case "$tls_key_data" in
			*'TLS-CRYPT'*) tls_key_type=TLS-CRYPT ;;
			*'TLS-AUTH'*) tls_key_type=TLS-AUTH ;;
			*) tls_key_type=UNKNOWN
		esac

		user_error "\
Cannot overwrite existing $tls_key_type Key:
* $tls_key_file
$tls_key_error_msg"
	fi

	# Forbid overwrite - Old TLS key
	if [ -f "$old_tls_key_file" ]; then
		old_tls_key_data="$(cat "$old_tls_key_file")"
		case "$old_tls_key_data" in
			*'TLS-CRYPT'*) tls_key_type=TLS-CRYPT ;;
			*'TLS-AUTH'*) tls_key_type=TLS-AUTH ;;
			*) tls_key_type=UNKNOWN
		esac

		user_error "\
Cannot overwrite existing $tls_key_type Key:
* $old_tls_key_file
$tls_key_error_msg"
	fi

	verify_openvpn

	tls_key_tmp=
	easyrsa_mktemp tls_key_tmp || \
		die "tls_key_gen - easyrsa_mktemp tls_key_tmp"

	# Generate TLS Key
	"$EASYRSA_OPENVPN" --genkey "$1" "$tls_key_tmp" || \
		die "tls_key_gen - --genkey $tls_key_type FAIL"

	# Insert type label
	{
		print "# Easy-RSA $tls_key_type Key"
		cat "$tls_key_tmp"
	} > "$tls_key_file" || \
			die "tls_key_gen - Insert type label FAIL"

	notice "\
$tls_key_type Key generated at:
* $tls_key_file
$tls_key_error_msg"
	verbose "tls_key_gen: openvpn --genkey $tls_key_type OK"
} # => tls_key_gen()

# Get certificate start date
# shellcheck disable=2317 # Unreach - ssl_cert_not_before_date()
ssl_cert_not_before_date() {
	verbose "DEPRECATED: ssl_cert_not_before_date()"
	[ "$#" = 2 ] || die "\
ssl_cert_not_before_date - input error"
	[ -f "$1" ] || die "\
ssl_cert_not_before_date - missing cert"

	fn_ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout -startdate
		)" || die "\
ssl_cert_not_before_date - failed: -startdate"

	fn_ssl_out="${fn_ssl_out#*=}"

	force_set_var "$2" "$fn_ssl_out" || die "\
ssl_cert_not_before_date - failed to set var '$*'"

	unset -v fn_ssl_out
} # => ssl_cert_not_before_date()

# Get certificate end date
ssl_cert_not_after_date() {
	verbose "DEPRECATED: ssl_cert_not_after_date()"
	[ "$#" = 2 ] || die "\
ssl_cert_not_after_date - input error"
	[ -f "$1" ] || die "\
ssl_cert_not_after_date - missing cert"

	fn_ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout -enddate
		)" || die "\
ssl_cert_not_after_date - failed: -enddate"

	fn_ssl_out="${fn_ssl_out#*=}"

	force_set_var "$2" "$fn_ssl_out" || die "\
ssl_cert_not_after_date - failed to set var '$*'"

	unset -v fn_ssl_out
} # => ssl_cert_not_after_date()

# SSL -- v3 -- startdate iso_8601
# shellcheck disable=2317 # Unreach - iso_8601_cert_startdate()
iso_8601_cert_startdate() {
	verbose "NEW: iso_8601_cert_startdate"
	[ "$#" = 2 ] || die "\
iso_8601_cert_startdate: input error"
	[ -f "$1" ] || die "\
iso_8601_cert_startdate: missing cert"

	# On error return, let the caller decide what to do
	if fn_ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout \
			-startdate -dateopt iso_8601
		)"
	then
		: # ok
	else
		# The caller MUST assess this error
		verbose "\
iso_8601_cert_startdate: GENERATED ERROR"
		return 1
	fi

	fn_ssl_out="${fn_ssl_out#*=}"

	force_set_var "$2" "$fn_ssl_out" || die "\
iso_8601_cert_startdate: failed to set var '$*'"

	unset -v fn_ssl_out
} # => iso_8601_cert_startdate()

# SSL -- v3 -- enddate iso_8601
iso_8601_cert_enddate() {
	verbose "NEW: iso_8601_cert_enddate"
	[ "$#" = 2 ] || die "\
iso_8601_cert_enddate: input error"
	[ -f "$1" ] || die "\
iso_8601_cert_enddate: missing cert"

	# On error return, let the caller decide what to do
	if fn_ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout \
			-enddate -dateopt iso_8601
		)"
	then
		: # ok
	else
		# The caller MUST assess this error
		verbose "\
iso_8601_cert_enddate: GENERATED ERROR"
		return 1
	fi

	fn_ssl_out="${fn_ssl_out#*=}"

	force_set_var "$2" "$fn_ssl_out" || die "\
iso_8601_cert_enddate: failed to set var '$*'"

	unset -v fn_ssl_out
} # => iso_8601_cert_enddate()

# Certificate expiry
will_cert_be_valid() {
	# Verify file exists and is a valid cert
	[ -f "$1" ] || \
		die "will_cert_be_valid - Missing file: $1"
	verify_file x509 "$1" || \
		die "will_cert_be_valid - Invalid file: $1"

	# Verify --days
	case "$2" in
		0) : ;; # ok
		''|*[!1234567890]*|0*)
			die "will_cert_be_valid - Non-decimal value: $2"
	esac

	# is the cert still valid at this future date
	ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout \
			-checkend "$2"
	)"

	# analyse SSL output
	case "$ssl_out" in
		'Certificate will not expire') return 0 ;;
		'Certificate will expire') return 1 ;;
		*) die "will_cert_be_valid - Failure"
	esac
} # => will_cert_be_valid()

# Read db
# shellcheck disable=SC2295 # nested expand - read_db()
read_db() {
	TCT='	' # tab character
	db_in="$EASYRSA_PKI/index.txt"
	pki_r_issued="$EASYRSA_PKI/renewed/issued"
	pki_r_by_sno="$EASYRSA_PKI/renewed/certs_by_serial"
	unset -v target_found

	while read -r db_status db_notAfter db_record; do

		verbose "***** Read next record *****"

		# Recreate temp-session and
		# drop edits to SSL Conf file
		remove_secure_session
		secure_session
		locate_support_files
		write_global_safe_ssl_cnf_tmp

		# Interpret the db/certificate record
		unset -v db_serial db_cn db_revoke_date db_reason
		case "$db_status" in
		V|E)
			# Valid
			db_serial="${db_record%%${TCT}*}"
			db_record="${db_record#*${TCT}}"
			db_cn="${db_record#*/CN=}"; db_cn="${db_cn%%/*}"
			cert_issued="$EASYRSA_PKI/issued/$db_cn.crt"
			cert_r_issued="$pki_r_issued/$db_cn.crt"
			cert_r_by_sno="$pki_r_by_sno/$db_serial.crt"
		;;
		R)
			# Revoked
			db_revoke_date="${db_record%%${TCT}*}"
			db_reason="${db_revoke_date#*,}"
			if [ "$db_reason" = "$db_revoke_date" ]; then
				db_reason="None given"
			else
				db_revoke_date="${db_revoke_date%,*}"
			fi
			db_record="${db_record#*${TCT}}"

			db_serial="${db_record%%${TCT}*}"
			db_record="${db_record#*${TCT}}"
			db_cn="${db_record#*/CN=}"; db_cn="${db_cn%%/*}"
		;;
		*) die "Unexpected status: $db_status"
		esac

		# Output selected status report for this record
		case "$report" in
		expire)
		# Certs which expire before EASYRSA_PRE_EXPIRY_WINDOW days
			case "$db_status" in
			V|E)
				case "$target" in
				'') expire_status_v2 "$cert_issued" ;;
				*)
					if [ "$target" = "$db_cn" ]; then
						expire_status_v2 "$cert_issued"
					fi
				esac
			;;
			*)
				: # Ignore ok
			esac
		;;
		revoke)
		# Certs which have been revoked
			case "$db_status" in
			R)
				case "$target" in
				'') revoke_status ;;
				*)
					if [ "$target" = "$db_cn" ]; then
						revoke_status
					fi
				esac
			;;
			*)
				: # Ignore ok
			esac
		;;
		renew)
		# Certs which have been renewed but not revoked
			case "$db_status" in
			V|E)
				case "$target" in
				'') renew_status ;;
				*)
					if [ "$target" = "$db_cn" ]; then
						renew_status
					fi
				esac
			;;
			*)
				: # Ignore ok
			esac
		;;
		*) die "Unrecognised report: $report"
		esac

		# Is db record for target found
		if [ "$target" = "$db_cn" ]; then
			target_found=1
		fi

	done < "$db_in"

	# Add CA to show-expire
	case  "$report" in
	expire)
		# Extract -endate
		ca_enddate="$(
			"$EASYRSA_OPENSSL" x509 -in "$EASYRSA_PKI"/ca.crt \
				-noout -enddate
		)"
		ca_enddate="${ca_enddate#*=}"

		# Check CA for expiry
		if will_cert_be_valid "$EASYRSA_PKI"/ca.crt \
			"$pre_expire_window_s"
		then
			: # cert will still be valid by expiry window
		else
			# Print CA expiry date
			printf '\n%s\n\n' \
				"CA certificate will expire on $ca_enddate"
		fi
	esac

	# Check for target found/valid commonName, if given
	if [ "$target" ]; then
		[ "$target_found" ] || \
			warn "Certificate for $target was not found"
	fi
} # => read_db()

# Expire status
expire_status_v2() {
	# expiry seconds
	pre_expire_window_s="$((
		EASYRSA_PRE_EXPIRY_WINDOW * 60*60*24
		))"

	# The certificate for CN should exist but may not
	if [ -f "$1" ]; then
		verbose "expire_status: cert exists"

		# Check if cert will be valid else print details
		if will_cert_be_valid "$1" "$pre_expire_window_s"
		then
			verbose "cert will still be valid by expiry window"
		else
			# cert expiry date
			if [ "$openssl_v3" ]; then
				# ISO8601 date - OpenSSL v3 only
				iso_8601_cert_enddate "$1" cert_not_after_date
			else
				# Standard date - OpenSSL v1
				ssl_cert_not_after_date "$1" cert_not_after_date
			fi

			# show expiring cert details
			printf '%s%s\n' \
				"$db_status | Serial: $db_serial | " \
				"$cert_not_after_date | CN: $db_cn"
		fi
	else
		verbose "issued cert does not exist, ignore other certs"
	fi
} # => expire_status_v2()

# Revoke status
revoke_status() {
	# Translate db date to usable date
	cert_revoke_date=
	db_date_to_iso_8601_date "$db_revoke_date" cert_revoke_date

	printf '%s%s%s\n' \
		"$db_status | Serial: $db_serial | " \
		"Revoked: $cert_revoke_date | " \
		"Reason: $db_reason | CN: $db_cn"
} # => revoke_status()

# Renewed status
# renewed certs only remain in the renewed folder until revoked
# Only ONE renewed cert with unique CN can exist in renewed folder
renew_status() {
	# Does a Renewed cert exist ?
	# files in issued are file name, or in serial are SerialNumber
	unset -v \
		cert_file_in cert_is_issued cert_is_serial renew_is_old

	# Find renewed/issued/CN
	if [ -f "$cert_r_issued" ]; then
		cert_file_in="$cert_r_issued"
		cert_is_issued=1
	fi

	# Find renewed/cert_by_serial/SN
	if [ -f "$cert_r_by_sno" ]; then
		cert_file_in="$cert_r_by_sno"
		cert_is_serial=1
		renew_is_old=1
	fi

	# Both should not exist
	if [ "$cert_is_issued" ] && [ "$cert_is_serial" ]; then
		die "Too many certs"
	fi

	# If a renewed cert exists
	if [ "$cert_file_in" ]; then
		# get the serial number of the certificate
		ssl_cert_serial "$cert_file_in" cert_serial

		# db serial must match certificate serial, otherwise
		# this is an issued cert that replaces a renewed cert
		if [ "$db_serial" != "$cert_serial" ]; then
			information "\
serial mismatch:
  db_serial:    $db_serial
  cert_serial:  $cert_serial
  cert_file_in: $cert_file_in"
			return 0
		fi

		# Use cert date
		# Assigns cert_not_after_date
		ssl_cert_not_after_date \
			"$cert_file_in" cert_not_after_date

		# Highlight renewed/cert_by_serial
		if [ "$renew_is_old" ]; then
			printf '%s%s\n' \
				"*** $db_status | Serial: $db_serial | " \
				"Expires: $cert_not_after_date | CN: $db_cn"
		else
			printf '%s%s\n' \
				"$db_status | Serial: $db_serial | " \
				"Expires: $cert_not_after_date | CN: $db_cn"
		fi

	else
		# Cert is valid but not renewed
		: # ok - ignore
	fi
} # => renew_status()

# cert status reports
status() {
	[ "$#" -gt 0 ] || die "status - input error"
	report="$1"
	target="$2"

	# test fix: https://github.com/OpenVPN/easy-rsa/issues/819
	export LC_TIME=C.UTF-8

	# If no target file then add Notice
	if [ -z "$target" ]; then
		# Select correct Notice
		case "$report" in
		expire)
			notice "\
* Showing certificates which expire in less than \
$EASYRSA_PRE_EXPIRY_WINDOW days (--days):"
		;;
		revoke)
			notice "\
* Showing certificates which are revoked:"
		;;
		renew)
			notice "\
* Showing certificates which have been renewed but NOT revoked:

*** Marks those which require 'rewind-renew' \
before they can be revoked."
		;;
		*) warn "Unrecognised report: $report"
		esac
	fi

	# Create report
	read_db
} # => status()

# renew backend
renew() {
	# pull filename base:
	[ "$1" ] || user_error "\
Error: didn't find a file base name as the first argument.
Run easyrsa without commands for usage and command help."

	# Assign file_name_base and dust off!
	file_name_base="$1"
	shift

	# Assign input files
	in_dir="$EASYRSA_PKI"
	crt_in="$in_dir/issued/${file_name_base}.crt"
	key_in="$in_dir/private/${file_name_base}.key"
	req_in="$in_dir/reqs/${file_name_base}.req"
	inline_pub="$in_dir/inline/${file_name_base}.inline"
	inline_pri="$in_dir/inline/private/${file_name_base}.inline"

	# deprecate ALL options
	while [ "$1" ]; do
		case "$1" in
			nopass)
				warn "\
Option 'nopass' is not supported by command 'renew'."
			;;
			*) user_error "Unknown option: $1"
		esac
		shift
	done

	# Verify certificate
	if [ -f "$crt_in" ]; then
		verify_file x509 "$crt_in" || user_error "\
Input file is not a valid certificate:
* $crt_in"
	else
		user_error "\
Missing certificate file:
* $crt_in"
	fi

	# Forbid self-signed cert from being expired/renewed/revoked
	if forbid_selfsign "$crt_in"; then
		user_error "Cannot $cmd a self-signed certificate."
	fi

	# Verify request
	if [ -f "$req_in" ]; then
		verify_file req "$req_in" || user_error "\
Input file is not a valid request:
* $req_in"
	else
		user_error "\
Missing request file:
* $req_in"
	fi

	# Get cert commonName
	cert_CN="$(
			display_dn x509 "$crt_in" | grep 'commonName'
		)" || die "renew - display_dn of cert failed"

	# Get req commonName
	req_CN="$(
			display_dn req "$req_in" | grep 'commonName'
		)" || die "renew - display_dn of req failed"

	# For renew, cert_CN must match req_CN
	[ "$cert_CN" = "$req_CN" ] || user_error \
		"Certificate cannot be renewed due to commonName mismatch"
	verbose "renew - cert_CN MATCH req_CN"

	# get the serial number of the certificate
	ssl_cert_serial "$crt_in" cert_serial || \
		die "$cmd: Failed to get cert serial number!"

	# Duplicate cert by serial file
	dup_dir="$EASYRSA_PKI/certs_by_serial"
	dup_crt_by_serial="$dup_dir/${cert_serial}.pem"

	# Set out_dir
	out_dir="$EASYRSA_PKI/renewed"
	crt_out="$out_dir/issued/${file_name_base}.crt"

	# NEVER over-write a renewed cert, revoke it first
	if [ -f "$crt_out" ]; then
		user_error "\
Cannot renew this certificate, a conflicting file exists:
* certificate: $crt_out

Use command 'revoke-renewed' to revoke this certificate."
	fi

	# Extract certificate usage from old cert
	ssl_cert_x509v3_eku "$crt_in" cert_type

	# create temp-file for full cert text
	full_crt_tmp=
	easyrsa_mktemp full_crt_tmp || \
		die "easyrsa_mktemp full_crt_tmp"

	# write full cert text tempfile data
	"$EASYRSA_OPENSSL" x509 -in "$crt_in" \
		-noout -text > "$full_crt_tmp" || \
			die "write full cert text"

	# Use SAN from old cert ONLY
	if grep -q 'X509v3 Subject Alternative Name' \
		"$full_crt_tmp"
	then
		EASYRSA_SAN="$(
			grep -A 1 'X509v3 Subject Alternative Name' \
				"$full_crt_tmp" | \
					sed -e s/'^\ *'// \
						-e /'X509v3 Subject Alternative Name'/d \
						-e s/'IP Address:'/'IP:'/g
		)" || die "renew - EASYRSA_SAN: easyrsa_openssl subshell"
		verbose "renew: EASYRSA_SAN: ${EASYRSA_SAN}"

		# --san-crit
		unset -v EASYRSA_SAN_CRIT
		if grep -q 'X509v3 Subject Alternative Name: critical' \
			"$full_crt_tmp"
		then
			export EASYRSA_SAN_CRIT='critical,'
			verbose "renew: --san-crit ENABLED"
		fi

		export EASYRSA_EXTRA_EXTS="\
$EASYRSA_EXTRA_EXTS
subjectAltName = ${EASYRSA_SAN_CRIT}${EASYRSA_SAN}"
		verbose "renew: EASYRSA_EXTRA_EXTS: ${EASYRSA_EXTRA_EXTS}"
	fi

	# --bc-crit
	if grep -q 'X509v3 Basic Constraints: critical' \
		"$full_crt_tmp"
	then
		export EASYRSA_BC_CRIT=1
		verbose "renew: --bc-crit ENABLED"
	fi

	# --ku-crit
	if grep -q 'X509v3 Key Usage: critical' \
		"$full_crt_tmp"
	then
		export EASYRSA_KU_CRIT=1
		verbose "renew: --ku-crit ENABLED"
	fi

	# --eku-crit
	if grep -q 'X509v3 Extended Key Usage: critical' \
		"$full_crt_tmp"
	then
		export EASYRSA_EKU_CRIT=1
		verbose "renew: --eku-crit ENABLED"
	fi

	# Disable options not supported by renew
	unset -v EASYRSA_AUTO_SAN EASYRSA_NEW_SUBJECT

	# confirm operation by displaying Warning
	confirm "Continue with 'renew' ? " yes "\
WARNING: This process is destructive!

These files will be MOVED to the 'renewed' sub-directory:
* $crt_in

These files will be DELETED:
All PKCS files for commonName: $file_name_base

The inline credentials files:
* $inline_pub
* $inline_pri"

	# move renewed files
	# so we can reissue certificate with the same name
	renew_move
	error_undo_renew_move=1

	# Set to modify sign-req confirmation message
	local_request=1

	# renew certificate
	# EASYRSA_BATCH=1
	if sign_req "$cert_type" "$file_name_base"
	then
		unset -v error_undo_renew_move
	else
		# If renew failed then restore cert.
		# Otherwise, issue a warning
		renew_restore_move
		die "Renewal has failed to build a new certificate."
	fi

	# Success messages
	notice "\
Renew was successful.

                    * IMPORTANT *

Renew has created a new certificate, to replace the old one.

To revoke the old certificate, once the new one has been deployed,
use command 'revoke-renewed $file_name_base'"
} # => renew()

# Restore files on failure to renew
renew_restore_move() {
	# restore crt file to PKI folders
	rrm_err=
	if mv "$restore_crt_out" "$restore_crt_in"; then
		: # ok
	else
		warn "Failed to restore: $restore_crt_in"
		rrm_err=1
	fi

	# messages
	if [ "$rrm_err" ]; then
		warn "Failed to restore renewed files."
	else
		notice "\
Renew FAILED but files have been successfully restored."
	fi
} # => renew_restore_move()

# renew_move
# moves renewed certificates to the 'renewed' folder
# allows reissuing certificates with the same name
renew_move() {
	# make sure renewed dirs exist
	easyrsa_mkdir "$out_dir"
	easyrsa_mkdir "$out_dir"/issued

	# move crt to renewed folders
	# After this point, renew is possible!
	restore_crt_in="$crt_in"
	restore_crt_out="$crt_out"
	mv "$crt_in" "$crt_out" || \
		die "Failed to move: $crt_in"

	# Remove files that can be recreated:
	# remove any pkcs files
	for pkcs in p12 p7b p8 p1; do
		# issued
		rm -f "$in_dir/issued/$file_name_base.$pkcs"
		# private
		rm -f "$in_dir/private/$file_name_base.$pkcs"
	done

	# remove inline files
	rm -f "$inline_pub" "$inline_pri" || warn \
		"renew_move - Error trying to remove inline files."
} # => renew_move()

# Verify certificate against CA
verify_cert() {
	# pull filename base:
	[ "$1" ] || user_error "\
Error: didn't find a <file-name-base> as the first argument.
Run easyrsa without commands for usage and command help."

	# Assign file_name_base and dust off!
	file_name_base="$1"
	shift

	# function opts support
	while [ "$1" ]; do
		case "$1" in
			# batch flag, return status [0/1] to calling
			# program.  Otherwise, exit 0 on completion.
			batch) EASYRSA_BATCH=1 ;;
			*) warn "Ignoring unknown command option: '$1'"
		esac
		shift
	done

	in_dir="$EASYRSA_PKI"
	ca_crt="$in_dir/ca.crt"
	crt_in="$in_dir/issued/$file_name_base.crt"

	# Cert file must exist
	[ -f "$crt_in" ] || user_error "\
No certificate found for the input:
* '$crt_in'"

	# Verify file is a valid cert
	verify_file x509 "$crt_in" || user_error "\
Input is not a valid certificate:
* $crt_in"

	# Silent SSL or not
	if [ "$EASYRSA_SILENT_SSL" ]; then
		# Test SSL out
		# openssl direct call because error is expected
		if "$EASYRSA_OPENSSL" verify \
			-CAfile "$ca_crt" "$crt_in" >/dev/null
		then
			verify_cert_ok=1
		else
			unset -v verify_cert_ok
		fi
	else
		if "$EASYRSA_OPENSSL" verify \
			-CAfile "$ca_crt" "$crt_in"
		then
			verify_cert_ok=1
		else
			unset -v verify_cert_ok
		fi
	fi

	# Return cert status
	if [ "$verify_cert_ok" ]; then
		notice "\
  Certificate name:    $file_name_base
  Verification status: GOOD"
	else
		notice "\
  Certificate name:    $file_name_base
  Verification status: FAILED"

		# Exit with error (batch mode)
		if [ "$EASYRSA_BATCH" ]; then
			# exit with error at cleanup
			easyrsa_exit_with_error=1
			# Return error for internal callers
			return 1
		fi
	fi
} # => verify_cert()

# Renew CA certificate
renew_ca_cert() {
	# dirs and files
	ca_key_file="$EASYRSA_PKI"/private/ca.key
	ca_cert_file="$EASYRSA_PKI"/ca.crt
	exp_ca_cert_list="$EASYRSA_PKI"/expired-ca.list

	# Set fixed variables
	x509=1
	date_stamp=1
	f_name="renew_ca_cert()"

	# Set default CA commonName
	[ "$EASYRSA_REQ_CN" = ChangeMe ] || \
		warn "\
$cmd does not support setting an external commonName."

	# Copy Old CA commonName as default
	export EASYRSA_REQ_CN="$(
		"$EASYRSA_OPENSSL" x509 -in "$ca_cert_file" \
		-noout -subject -nameopt utf8,multiline | \
			grep 'commonName' | sed -e \
			s\`^[[:blank:]]*commonName[[:blank:]]*=[[:blank:]]\`\`
	)"

	# Set ssl batch mode, as required
	[ "$EASYRSA_BATCH" ] && ssl_batch=1

	# create local SSL cnf
	write_easyrsa_ssl_cnf_tmp

	# Assign new cert temp-file
	out_cert_tmp=
	easyrsa_mktemp out_cert_tmp || \
		die "$f_name easyrsa_mktemp out_cert_tmp"

	# Assign old cert temp-file
	old_cert_tmp=
	easyrsa_mktemp old_cert_tmp || \
		die "$f_name easyrsa_mktemp old_cert_tmp"

	# Write complete CA cert to old cert temp-file
	"$EASYRSA_OPENSSL" x509 -in "$ca_cert_file" \
		-text > "$old_cert_tmp" || \
			die "$f_name Write CA cert to temp-file"

	# Find or create x509 CA file
	if [ -f "$EASYRSA_EXT_DIR/ca" ]; then
		# Use the x509-types/ca file
		x509_type_file="$EASYRSA_EXT_DIR/ca"
	else
		# Use a temp file
		write_x509_type_tmp ca
		x509_type_file="$write_x509_file_tmp"
	fi

	# basicConstraints critical
	if grep -q 'Basic Constraints: critical' "$old_cert_tmp"
	then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "$f_name easyrsa_mktemp BC crit_tmp"

		add_critical_attrib basicConstraints "$x509_type_file" \
			"$crit_tmp" || die "$f_name BC add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		verbose "renew_ca_cert: basicConstraints critical OK"
	fi

	# keyUsage critical
	if grep -q 'Key Usage: critical' "$old_cert_tmp"
	then
		crit_tmp=
		easyrsa_mktemp crit_tmp || \
			die "$f_name easyrsa_mktemp KU crit_tmp"

		add_critical_attrib keyUsage "$x509_type_file" \
			"$crit_tmp" || die "$f_name KU add_critical_attrib"

		# Use the new tmp-file with critical attribute
		x509_type_file="$crit_tmp"
		verbose "renew_ca_cert: keyUsage critical OK"
	fi

	# Find or create x509 COMMON file
	if [ -f "$EASYRSA_EXT_DIR/COMMON" ]; then
		# Use the x509-types/COMMON file
		x509_COMMON_file="$EASYRSA_EXT_DIR/COMMON"
	else
		# Use a temp file
		write_x509_type_tmp COMMON
		x509_COMMON_file="$write_x509_file_tmp"
	fi

	# Check for insert-marker in ssl config file
	if ! grep -q '^#%CA_X509_TYPES_EXTRA_EXTS%' \
		"$EASYRSA_SSL_CONF"
	then
		die "\
This openssl config file does not support X509-type 'ca'.
* $EASYRSA_SSL_CONF

Please update 'openssl-easyrsa.cnf' to the latest Easy-RSA release."
	fi

	# Assign awkscript to insert EASYRSA_EXTRA_EXTS
	# shellcheck disable=SC2016 # No expand '' - build_ca()
	awkscript='\
{if ( match($0, "^#%CA_X509_TYPES_EXTRA_EXTS%") )
{ while ( getline<"/dev/stdin" ) {print} next }
{print} }'

	# Assign tmp-file for config
	adjusted_ssl_cnf_tmp=""
	easyrsa_mktemp adjusted_ssl_cnf_tmp || \
		die "$f_name easyrsa_mktemp adjusted_ssl_cnf_tmp"

	# Insert x509-types COMMON and 'ca' and EASYRSA_EXTRA_EXTS
	{
		# X509 files
		cat "$x509_type_file" "$x509_COMMON_file"

		# User extensions
		[ "$EASYRSA_EXTRA_EXTS" ] && \
			print "$EASYRSA_EXTRA_EXTS"

	} | awk "$awkscript" "$EASYRSA_SSL_CONF" \
			> "$adjusted_ssl_cnf_tmp" || \
				die "$f_name Copy X509_TYPES to config failed"
	verbose "$f_name insert x509 and extensions OK"

	# Use this new SSL config for the rest of this function
	EASYRSA_SSL_CONF="$adjusted_ssl_cnf_tmp"

	# Generate new CA cert:
	easyrsa_openssl req -utf8 -new \
		-key "$ca_key_file" \
		-out "$out_cert_tmp" \
		${ssl_batch:+ -batch} \
		${x509:+ -x509} \
		${date_stamp:+ -days "$EASYRSA_CA_EXPIRE"} \
		${EASYRSA_DIGEST:+ -"$EASYRSA_DIGEST"} \
		${EASYRSA_NO_PASS:+ "$no_password"} \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} \
		# EOL

	# Collect New CA text
	new_ca_text="$(
		"$EASYRSA_OPENSSL" x509 -in "$out_cert_tmp" -noout -text
	)"

	# Confirm renewed certificate installation
	confirm "Install the new CA certificate ? " yes "
NEW CA CERTIFICATE:

$new_ca_text

WARNING !!!

Your CA certificate is ready to be renewed. (Details above)

This new CA certificate will completely replace the old one.
The old CA will be archived to the 'expired-ca.list' file.

Please check the details above are correct, before continuing."

	# Prepare header file for updated old CA list
	header_tmp=
	easyrsa_mktemp header_tmp || \
		die "$f_name easyrsa_mktemp header_tmp"

	# header and separator text
	hdr='# Easy-RSA expired CA certificate list:'
	spr='# ====================================='

	# make full header temp-file
	printf '%s\n%s\n\n' "$hdr" "$spr" > "$header_tmp" || \
		die "$f_name printf header to header-temp"

	# Prepare old cert list
	if [ -f "$exp_ca_cert_list" ]; then
		# Assign old cert list temp file
		exp_cert_list_tmp=
		easyrsa_mktemp exp_cert_list_tmp || \
			die "$f_name easyrsa_mktemp exp_cert_list_tmp"

		# write list to temp-fie, remove header not separators
		sed -e s/"^${hdr}$"// \
			"$exp_ca_cert_list" > "$exp_cert_list_tmp" || \
				die "$f_name sed exp_ca_cert_list"
	fi

	# Add full old CA Cert to old CA Cert list file
	if [ -f "$exp_cert_list_tmp" ]; then
		cat "$header_tmp" "$old_cert_tmp" "$exp_cert_list_tmp" \
			> "$exp_ca_cert_list" || \
				die "$f_name cat exp_cert_list_tmp"
	else
		cat "$header_tmp" "$old_cert_tmp" \
			> "$exp_ca_cert_list" || \
				die "$f_name cat old_cert_tmp"
	fi

	# Install renewed CA Cert temp-file as current CA cert
	mv -f "$out_cert_tmp" "$ca_cert_file" || \
		die "Failed to install renewed CA temp-file!"

	notice "\
CA certificate has been successfully renewed.

Your old CA cerificate has been added to the expired CA list at:
* $exp_ca_cert_list

Your renewed CA cerificate is at:
* $ca_cert_file"
} # => renew_ca_cert()

# update-db backend
update_db() {
	easyrsa_openssl ca -utf8 -updatedb \
		${EASYRSA_PASSIN:+ -passin "$EASYRSA_PASSIN"} || \
			die "Failed to perform update-db."
} # => update_db()

# display cert DN info on a req/X509, passed by full pathname
display_dn() {
	[ "$#" = 2 ] || die "\
display_dn - input error"

	format="$1"
	path="$2"
	shift 2

	# Display DN
	"$EASYRSA_OPENSSL" "$format" -in "$path" -noout -subject \
	-nameopt utf8,sep_multiline,space_eq,lname,align
} # => display_dn()

# verify a file seems to be a valid req/X509
verify_file() {
	format="$1"
	path="$2"
	"$EASYRSA_OPENSSL" "$format" -in "$path" -noout 2>/dev/null
} # => verify_file()

# show-* command backend
# Prints req/cert details in a readable format
show() {
	type="$1"
	name="$2"
	in_file=""
	format=""
	[ "$name" ] || user_error "\
Missing expected <file_name_base> argument.
Run easyrsa without commands for usage help."
	shift 2

	# opts support
	type_opts="-${type}opt"
	out_opts="no_pubkey,no_sigdump"
	name_opts="utf8,sep_multiline,space_eq,lname,align"
	while [ "$1" ]; do
		case "$1" in
			full) out_opts= ;;
			*) warn "Ignoring unknown command option: '$1'"
		esac
		shift
	done

	# Determine cert/req type (v2)
	case "$type" in
	cert)
		in_file="$EASYRSA_PKI/issued/$name.crt"
		format="x509"
		;;
	req)
		in_file="$EASYRSA_PKI/reqs/$name.req"
		format="req"
		;;
	crl)
		in_file="$EASYRSA_PKI/$name.pem"
		format="crl"
		unset -v type_opts out_opts name_opts
		;;
	*) die "Unrecognised type: $type"
	esac

	# Verify file exists and is of the correct type
	[ -f "$in_file" ] || user_error "\
No such '$type' type file with a <file_name_base> of '$name'.
Expected to find this file at:
* $in_file"

	verify_file "$format" "$in_file" || user_error "\
This file is not a valid $type file:
* $in_file"

	notice "\
Showing '$type' details for: '$name'

This file is stored at:
* $in_file${NL}"

	easyrsa_openssl "$format" -in "$in_file" -noout -text \
		${type_opts:+ "$type_opts" "$out_opts"} \
		${name_opts:+ -nameopt "$name_opts"} || \
			die "OpenSSL failure to process the input"
} # => show()

# show-ca command backend
# Prints CA cert details in a readable format
show_ca() {
	# opts support
	out_opts="no_pubkey,no_sigdump"
	name_opts="utf8,sep_multiline,space_eq,lname,align"
	while [ "$1" ]; do
		case "$1" in
			full) out_opts= ;;
			*) warn "Ignoring unknown command option: '$1'"
		esac
		shift
	done

	in_file="$EASYRSA_PKI/ca.crt"
	format="x509"

	# Verify file exists and is of the correct type
	[ -f "$in_file" ] || user_error "\
No such $type file with a basename of '$name' is present.
Expected to find this file at:
$in_file"

	verify_file "$format" "$in_file" || user_error "\
This file is not a valid $type file:
$in_file"

	notice "\
Showing details for CA certificate, at:
* $in_file${NL}"

	easyrsa_openssl "$format" -in "$in_file" -noout -text \
		-nameopt "$name_opts" -certopt "$out_opts" || \
			die "OpenSSL failure to process the input"
} # => show_ca()

# Certificate X509v3 Extended Key Usage
ssl_cert_x509v3_eku() {
	[ "$1" ] || die "ssl_cert_x509v3_eku - Missing input"

	# check input file name
	if [ -f "$1" ]; then
		__crt="$1"
	else
		__crt="${EASYRSA_PKI}/issued/${1}.crt"
		[ -f "$__crt" ] || \
			die "ssl_cert_x509v3_eku - Missing cert '$__crt'"
	fi

	# Set output variable
	__var="$2"
	shift "$#"

	# required variables
	__pattern="X509v3 Extended Key Usage:"
	__cli="TLS Web Client Authentication"
	__srv="TLS Web Server Authentication"
	__srv_cli="${__srv}, ${__cli}"
	__codeSign="Code Signing"
	unset -v __known

	# Extract certificate Extended Key Usage
	if [ "$ssl_lib" = libressl ]; then
		__eku="$(
			"$EASYRSA_OPENSSL" x509 -in "${__crt}" -noout -text | \
				sed -n "/${__pattern}/{n;s/^ *//g;p;}"
			)"
	else
		__eku="$(
			"$EASYRSA_OPENSSL" x509 -in "${__crt}" -noout \
				-ext extendedKeyUsage | \
					sed -e /"${__pattern}"/d -e s/^\ *//
			)"
	fi

	# Match EKU with supported usage
	case "$__eku" in
		"$__srv_cli")
			__known=1
			__type=serverClient
			;;
		"$__cli")
			__known=1
			__type=client
			;;
		"$__srv")
			__known=1
			__type=server
			;;
		"$__codeSign")
			__known=1
			__type=codeSign
			;;
		'')
			__type=undefined
			;;
		*)
			__type="'$__eku'"
	esac

	# Check for self-sign
	if "$EASYRSA_OPENSSL" x509 -in "$__crt" -noout -text | \
		grep -q 'CA:TRUE'
	then
		__type="self-signed-$__type"
	fi

	# Set variable to return
	if [ "$__var" ]; then
		verbose "ssl_cert_x509v3_eku - EKU: $__type"
		force_set_var "$__var" "$__type"
	elif [ "$__known" ]; then
		information "
* Known X509v3 Extended Key Usage: $__type"
	else
		information "
* Unknown X509v3 Extended Key Usage: $__type"
	fi

	unset -v __crt __var __pattern __srv_cli __cli __srv \
		__codeSign __eku __type

	if [ "$__known" ]; then
		unset -v __known
		return
	fi

	# Also, catch errors from SSL x509 command
	# for '__eku' subshell+pipe
	return 1
} # => ssl_cert_x509v3_eku()

# get the serial number of the certificate -> serial=XXXX
ssl_cert_serial() {
	[ "$#" = 2 ] || die "ssl_cert_serial - input error"
	[ -f "$1" ] || die "ssl_cert_serial - missing cert"

	fn_ssl_out="$(
		"$EASYRSA_OPENSSL" x509 -in "$1" -noout -serial
		)" || die "ssl_cert_serial - failed: -serial"
	# remove the serial= part -> we only need the XXXX part
	fn_ssl_out="${fn_ssl_out##*=}"

	force_set_var "$2" "$fn_ssl_out" || \
		die "ssl_cert_serial - failed to set var '$*'"

	unset -v fn_ssl_out
} # => ssl_cert_serial()

# Identify host OS
detect_host() {
	unset -v \
		easyrsa_ver_test easyrsa_host_os easyrsa_host_test \
			easyrsa_win_git_bash

	# Detect Windows
	[ "${OS}" ] && easyrsa_host_test="${OS}"

	# shellcheck disable=SC2016 # No expand '' - detect_host()
	easyrsa_ksh=\
'@(#)MIRBSD KSH R39-w32-beta14 $Date: 2013/06/28 21:28:57 $'

	[ "${KSH_VERSION}" = "${easyrsa_ksh}" ] && \
		easyrsa_host_test="${easyrsa_ksh}"
	unset -v easyrsa_ksh

	# If not Windows then nix
	if [ "${easyrsa_host_test}" ]; then
		easyrsa_host_os=win
		easyrsa_uname="${easyrsa_host_test}"
		easyrsa_shell="$SHELL"
		# Detect Windows git/bash
		if [ "${EXEPATH}" ]; then
			easyrsa_shell="$SHELL (Git)"
			easyrsa_win_git_bash="${EXEPATH}"
			# If found then set openssl NOW!
			#[ -e /usr/bin/openssl ] && \
			#	set_var EASYRSA_OPENSSL /usr/bin/openssl
		fi
	else
		easyrsa_host_os=nix
		easyrsa_uname="$(uname 2>/dev/null)"
		easyrsa_shell="${SHELL:-undefined}"
	fi

	easyrsa_ver_test="${EASYRSA_version%%~*}"
	if [ "$easyrsa_ver_test" ]; then
		host_out="Host: $EASYRSA_version"
	else
		host_out="Host: dev"
	fi

	host_out="\
$host_out | $easyrsa_host_os | $easyrsa_uname | $easyrsa_shell"
	host_out="\
${host_out}${easyrsa_win_git_bash+ | "$easyrsa_win_git_bash"}"
	unset -v easyrsa_ver_test easyrsa_host_test
} # => detect_host()

# Extra diagnostics
show_host() {
	[ "$EASYRSA_SILENT" ] && return
	print_version
	print "$host_out"
	[ "$EASYRSA_DEBUG" ] || return 0
	case "$easyrsa_host_os" in
		win) set ;;
		nix) env ;;
		*) print "Unknown host OS: $easyrsa_host_os"
	esac
} # => show_host()

# Verify the selected algorithm parameters
verify_algo_params() {
	case "$EASYRSA_ALGO" in
	rsa)
		# Set RSA key size
		EASYRSA_ALGO_PARAMS="$EASYRSA_KEY_SIZE"
		;;
	ec)
		# Verify Elliptic curve
		EASYRSA_ALGO_PARAMS=""
		easyrsa_mktemp EASYRSA_ALGO_PARAMS || \
			die "\
verify_algo_params - easyrsa_mktemp EASYRSA_ALGO_PARAMS"

		# Create the required ecparams file, temp-file
		# call openssl directly because error is expected
			"$EASYRSA_OPENSSL" ecparam \
				-name "$EASYRSA_CURVE" \
				-out "$EASYRSA_ALGO_PARAMS" \
				>/dev/null 2>&1 || user_error "\
Failed to generate ecparam file for curve '$EASYRSA_CURVE'"
		;;
	ed)
		# Verify Edwards curve
		# call openssl directly because error is expected
			"$EASYRSA_OPENSSL" genpkey \
				-algorithm "$EASYRSA_CURVE" \
				>/dev/null 2>&1 || user_error "\
Edwards Curve '$EASYRSA_CURVE' not found."
		;;
	*) user_error "\
Unknown algorithm '$EASYRSA_ALGO': Must be 'rsa', 'ec' or 'ed'"
	esac
	verbose "\
verify_algo_params: Params verified for algo '$EASYRSA_ALGO' OK"
} # => verify_algo_params()

# Check for conflicting input options
mutual_exclusions() {
	# --nopass cannot be used with --passout
	if [ "$EASYRSA_PASSOUT" ]; then
		# --passout MUST take priority over --nopass
		[ "$EASYRSA_NO_PASS" ] && warn "\
Option --passout cannot be used with --nopass|nopass."
		unset -v EASYRSA_NO_PASS
		prohibit_no_pass=1
	fi

	# Restrict --days=0 to 'show-expire'
	if [ "$alias_days" = 0 ]; then
		case "$cmd" in
			show-expire) : ;; # ok
			*) user_error "Cannot use --days=0 for command $cmd"
		esac
	fi

	# --silent-ssl requires --batch
	if [ "$EASYRSA_SILENT_SSL" ]; then
		[ "$EASYRSA_BATCH" ] || warn "\
Option --silent-ssl requires batch mode --batch."
	fi

	# --startdate requires --enddate
	# otherwise, --days counts from now
	if [ "$EASYRSA_START_DATE" ]; then
		[ "$EASYRSA_END_DATE" ] || user_error "\
Use of --startdate requires use of --enddate."
	fi

	# --enddate may over-rule EASYRSA_CERT_EXPIRE
	if [ "$EASYRSA_END_DATE" ]; then
		case "$cmd" in
			sign-req|build-*-full|renew)
				# User specified alias_days IS over-ruled
				if [ "$alias_days" ]; then
					warn "\
Option --days is over-ruled by option --enddate."
				fi
				unset -v EASYRSA_CERT_EXPIRE alias_days
				;;
			*)
				warn "\
EasyRSA '$cmd' does not support --startdate or --enddate"
				unset -v EASYRSA_START_DATE EASYRSA_END_DATE
		esac
	fi

	# Insecure Windows directory
	if [ "$easyrsa_host_os" = win ]; then
		if echo "$PWD" | grep -q '/Prog.*/OpenVPN/easy-rsa'
		then
			verbose "\
Using Windows-System-Folders for your PKI is NOT SECURE!
Your Easy-RSA PKI CA Private Key is WORLD readable.

To correct this problem, it is recommended that you either:
* Copy Easy-RSA to your User folders and run it from there, OR
* Define your PKI to be in your User folders. EG:
  'easyrsa --pki-dir=\"C:/Users/<your-user-name>/easy-rsa/pki\"\
 <command>'"
		fi
	fi

	verbose "mutual_exclusions: COMPLETED"
} # => mutual_exclusions()

# Select vars in order preference:
# Here sourcing of 'vars' if present occurs.
# If not present, defaults are used to support
# running without a sourced config format.
select_vars() {
	# User specified vars file will be used ONLY
	if [ "$EASYRSA_VARS_FILE" ]; then
		# Takes priority, nothing to do
		verbose "select_vars: EASYRSA_VARS_FILE"

	# This is where auto-load goes bananas
	else

		# User specified PKI; if vars exists, use it ONLY
		if [ "$EASYRSA_PKI" ]; then
			if [ -f "$EASYRSA_PKI/vars" ]; then
				verbose "select_vars: source EASYRSA_PKI/vars"
				set_var EASYRSA_VARS_FILE "$EASYRSA_PKI/vars"
			fi
		fi

		# User specified EASYRSA; if vars exists, use it ONLY
		if [ "$EASYRSA" ]; then
			if [ -f "$EASYRSA/vars" ]; then
				verbose "select_vars: EASYRSA/vars"
				set_var EASYRSA_VARS_FILE "$EASYRSA/vars"
			fi
		fi

		# Default PKI; if vars exists, use it ONLY
		if [ -f "$PWD/pki/vars" ] && \
			[ -z "$EASYRSA_PKI" ] && \
			[ -z "$EASYRSA" ]
		then
			# Prevent vars from changing expected PKI.
			# A vars in the PKI MUST always imply EASYRSA_PKI
			# This is NOT backward compatible
			# Use expected value comparison for v3.1.7
			if [ -z "$EASYRSA_VARS_FILE" ]; then
				expected_EASYRSA="$PWD"
				expected_EASYRSA_PKI="$PWD/pki"
			fi

			# Use this for v3.2.0
			# If the pki/vars sets a different PKI then
			# there will be no PKI in the default /pki
			#set_var EASYRSA "$PWD"
			#set_var EASYRSA_PKI "$EASYRSA/pki"

			verbose "select_vars: PWD/pki/vars"
			set_var EASYRSA_VARS_FILE "$PWD/pki/vars"
		fi

		# Default working dir; if vars exists, use it ONLY
		if [ -f "$PWD/vars" ]; then
			verbose "select_vars: PWD/vars"
			set_var EASYRSA_VARS_FILE "$PWD/vars"
		fi
	fi

	# if select_vars failed to find a vars file
	if [ -z "$EASYRSA_VARS_FILE" ]; then
		verbose "select_vars: No vars"
		return 1
	fi
} # => select_vars()

# Source a vars file
source_vars() {
	# File to be sourced
	target_file="$1"

	# 'vars' MUST not be a directory
	[ -d "$target_file" ] && user_error "\
Missing vars file:
* $target_file"

	# 'vars' now MUST exist
	[ -f "$target_file" ] || user_error "\
Missing vars file:
* $target_file"

	# Sanitize vars
	if grep -q \
		-e 'EASYRSA_PASSIN' -e 'EASYRSA_PASSOUT' \
		-e '[^(]`[^)]' \
		-e 'export ' \
		-e 'unset ' \
			"$target_file"
	then
		# here we go ..
		err_msg="\
These problems have been found in your 'vars' settings:${NL}"

		# No passwords!
		if grep -q \
			-e 'EASYRSA_PASSIN' -e 'EASYRSA_PASSOUT' \
			"$target_file"
		then
			err_msg="${err_msg}
  Use of 'EASYRSA_PASSIN' or 'EASYRSA_PASSOUT':
  Storing password information in the 'vars' file is not permitted."
		fi

		# No backticks
		if grep -q \
			-e '[^(]`[^)]' \
			"$target_file"
		then
			err_msg="${err_msg}
  Use of unsupported characters:
  These characters are not supported: \` backtick"
		fi

		# No export
		if grep -q \
			-e 'export ' \
			"$target_file"
		then
			err_msg="${err_msg}
  Use of 'export':
  Remove 'export' or replace it with 'set_var'."
		fi

		# No unset
		if grep -q \
			-e 'unset ' \
			"$target_file"
		then
			err_msg="${err_msg}
  Use of 'unset':
  Remove 'unset' ('force_set_var' may also work)."
		fi

		# Fatal error
		user_error "${err_msg}${NL}
Please, correct these errors and try again."

	else
		verbose "source_vars: CLEAN '$target_file'"
	fi

	# Enable sourcing 'vars'
	# shellcheck disable=SC2034 # appears unused - source_vars()
	EASYRSA_CALLER=1
	easyrsa_path="$PATH"
	# shellcheck disable=SC2123 # PATH is - source_vars()
	PATH=./

	# Test sourcing 'vars' in a subshell
	# shellcheck disable=1090 # can't follow - source_vars()
	if ( . "$target_file" ); then
		# Source 'vars' now
		# shellcheck disable=1090 # can't follow - source_vars()
		. "$target_file" || \
			die "Failed to source the '$target_file' file."
	else
		PATH="$easyrsa_path"
		die "Failed to dry-run the '$target_file' file."
	fi

	PATH="$easyrsa_path"
	verbose "source_vars: sourced OK '$target_file'"
	unset -v EASYRSA_CALLER easyrsa_path target_file
} # => source_vars()

# Set defaults
default_vars() {
	# Set defaults, preferring existing env-vars if present
	set_var EASYRSA					"$PWD"
	set_var EASYRSA_OPENSSL			openssl
	set_var EASYRSA_PKI				"$EASYRSA/pki"
	set_var EASYRSA_DN				cn_only
	set_var EASYRSA_REQ_COUNTRY		"US"
	set_var EASYRSA_REQ_PROVINCE	"California"
	set_var EASYRSA_REQ_CITY		"San Francisco"
	set_var EASYRSA_REQ_ORG			"Copyleft Certificate Co"
	set_var EASYRSA_REQ_EMAIL		me@example.net
	set_var EASYRSA_REQ_OU			"My Organizational Unit"
	set_var EASYRSA_REQ_SERIAL		""
	set_var EASYRSA_ALGO			rsa
	set_var EASYRSA_KEY_SIZE		2048

	case "$EASYRSA_ALGO" in
		rsa)
			: # ok
			# default EASYRSA_KEY_SIZE must always be set
			# it must NOT be set selectively because it is
			# present in the SSL config file
			;;
		ec)
			set_var EASYRSA_CURVE		secp384r1
			;;
		ed)
			set_var EASYRSA_CURVE		ed25519
			;;
		*) user_error "\
Algorithm '$EASYRSA_ALGO' is invalid: Must be 'rsa', 'ec' or 'ed'"
	esac

	set_var EASYRSA_CA_EXPIRE		3650
	set_var EASYRSA_CERT_EXPIRE		825
	set_var \
		EASYRSA_PRE_EXPIRY_WINDOW	90
	set_var EASYRSA_CRL_DAYS		180
	set_var EASYRSA_NS_SUPPORT		no
	set_var EASYRSA_NS_COMMENT		\
		"Easy-RSA (~VER~) Generated Certificate"

	set_var EASYRSA_TEMP_DIR		"$EASYRSA_PKI"
	set_var EASYRSA_REQ_CN			ChangeMe
	set_var EASYRSA_DIGEST			sha256

	set_var EASYRSA_KDC_REALM		"CHANGEME.EXAMPLE.COM"

	set_var EASYRSA_MAX_TEMP		1
} # => default_vars()

# Validate expected values for EASYRSA and EASYRSA_PKI
validate_default_vars() {
	unset -v unexpected_error

	# Keep checks separate
	# EASYRSA
	if [ "$expected_EASYRSA" ]; then
		[ "$expected_EASYRSA" = "$EASYRSA" ] || \
			unexpected_error="\
       EASYRSA: $EASYRSA
      Expected: $expected_EASYRSA"
	fi

	# EASYRSA_PKI
	if [ "$expected_EASYRSA_PKI" ]; then
		if [ "$expected_EASYRSA_PKI" = "$EASYRSA_PKI" ]; then
			: # ok
		else
			if [ "$unexpected_error" ]; then
				# Add a new-line Extra separator, for clarity
				unexpected_error="${unexpected_error}${NL}${NL}"
			fi
			unexpected_error="${unexpected_error}\
   EASYRSA_PKI: $EASYRSA_PKI
      Expected: $expected_EASYRSA_PKI"
		fi
	fi

	# Return no error
	[ -z "$unexpected_error" ] && return

	# This is an almost unacceptable error
	invalid_vars=1
	[ "$quiet_vars" ] || user_error "\
The values in the vars file have unexpectedly changed the values for
EASYRSA and/or EASYRSA_PKI. The default pki/vars file is forbidden to
change these values.

     vars-file: $EASYRSA_VARS_FILE

${unexpected_error}"
} # => validate_default_vars()

# Verify working environment
verify_working_env() {
	verbose "verify_working_env: BEGIN"
	# For commands which 'require a PKI' and PKI exists
	if [ "$require_pki" ]; then
		# Verify PKI is initialised
		verify_pki_init

		# Temp dir session
		secure_session

		# global safe ssl cnf temp
		write_global_safe_ssl_cnf_tmp

		# Verify selected algorithm and parameters
		verify_algo_params

		# Verify CA is initialised
		if [ "$require_ca" ]; then
			verify_ca_init
		fi
	else
		# For commands that do not require a PKI
		# but do require a temp-dir, eg. 'write'
		# If there is a valid temp-dir:
		# Create temp-session and openssl-easyrsa.cnf (Temp) now
		if [ -d "$EASYRSA_TEMP_DIR" ]; then
			# Temp dir session
			secure_session

			# global safe ssl cnf temp
			write_global_safe_ssl_cnf_tmp
		fi
	fi

	# Find x509-types, openssl-easyrsa.cnf
	# and easyrsa-tools.lib
	locate_support_files

	# Save original EASYRSA_SSL_CONF
	original_ssl_cnf="$EASYRSA_SSL_CONF"

	verbose "verify_working_env: COMPLETED Handover-to: $cmd"
} # => verify_working_env()

# variable assignment by indirection.
# Sets '$1' as the value contained in '$2'
# and exports (may be blank)
set_var() {
	[ -z "$*" ] && return
	[ -z "$3" ] || \
		user_error "set_var - excess input '$*'"
	case "$1" in
		*=*) user_error "set_var - var '$1'"
	esac
	eval "export \"$1\"=\"\${$1-$2}\"" && return
	die "set_var - eval '$*'"
} # => set_var()

# sanitize and set var
# nix.sh/win.sh/busybox.sh never return error from unset
# when an invalid variable name 'a=b' is used with a value
# to set, eg. 'c'; This causes EasyRSA to execute:
# eval "export a=b=c". 'set_var EASYRSA_PKI=pki' results in
# $EASYRSA_PKI being set to 'pki=pki-', without error!
# Guard against this possible user error with 'case'.
force_set_var() {
	[ -z "$3" ] || \
		user_error "force_set_var - excess input '$*'"
	case "$1" in
		*=*) user_error "force_set_var - var '$1'"
	esac
	# force unsetting $1; Guard unset with '|| die', just in case
	unset -v "$1" || die "force_set_var - unset '$1'"
	# Allow empty value to unset variable by returning
	[ "$2" ] || return 0
	set_var "$1" "$2" && return
	die "force_set_var - set_var '$*'"
} # => force_set_var()

# global Safe SSL conf file, for use by any SSL lib
write_global_safe_ssl_cnf_tmp() {
	global_safe_ssl_cnf_tmp=
	easyrsa_mktemp global_safe_ssl_cnf_tmp || die "\
verify_working_env - easyrsa_mktemp global_safe_ssl_cnf_tmp"

	write_legacy_file_v2 safe-cnf "$global_safe_ssl_cnf_tmp" || \
		die "verify_working_env - write safe-cnf"

	export OPENSSL_CONF="$global_safe_ssl_cnf_tmp"
	verbose "GLOBAL - OPENSSL_CONF = $OPENSSL_CONF"
} # => write_global_safe_ssl_cnf_tmp()

# Create as needed: $EASYRSA_SSL_CONF pki/openssl-easyrsa.cnf
# If the existing file has a known hash then use temp-file.
# Otherwise, use the file in place.
write_easyrsa_ssl_cnf_tmp() {
	# If EASYRSA_SSL_CONF is undefined then use default
	[ "$EASYRSA_SSL_CONF" ] || set_var \
		EASYRSA_SSL_CONF "$EASYRSA_PKI"/openssl-easyrsa.cnf

	if [ -f "$EASYRSA_SSL_CONF" ]; then
		verbose "write_easyrsa_ssl_cnf_tmp: SSL config EXISTS"

		# Set known hashes
		# 3.1.7 -> Current
		known_file_317="\
13ca05f031d58c5e2912652b33099ce9\
ac05f49595e5d5fe96367229e3ce070c"

		# 3.1.5 -> 3.1.6
		known_file_315="\
87d51ca0db1cc0ac3cc2634792fc5576\
e0034ebf9d546de11674b897514f3afb"

		# 3.1.0 -> 3.1.4
		known_file_310="\
5455947df40f01f845bf79c1e89f102c\
628faaa65d71a6512d0e17bdd183feb0"

		# 3.0.8 -> 3.0.9
		known_file_308="\
1cc6a1de93ca357b5c364aa0fa2c4bea\
f97425686fa1976d436fa31f550641aa"

		# Built-in here-doc 3.2.0
		known_heredoc_320="\
82439f1860838e28f6270d5d06b17717\
56db777861e19bf9edc21222f86a310d"

		# Get file hash
		file_hash="$(
			"$EASYRSA_OPENSSL" dgst -sha256 -r \
				"$EASYRSA_SSL_CONF" 2>/dev/null
		)" || die "write_easyrsa_ssl_cnf_tmp - hash malfunction!"

		# Strip excess SSL info
		file_hash="${file_hash%% *}"

		# Compare SSL output
		case "$file_hash" in
		*[!1234567890abcdef]*|'')
			die "write_easyrsa_ssl_cnf_tmp - hash failure!"
		esac

		# Check file hash against known hash
		hash_is_unknown=""

		case "$file_hash" in
			"$known_file_317") ;;
			"$known_file_315") ;;
			"$known_file_310") ;;
			"$known_file_308") ;;
			"$known_heredoc_320") ;;

			*)
				# File is unknown or has been changed
				# leave in place
				hash_is_unknown=1
		esac

		# Cleanup
		unset -v file_hash known_heredoc_320 \
				known_file_317 \
				known_file_315 \
				known_file_310 \
				known_file_308

		# Use the existing file ONLY
		if [ "$hash_is_unknown" ] || [ "$EASYRSA_FORCE_SAFE_SSL" ]
		then
			unset -v hash_is_unknown
			verbose "write_easyrsa_ssl_cnf_tmp: SSL config UNKNOWN!"

			# Auto-escape hazardous characters
			escape_hazard || \
				die "easyrsa_openssl - escape_hazard failed"

			# Rewrite SSL config
			expand_ssl_config || \
				die "easyrsa_openssl - expand_ssl_config failed"

			return 0
		fi

		# Ignore existing file, prefer to use a temp-file
		verbose "write_easyrsa_ssl_cnf_tmp: SSL config KNOWN"
	fi

	# SET and USE temp-file from here-doc Now
	# Create temp-file
	ssl_cnf_tmp=
	easyrsa_mktemp ssl_cnf_tmp || die "\
write_easyrsa_ssl_cnf_tmp - easyrsa_mktemp"

	# Write SSL cnf to temp-file
	write_legacy_file_v2 "$ssl_cnf_type" "$ssl_cnf_tmp" || die "\
write_easyrsa_ssl_cnf_tmp - write $ssl_cnf_type: $ssl_cnf_tmp"

	# export SSL cnf tmp
	export EASYRSA_SSL_CONF="$ssl_cnf_tmp"
	verbose "\
write_easyrsa_ssl_cnf_tmp: $ssl_cnf_type \
- EASYRSA_SSL_CONF = $EASYRSA_SSL_CONF"

	export OPENSSL_CONF="$EASYRSA_SSL_CONF"
	verbose "LOCAL - OPENSSL_CONF = $OPENSSL_CONF"
} # => write_easyrsa_ssl_cnf_tmp()

# Write x509 type file to a temp file
write_x509_type_tmp() {
	# Verify x509-type before redirect
	case "$1" in
		COMMON|ca|server|serverClient|client|email| \
		codeSigning|kdc|selfsign)
			: # ok
		;;
	*)
		die "write_x509_type_tmp - unknown type '$1'"
	esac

	write_x509_file_tmp=""
	easyrsa_mktemp write_x509_file_tmp || \
		die "write_x509_type_tmp - easyrsa_mktemp"

	write_legacy_file_v2 "$1" "$write_x509_file_tmp" || \
		die "write_x509_type_tmp - write $1"


	verbose ": write_x509_type_tmp: $1 COMPLETE"
} # => write_x509_type_tmp()

############################################################################
#
# Create legacy files
#

# Write ALL legacy files to $1 or default
all_legacy_files_v2() {
	# Confirm over write
	if [ "$legacy_file_over_write" ]; then
		confirm "${NL}  Confirm OVER-WRITE files ? " yes "
Warning:
'legacy-hard' will OVER-WRITE all legacy files to default settings.

Legacy files:
* File: ${EASYRSA_PKI}/openssl-easyrsa.cnf
* File: ${EASYRSA_PKI}/vars.example
* Dir:  ${EASYRSA_PKI}/x509-types/*"

		verbose "all_legacy_files_v2 - over-write ENABLED"
	fi

	# Output directories
	legacy_out_d="$EASYRSA_PKI"
		easyrsa_mkdir "$legacy_out_d"
	x509_types_d="$legacy_out_d"/x509-types
		easyrsa_mkdir "$x509_types_d"

	# Create x509-types
	for legacy_type in COMMON ca server serverClient client \
		email codeSigning kdc
	do
		legacy_target="${x509_types_d}/${legacy_type}"
		write_legacy_file_v2 "$legacy_type" "$legacy_target" \
			"$legacy_file_over_write"
	done

	# vars.example
	legacy_type=vars
	legacy_target="$legacy_out_d"/vars.example
	write_legacy_file_v2 "$legacy_type" "$legacy_target" \
		"$legacy_file_over_write"

	# openssl-easyrsa.cnf
	legacy_type=ssl-cnf
	legacy_target="$legacy_out_d"/openssl-easyrsa.cnf
	write_legacy_file_v2 "$legacy_type" "$legacy_target" \
		"$legacy_file_over_write"

	# User notice
	if [ "$legacy_file_over_write" ]; then
		notice "legacy-hard has updated all files."
	else
		notice "legacy has updated missing files."
	fi
} # => all_legacy_files_v2()

# write legacy files to stdout or user defined file
write_legacy_file_v2() {
	# recursion check
	write_recursion="$(( write_recursion + 1 ))"
	if [ "$write_recursion" -gt 1 ]; then
		print "write recursion" > "$easyrsa_err_log"
		die "write recursion"
	fi

	write_type="$1"
	write_file="$2"
	write_over=
	[ "$3" = overwrite ] && write_over=1

	# Select by type
	case "$write_type" in
	ssl-cnf)
		set_openssl_easyrsa_cnf_vars unexpanded
		;;
	safe-cnf)
		set_openssl_easyrsa_cnf_vars expanded
		;;
	vars)
		;;
	# This correctly renames 'code-signing' to 'codeSigning'
	COMMON|ca|server|serverClient|client|codeSigning|email|kdc)
		;;
	selfsign)
		;;
	*)
		user_error "write - unknown type '$write_type'"
	esac

	# If $write_file is given then establish overwrite rules
	if [ "$write_file" ]; then

		# $write_file must not be a directory
		[ -d "$write_file" ] && user_error \
			"write: Target is a directory: '$write_file'"

		# If $write_file exists then check for temp-file
		if [ -f "$write_file" ]; then
			# if this is a temp file then enable auto-overwrite
			path="${write_file%%/temp.*}"
			if [ "$path" = "${secured_session}" ]; then
				verbose ": write_legacy_file_v2 - temp-file ACCEPTED"
				write_over=1
			else
				# target is not a temp-file, overwrite not changed
				verbose ": Target is not a temp-file: $write_file"
			fi
		else
			verbose ": Create new file: $write_file"
		fi
	else
		verbose ": No target file - output to stdout"
	fi

	# write legacy data stream to stdout or file
	if [ -f "$write_file" ]; then
		if [ "$write_over" ]; then
			verbose ": write_legacy_file_v2 - over-write ENABLED"
			create_legacy_stream "$write_type" > "$write_file" || \
				die "write failed"
			[ "$EASYRSA_DEBUG" ] && print \
				"### write OVERWRITE: $write_type to $write_file"
		else
			# Preserve existing file and continue
			verbose "write_legacy_file_v2 - over-write DISABLED "
			[ "$EASYRSA_DEBUG" ] && print \
				"### write PRESERVE existing: $write_file"
		fi
	elif [ "$write_file" ]; then
			verbose ": write_legacy_file_v2 - over-write DISABLED"
			create_legacy_stream "$write_type" > "$write_file" || \
				die "write failed"
			[ "$EASYRSA_DEBUG" ] && print \
				"### write NEWFILE: $write_type to $write_file"
	else
		# write stream to stdout ONLY
		create_legacy_stream "$write_type"
	fi

	write_recursion="$(( write_recursion - 1 ))"
} # => write_legacy_file_v2()

# set heredoc variables for openssl-easyrsa.cnf
# shellcheck disable=SC2016 # (info): $ don't expand in ''
set_openssl_easyrsa_cnf_vars(){
	case "$1" in
	expanded)
		# fully expand ssl-cnf for safe-cnf
		conf_EASYRSA_dir="$EASYRSA_PKI"
		conf_EASYRSA_PKI="$EASYRSA_PKI"
		conf_EASYRSA_DIGEST="$EASYRSA_DIGEST"
		conf_EASYRSA_KEY_SIZE="$EASYRSA_KEY_SIZE"
		conf_EASYRSA_DN="$EASYRSA_DN"
		conf_EASYRSA_REQ_CN="$EASYRSA_REQ_CN"
		conf_EASYRSA_REQ_COUNTRY="$EASYRSA_REQ_COUNTRY"
		conf_EASYRSA_REQ_PROVINCE="$EASYRSA_REQ_PROVINCE"
		conf_EASYRSA_REQ_CITY="$EASYRSA_REQ_CITY"
		conf_EASYRSA_REQ_ORG="$EASYRSA_REQ_ORG"
		conf_EASYRSA_REQ_OU="$EASYRSA_REQ_OU"
		conf_EASYRSA_REQ_EMAIL="$EASYRSA_REQ_EMAIL"
		conf_EASYRSA_REQ_SERIAL="$EASYRSA_REQ_SERIAL"
		;;
	unexpanded)
		# write standard ssl-cnf
		conf_EASYRSA_dir='$dir'
		conf_EASYRSA_PKI='$ENV::EASYRSA_PKI'
		conf_EASYRSA_DIGEST='$ENV::EASYRSA_DIGEST'
		conf_EASYRSA_KEY_SIZE='$ENV::EASYRSA_KEY_SIZE'
		conf_EASYRSA_DN='$ENV::EASYRSA_DN'
		conf_EASYRSA_REQ_CN='$ENV::EASYRSA_REQ_CN'
		conf_EASYRSA_REQ_COUNTRY='$ENV::EASYRSA_REQ_COUNTRY'
		conf_EASYRSA_REQ_PROVINCE='$ENV::EASYRSA_REQ_PROVINCE'
		conf_EASYRSA_REQ_CITY='$ENV::EASYRSA_REQ_CITY'
		conf_EASYRSA_REQ_ORG='$ENV::EASYRSA_REQ_ORG'
		conf_EASYRSA_REQ_OU='$ENV::EASYRSA_REQ_OU'
		conf_EASYRSA_REQ_EMAIL='$ENV::EASYRSA_REQ_EMAIL'
		conf_EASYRSA_REQ_SERIAL='$ENV::EASYRSA_REQ_SERIAL'
		;;
	*)
		die "set_openssl_easyrsa_cnf_vars - input"
	esac
} # => set_openssl_easyrsa_cnf_vars()

# Create x509 type
create_legacy_stream() {
	case "$1" in
	COMMON)
	# COMMON is not very useful
		cat <<- "CREATE_X509_TYPE_COMMON"
		CREATE_X509_TYPE_COMMON
		;;
	easyrsa)
	# This could be COMMON but not is not suitable for a CA
		cat <<- "CREATE_X509_TYPE_EASYRSA"
		basicConstraints = CA:FALSE
		subjectKeyIdentifier = hash
		authorityKeyIdentifier = keyid,issuer:always
		keyUsage = digitalSignature,keyEncipherment
		CREATE_X509_TYPE_EASYRSA
		;;
	serverClient)
	# serverClient
		create_legacy_stream easyrsa
		cat <<- "CREATE_X509_TYPE_SERV_CLI"
		extendedKeyUsage = serverAuth,clientAuth
		CREATE_X509_TYPE_SERV_CLI
		;;
	server)
	# server
		create_legacy_stream easyrsa
		cat <<- "CREATE_X509_TYPE_SERV"
		extendedKeyUsage = serverAuth
		CREATE_X509_TYPE_SERV
		;;
	client)
	# client
		create_legacy_stream easyrsa
		cat <<- "CREATE_X509_TYPE_CLI"
		extendedKeyUsage = clientAuth
		CREATE_X509_TYPE_CLI
		;;
	ca)
	# ca
		cat <<- "CREATE_X509_TYPE_CA"
		basicConstraints = CA:TRUE
		subjectKeyIdentifier = hash
		authorityKeyIdentifier = keyid:always,issuer:always
		keyUsage = cRLSign, keyCertSign
		CREATE_X509_TYPE_CA
		;;
	selfsign)
	# selfsign
		cat <<- "CREATE_X509_TYPE_SELFSIGN"
		subjectKeyIdentifier = hash
		authorityKeyIdentifier = keyid:always,issuer:always
		basicConstraints = CA:TRUE
		keyUsage = digitalSignature,keyEncipherment
		CREATE_X509_TYPE_SELFSIGN

		print "extendedKeyUsage = $selfsign_eku"
		;;
	codeSigning)
	# codeSigning
		cat <<- "CREATE_X509_CODE_SIGNING"
		basicConstraints = CA:FALSE
		subjectKeyIdentifier = hash
		authorityKeyIdentifier = keyid,issuer:always
		extendedKeyUsage = codeSigning
		keyUsage = digitalSignature
		CREATE_X509_CODE_SIGNING
		;;
	email)
	# email
		cat <<- "CREATE_X509_TYPE_EMAIL"
		basicConstraints = CA:FALSE
		subjectKeyIdentifier = hash
		authorityKeyIdentifier = keyid,issuer:always
		extendedKeyUsage = emailProtection
		keyUsage = digitalSignature,keyEncipherment,nonRepudiation
		CREATE_X509_TYPE_EMAIL
		;;
	kdc)
	# kdc
		cat <<- "CREATE_X509_TYPE_KDC"
basicConstraints = CA:FALSE
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
extendedKeyUsage = 1.3.6.1.5.2.3.5
keyUsage = nonRepudiation,digitalSignature,keyEncipherment,keyAgreement
issuerAltName = issuer:copy
subjectAltName = otherName:1.3.6.1.5.2.2;SEQUENCE:kdc_princ_name

[kdc_princ_name]
realm = EXP:0,GeneralString:${ENV::EASYRSA_KDC_REALM}
principal_name = EXP:1,SEQUENCE:kdc_principal_seq

[kdc_principal_seq]
name_type = EXP:0,INTEGER:1
name_string = EXP:1,SEQUENCE:kdc_principals

[kdc_principals]
princ1 = GeneralString:krbtgt
princ2 = GeneralString:${ENV::EASYRSA_KDC_REALM}
CREATE_X509_TYPE_KDC
		;;
	vars)
	# vars
		cat << "CREATE_VARS_EXAMPLE"
# Easy-RSA 3 parameter settings

# NOTE: If you installed Easy-RSA from your package manager, do not edit
# this file in place -- instead, you should copy the entire easy-rsa directory
# to another location so future upgrades do not wipe out your changes.

# HOW TO USE THIS FILE
#
# vars.example contains built-in examples to Easy-RSA settings. You MUST name
# this file "vars" if you want it to be used as a configuration file. If you
# do not, it WILL NOT be automatically read when you call easyrsa commands.
#
# It is not necessary to use this config file unless you wish to change
# operational defaults. These defaults should be fine for many uses without
# the need to copy and edit the "vars" file.
#
# All of the editable settings are shown commented and start with the command
# "set_var" -- this means any set_var command that is uncommented has been
# modified by the user. If you are happy with a default, there is no need to
# define the value to its default.

# NOTES FOR WINDOWS USERS
#
# Paths for Windows  *MUST* use forward slashes, or optionally double-escaped
# backslashes (single forward slashes are recommended.) This means your path
# to the openssl binary might look like this:
# "C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# A little housekeeping: DO NOT EDIT THIS SECTION
#
# Easy-RSA 3.x does not source into the environment directly.
# Complain if a user tries to do this:
if [ -z "$EASYRSA_CALLER" ]; then
	echo "You appear to be sourcing an Easy-RSA *vars* file. This is" >&2
	echo "no longer necessary and is disallowed. See the section called" >&2
	echo "*How to use this file* near the top comments for more details." >&2
	return 1
fi

# DO YOUR EDITS BELOW THIS POINT

# If your OpenSSL command is not in the system PATH, you will need to define
# the path here. Normally this means a full path to the executable, otherwise
# you could have left it undefined here and the shown default would be used.
#
# Windows users, remember to use paths with forward-slashes (or escaped
# back-slashes.) Windows users should declare the full path to the openssl
# binary here if it is not in their system PATH.
#
#set_var EASYRSA_OPENSSL	"openssl"
#
# This sample is in Windows syntax -- edit it for your path if not using PATH:
#set_var EASYRSA_OPENSSL	"C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# Windows users, to generate OpenVPN TLS Keys the Openvpn binary must be
# defined here.
#
#set_var EASYRSA_OPENVPN "C:\\Program Files\\Openvpn\\bin\\openvpn.exe"

# Define X509 DN mode.
#
# This is used to adjust which elements are included in the Subject field
# as the DN ("Distinguished Name"). Note that in 'cn_only' mode the
# Organizational fields, listed further below, are not used.
#
# Choices are:
#   cn_only  - Use just a commonName value.
#   org      - Use the "traditional" format:
#              Country/Province/City/Org/Org.Unit/email/commonName
#
#set_var EASYRSA_DN	"cn_only"

# Organizational fields (used with "org" mode and ignored in "cn_only" mode).
# These are the default values for fields which will be placed in the
# certificate.  Do not leave any of these fields blank, although interactively
# you may omit any specific field by typing the "." symbol (not valid for
# email).
#
# NOTE: The following characters are not supported
#       in these "Organizational fields" by Easy-RSA:
#       back-tick (`)
#
#set_var EASYRSA_REQ_COUNTRY	"US"
#set_var EASYRSA_REQ_PROVINCE	"California"
#set_var EASYRSA_REQ_CITY	"San Francisco"
#set_var EASYRSA_REQ_ORG	"Copyleft Certificate Co"
#set_var EASYRSA_REQ_EMAIL	"me@example.net"
#set_var EASYRSA_REQ_OU		"My Organizational Unit"

# Preserve the Distinguished Name field order
# of the certificate signing request
# *Only* effective in --dn-mode=org
#
#set_var EASYRSA_PRESERVE_DN	1

# Set no password mode - This will create the entire PKI without passwords.
# This can be better managed by choosing which entity private keys should be
# encrypted with the following command line options:
# Global option '--no-pass' or command option 'nopass'.
#
#set_var EASYRSA_NO_PASS	1

# Choose a size in bits for your keypairs. The recommended value is 2048.
# Using 2048-bit keys is considered more than sufficient for many years into
# the future. Larger keysizes will slow down TLS negotiation and make key/DH
# param generation take much longer. Values up to 4096 should be accepted by
# most software. Only used when the crypto alg is rsa, see below.
#
#set_var EASYRSA_KEY_SIZE	2048

# The default crypto mode is rsa; ec can enable elliptic curve support.
# Note that not all software supports ECC, so use care when enabling it.
# Choices for crypto alg are: (each in lower-case)
#  * rsa
#  * ec
#  * ed
#
#set_var EASYRSA_ALGO		rsa

# Define the named curve, used in ec & ed modes:
#
#set_var EASYRSA_CURVE		secp384r1

# In how many days should the root CA key expire?
#
#set_var EASYRSA_CA_EXPIRE	3650

# In how many days should certificates expire?
#
#set_var EASYRSA_CERT_EXPIRE	825

# How many days until the Certificate Revokation List will expire.
#
# IMPORTANT: When the CRL expires, an OpenVPN Server which uses a
# CRL will reject ALL new connections, until the CRL is replaced.
#
#set_var EASYRSA_CRL_DAYS	180

# Random serial numbers by default.
# Set to 'no' for the old incremental serial numbers.
#
#set_var EASYRSA_RAND_SN	"yes"

# Cut-off window for checking expiring certificates.
#
#set_var EASYRSA_PRE_EXPIRY_WINDOW	90

# Generate automatic subjectAltName for certificates
#
#set_var	EASYRSA_AUTO_SAN	1

# Add critical attribute to X509 fields: basicConstraints (BC),
# keyUsage (KU), extendedKeyUsage (EKU) or SAN
#
#set_var	EASYRSA_BC_CRIT		1
#set_var	EASYRSA_KU_CRIT		1
#set_var	EASYRSA_EKU_CRIT	1
#set_var	EASYRSA_SAN_CRIT	1

# Disable automatic inline files
#
#set_var	EASYRSA_DISABLE_INLINE	1
CREATE_VARS_EXAMPLE
		;;
	ssl-cnf|safe-cnf)
	# SSL config v3.2.0-1
	cat << CREATE_SSL_CONFIG
# For use with Easy-RSA 3.0+ and OpenSSL or LibreSSL

####################################################################
[ ca ]
default_ca	= CA_default		# The default ca section

####################################################################
[ CA_default ]

dir		= $conf_EASYRSA_PKI	# Where everything is kept
certs		= $conf_EASYRSA_dir			# Where the issued certs are kept
crl_dir		= $conf_EASYRSA_dir			# Where the issued crl are kept
database	= $conf_EASYRSA_dir/index.txt	# database index file.
new_certs_dir	= $conf_EASYRSA_dir/certs_by_serial	# default place for new certs.

certificate	= $conf_EASYRSA_dir/ca.crt		# The CA certificate
serial		= $conf_EASYRSA_dir/serial		# The current serial number
crl		= $conf_EASYRSA_dir/crl.pem		# The current CRL
private_key	= $conf_EASYRSA_dir/private/ca.key	# The private key
RANDFILE	= $conf_EASYRSA_dir/.rand		# private random number file

x509_extensions	= basic_exts		# The extensions to add to the cert

# A placeholder to handle the --copy-ext feature:
#%COPY_EXTS%	# Do NOT remove or change this line as --copy-ext support requires it

# This allows a V2 CRL. Ancient browsers don't like it, but anything Easy-RSA
# is designed for will. In return, we get the Issuer attached to CRLs.
crl_extensions	= crl_ext

# These fields are always configured via the command line.
# These fields are removed from this here-doc but retained
# in 'openssl-easyrsa.cnf' file, in case something breaks.
# default_days is no longer required by Easy-RSA
#default_days	= \$ENV::EASYRSA_CERT_EXPIRE	# how long to certify for
# default_crl_days is no longer required by Easy-RSA
#default_crl_days	= \$ENV::EASYRSA_CRL_DAYS	# how long before next CRL

default_md	= $conf_EASYRSA_DIGEST		# use public key default MD
preserve	= no			# keep passed DN ordering

# This allows to renew certificates which have not been revoked
unique_subject	= no

# A few different ways of specifying how similar the request should look
# For type CA, the listed attributes must be the same, and the optional
# and supplied fields are just that :-)
policy		= policy_anything

# For the 'anything' policy, which defines allowed DN fields
[ policy_anything ]
countryName		= optional
stateOrProvinceName	= optional
localityName		= optional
organizationName	= optional
organizationalUnitName	= optional
commonName		= supplied
emailAddress		= optional
serialNumber	= optional

####################################################################
# Easy-RSA request handling
# We key off \$DN_MODE to determine how to format the DN
[ req ]
default_bits		= $conf_EASYRSA_KEY_SIZE
default_keyfile	= privkey.pem
default_md		= $conf_EASYRSA_DIGEST
distinguished_name	= $conf_EASYRSA_DN
x509_extensions		= easyrsa_ca	# The extensions to add to the self signed cert

# A placeholder to handle the \$EXTRA_EXTS feature:
#%EXTRA_EXTS%	# Do NOT remove or change this line as \$EXTRA_EXTS support requires it

####################################################################
# Easy-RSA DN (Subject) handling

# Easy-RSA DN for cn_only support:
[ cn_only ]
commonName		= Common Name (eg: your user, host, or server name)
commonName_max		= 64
commonName_default	= $conf_EASYRSA_REQ_CN

# Easy-RSA DN for org support:
[ org ]
countryName			= Country Name (2 letter code)
countryName_default		= $conf_EASYRSA_REQ_COUNTRY
countryName_min			= 2
countryName_max			= 2

stateOrProvinceName		= State or Province Name (full name)
stateOrProvinceName_default	= $conf_EASYRSA_REQ_PROVINCE

localityName			= Locality Name (eg, city)
localityName_default		= $conf_EASYRSA_REQ_CITY

0.organizationName		= Organization Name (eg, company)
0.organizationName_default	= $conf_EASYRSA_REQ_ORG

organizationalUnitName		= Organizational Unit Name (eg, section)
organizationalUnitName_default	= $conf_EASYRSA_REQ_OU

commonName			= Common Name (eg: your user, host, or server name)
commonName_max			= 64
commonName_default		= $conf_EASYRSA_REQ_CN

emailAddress			= Email Address
emailAddress_default		= $conf_EASYRSA_REQ_EMAIL
emailAddress_max		= 64

serialNumber		= Serial-number (eg, device serial-number)
serialNumber_default	= $conf_EASYRSA_REQ_SERIAL

####################################################################
# Easy-RSA cert extension handling

# This section is effectively unused as the main script sets extensions
# dynamically. This core section is left to support the odd usecase where
# a user calls openssl directly.
[ basic_exts ]
basicConstraints	= CA:FALSE
subjectKeyIdentifier	= hash
authorityKeyIdentifier	= keyid,issuer:always

# The Easy-RSA CA extensions
[ easyrsa_ca ]

# PKIX recommendations:

subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always,issuer:always

# This could be marked critical, but it's nice to support reading by any
# broken clients who attempt to do so.
basicConstraints = CA:true

# Limit key usage to CA tasks. If you really want to use the generated pair as
# a self-signed cert, comment this out.
keyUsage = cRLSign, keyCertSign

# nsCertType omitted by default. Let's try to let the deprecated stuff die.
# nsCertType = sslCA

# A placeholder to handle the \$X509_TYPES and CA extra extensions \$EXTRA_EXTS:
#%CA_X509_TYPES_EXTRA_EXTS%	# Do NOT remove or change this line as \$X509_TYPES and EXTRA_EXTS demands it

# CRL extensions.
[ crl_ext ]

# Only issuerAltName and authorityKeyIdentifier make any sense in a CRL.

# issuerAltName=issuer:copy
authorityKeyIdentifier=keyid:always,issuer:always
CREATE_SSL_CONFIG
		;;
	*)
		die "create_legacy_stream: unknown type '$1'"
	esac
} # => create_legacy_stream()

# Version information
print_version() {
	ssl_version="$(
			"${EASYRSA_OPENSSL:-openssl}" version 2>/dev/null
		)"
		cat << VERSION_TEXT
EasyRSA Version Information
Version:     $EASYRSA_version
Generated:   ~DATE~
SSL Lib:     ${ssl_version:-undefined}
Git Commit:  ~GITHEAD~
Source Repo: https://github.com/OpenVPN/easy-rsa
VERSION_TEXT
} # => print_version()


########################################
# Invocation entry point:

EASYRSA_version="~VER~"
NL='
'

# Be secure with a restrictive umask
[ "$EASYRSA_NO_UMASK" ] || umask "${EASYRSA_UMASK:=077}"

# Register cleanup on EXIT
trap 'cleanup $?' EXIT
# When SIGHUP, SIGINT, SIGQUIT, SIGABRT and SIGTERM,
# explicitly exit to signal EXIT (non-bash shells)
trap "exit 1" 1
trap "exit 2" 2
trap "exit 3" 3
trap "exit 6" 6
trap "exit 15" 15

# Get host details - No configurable input allowed
detect_host

# Initialisation requirements
unset -v \
	OPENSSL_CONF \
	verify_ssl_lib_ok ssl_batch \
	secured_session \
	working_safe_ssl_conf working_safe_org_conf \
	alias_days text \
	prohibit_no_pass \
	invalid_vars \
	local_request error_build_full_cleanup \
	selfsign_eku \
	internal_batch mv_temp_error \
	easyrsa_exit_with_error error_info \
	write_recursion tools_error tools_error_txt

	# Used by build-ca->cleanup to restore prompt
	# after user interrupt when using manual password
	prompt_restore=0
	# Sequential temp-file counter
	mktemp_counter=0

# Parse options
while :; do
	# Reset per pass flags
	unset -v opt val \
		is_empty empty_ok number_only zero_allowed

	# Separate option from value:
	opt="${1%%=*}"
	val="${1#*=}"

	# Empty values are not allowed unless expected
	# eg: '--batch'
	[ "$opt" = "$val" ] && is_empty=1
	# eg: '--pki-dir='
	[ "$val" ] || is_empty=1

	case "$opt" in
		--days)
			number_only=1
			zero_allowed=1
			# Set the appropriate date variable
			# when called by command later
			alias_days="$val"
			;;
		--startdate)
			export EASYRSA_START_DATE="$val"
			;;
		--enddate)
			export EASYRSA_END_DATE="$val"
			;;
		--pki-dir|--pki)
			export EASYRSA_PKI="$val"
			;;
		--tmp-dir)
			export EASYRSA_TEMP_DIR="$val"
			;;
		--ssl-cnf|--ssl-conf)
			export EASYRSA_SSL_CONF="$val"
			;;
		--keep-tmp)
			export EASYRSA_KEEP_TEMP="$val"
			;;
		--use-algo)
			export EASYRSA_ALGO="$val"
			;;
		--keysize)
			number_only=1
			export EASYRSA_KEY_SIZE="$val"
			;;
		--curve)
			export EASYRSA_CURVE="$val"
			;;
		--dn-mode)
			export EASYRSA_DN="$val"
			;;
		--req-cn)
			export EASYRSA_REQ_CN="$val"
			;;
		--digest)
			export EASYRSA_DIGEST="$val"
			;;
		--req-c)
			empty_ok=1
			export EASYRSA_REQ_COUNTRY="$val"
			;;
		--req-st)
			empty_ok=1
			export EASYRSA_REQ_PROVINCE="$val"
			;;
		--req-city)
			empty_ok=1
			export EASYRSA_REQ_CITY="$val"
			;;
		--req-org)
			empty_ok=1
			export EASYRSA_REQ_ORG="$val"
			;;
		--req-email)
			empty_ok=1
			export EASYRSA_REQ_EMAIL="$val"
			;;
		--req-ou)
			empty_ok=1
			export EASYRSA_REQ_OU="$val"
			;;
		--req-serial)
			empty_ok=1
			export EASYRSA_REQ_SERIAL="$val"
			;;
		--ns-cert)
			empty_ok=1
			[ "$is_empty" ] && unset -v val
			export EASYRSA_NS_SUPPORT="${val:-yes}"
			;;
		--ns-comment)
			empty_ok=1
			export EASYRSA_NS_COMMENT="$val"
			;;
		--batch)
			empty_ok=1
			export EASYRSA_BATCH=1
			;;
		-s|--silent)
			empty_ok=1
			export EASYRSA_SILENT=1
			;;
		--sbatch|--silent-batch)
			empty_ok=1
			export EASYRSA_SILENT=1
			export EASYRSA_BATCH=1
			;;
		--verbose)
			empty_ok=1
			export EASYRSA_VERBOSE=1
			;;
		--days-margin)
			# ONLY ALLOWED use by status reports
			number_only=1
			export EASYRSA_iso_8601_MARGIN="$val"
			;;
		-S|--silent-ssl)
			empty_ok=1
			export EASYRSA_SILENT_SSL=1
			;;
		--force-safe-ssl)
			empty_ok=1
			export EASYRSA_FORCE_SAFE_SSL=1
			;;
		--nopass|--no-pass)
			empty_ok=1
			export EASYRSA_NO_PASS=1
			;;
		--passin)
			export EASYRSA_PASSIN="$val"
			;;
		--passout)
			export EASYRSA_PASSOUT="$val"
			;;
		--raw-ca)
			empty_ok=1
			export EASYRSA_RAW_CA=1
			;;
		--notext|--no-text)
			empty_ok=1
			export EASYRSA_NO_TEXT=1
			;;
		--subca-len)
			number_only=1
			zero_allowed=1
			export EASYRSA_SUBCA_LEN="$val"
			;;
		--vars)
			export EASYRSA_VARS_FILE="$val"
			;;
		--copy-ext)
			empty_ok=1
			export EASYRSA_CP_EXT=1
			;;
		--subject-alt-name|--san)
			# This allows --san to be used multiple times
			if [ "$EASYRSA_SAN" ]; then
				EASYRSA_SAN="$EASYRSA_SAN, $val"
			else
				EASYRSA_SAN="$val"
			fi
			;;
		--auto-san)
			empty_ok=1
			export EASYRSA_AUTO_SAN=1
			;;
		--san-crit*)
			empty_ok=1
			export EASYRSA_SAN_CRIT='critical,'
			;;
		--bc-crit*)
			empty_ok=1
			export EASYRSA_BC_CRIT=1
			;;
		--ku-crit*)
			empty_ok=1
			export EASYRSA_KU_CRIT=1
			;;
		--eku-crit*)
			empty_ok=1
			export EASYRSA_EKU_CRIT=1
			;;
		--new-subj*)
			export EASYRSA_NEW_SUBJECT="$val"
			;;
		--usefn)
			export EASYRSA_P12_FR_NAME="$val"
			;;
		--tools)
			export EASYRSA_TOOLS_LIB="$val"
			;;
		--version)
			shift "$#"
			set -- "$@" "version"
			break
			;;
		-h|--help|--usage)
			shift "$#"
			set -- "$@" "help"
			break
			;;
		-*)
			user_error "\
Unknown option '$opt'.
Run 'easyrsa help options' for option help."
			;;
		*)
			break
	esac

	# fatal error when no value was provided
	if [ "$is_empty" ]; then
		[ "$empty_ok" ] || \
			user_error "Missing value to option: $opt"
	fi

	# fatal error when a number is expected but not provided
	if [ "$number_only" ]; then
		case "$val" in
			(0)
				# Allow zero only
				[ "$zero_allowed" ] || \
					user_error "$opt - Number expected: '$val'"
				;;
			(*[!1234567890]*|0*)
				user_error "$opt - Number expected: '$val'"
		esac
	fi

	shift
done

# option dependencies
# Add full --san to extra extensions
if [ "$EASYRSA_SAN" ]; then
	EASYRSA_EXTRA_EXTS="\
$EASYRSA_EXTRA_EXTS
subjectAltName = ${EASYRSA_SAN_CRIT}${EASYRSA_SAN}"
fi

# Set cmd now
# vars_setup needs to know if this is init-pki
cmd="$1"
[ "$1" ] && shift # scrape off command

# Establish PKI and CA initialisation requirements
unset -v require_pki require_ca quiet_vars

case "$cmd" in
	''|help|version|show-host|rand|random)
		unset -v EASYRSA_SILENT
		quiet_vars=1
		;;
	init-pki|clean-all)
		: # ok
		;;
	*)
		require_pki=1
		case "$cmd" in
			gen-req|gen-dh|build-ca|show-req|export-p*| \
			inline|self-sign-*|write)
				: ;; # ok
			*) require_ca=1
		esac
esac

# Intelligent env-var detection and auto-loading:
# Select vars file as EASYRSA_VARS_FILE
# then source the vars file, if found
# otherwise, ignore no vars file
if select_vars; then
	[ "$quiet_vars" ] || information "\
Using Easy-RSA 'vars' configuration:
* $EASYRSA_VARS_FILE"
	source_vars "$EASYRSA_VARS_FILE"
else
	verbose "\
No Easy-RSA 'vars' configuration file exists!"
fi

# then set defaults
default_vars

# Check for unexpected changes to EASYRSA or EASYRSA_PKI
# https://github.com/OpenVPN/easy-rsa/issues/1006
validate_default_vars

# Check for conflicting input options
mutual_exclusions

# Verify SSL Lib - One time ONLY
verify_ssl_lib

# Hand off to the function responsible
# ONLY verify_working_env() for valid commands
case "$cmd" in
	init-pki|clean-all)
		verify_working_env
		init_pki "$@"
		;;
	build-ca)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CA_EXPIRE="$alias_days"
		build_ca "$@"
		;;
	self-sign-server)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		self_sign server "$@"
		;;
	self-sign-client)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		self_sign client "$@"
		;;
	self*)
		user_error "Self-sign syntax example: 'self-sign-server foo'"
		;;
	gen-dh)
		verify_working_env
		gen_dh
		;;
	gen-req)
		verify_working_env
		gen_req "$@"
		;;
	sign|sign-req)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		sign_req "$@"
		;;
	build-client-full)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		build_full client "$@"
		;;
	build-server-full)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		build_full server "$@"
		;;
	build-serverClient-full)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		build_full serverClient "$@"
		;;
	gen-crl)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CRL_DAYS="$alias_days"
		gen_crl
		;;
	revoke|revoke-issued)
		verify_working_env
		revoke 'issued' "$@"
		;;
	revoke-expired)
		verify_working_env
		revoke 'expired' "$@"
		;;
	revoke-renewed)
		verify_working_env
		revoke 'renewed/issued' "$@"
		;;
	import-req)
		verify_working_env
		import_req "$@"
		;;
	expire)
		verify_working_env
		expire_cert "$@"
		;;
	inline)
		verify_working_env
		inline_file "$@"
		;;
	export-p12)
		verify_working_env
		export_pkcs p12 "$@"
		;;
	export-p7)
		verify_working_env
		export_pkcs p7 "$@"
		;;
	export-p8)
		verify_working_env
		export_pkcs p8 "$@"
		;;
	export-p1)
		verify_working_env
		export_pkcs p1 "$@"
		;;
	set-pass|set-rsa-pass|set-ec-pass|set-ed-pass)
		verify_working_env
		set_pass "$@"
		;;
	update-db)
		verify_working_env
		update_db
		;;
	show-req)
		verify_working_env
		show req "$@"
		;;
	show-cert)
		verify_working_env
		show cert "$@"
		;;
	show-crl)
		verify_working_env
		show crl crl
		;;
	show-ca)
		verify_working_env
		show_ca "$@"
		;;
	show-host)
		verify_working_env
		show_host "$@"
		;;
	renew-ca)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CA_EXPIRE="$alias_days"
		renew_ca_cert "$@"
		;;
	renew)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_CERT_EXPIRE="$alias_days"
		renew "$@"
		;;
	show-expire)
		verify_working_env
		[ -z "$alias_days" ] || \
			export EASYRSA_PRE_EXPIRY_WINDOW="$alias_days"
		status expire "$@"
		;;
	show-revoke)
		verify_working_env
		status revoke "$@"
		;;
	show-renew)
		verify_working_env
		status renew "$@"
		;;
	verify-cert)
		verify_working_env
		# Called with --batch, this will return error
		# when the certificate fails verification.
		# Therefore, on error, exit with error.
		verify_cert "$@" || easyrsa_exit_with_error=1
		;;
	gen-tls-auth|gen-tls-auth-*)
		verify_working_env
		tls_key_gen tls-auth "$@"
		;;
	gen-tls-crypt|gen-tls-crypt-*)
		verify_working_env
		tls_key_gen tls-crypt "$@"
		;;
	gen-tls-cryptv2|gen-tls-cryptv2-*)
		verify_working_env
		tls_key_gen tls-crypt-v2 "$@"
		;;
	write)
		verify_working_env

		# Write legacy files to write_dir
		# or EASYRSA_PKI or EASYRSA
		case "$1" in
		legacy)
			# over-write NO
			shift
			legacy_file_over_write=
			all_legacy_files_v2 "$@"
			;;
		legacy-hard)
			# over-write YES
			shift
			legacy_file_over_write=overwrite
			all_legacy_files_v2 "$@"
			;;
		*)
			write_legacy_file_v2 "$@"
		esac
		;;
	serial|check-serial)
		verify_working_env
		# Called with --batch, this will return error
		# when the serial number is not unique.
		# Therefore, on error, exit with error.
		check_serial_unique "$@" || \
			easyrsa_exit_with_error=1
		;;
	display-dn)
		verify_working_env
		display_dn "$@"
		;;
	x509-eku|show-eku)
		verify_working_env
		ssl_cert_x509v3_eku "$@" || \
			easyrsa_exit_with_error=1
		;;
	rand|random)
		easyrsa_random "$1"
		;;
	""|help|-h|--help|--usage)
		verify_working_env
		cmd_help "$1"
		;;
	version)
		print_version
		;;
	*)
		user_error "\
Unknown command '$cmd'. Run without commands for usage help."
esac

# Check for untrapped errors
# shellcheck disable=SC2181 # Quote expand - pre-cleanup $?
if [ $? = 0 ]; then
	# Do 'cleanup ok' on successful completion
	cleanup ok
fi

# Otherwise, exit with error
print "Untrapped error detected!"
cleanup

# vim: ft=sh nu ai sw=8 ts=8 noet

================
File: servidor/easy-rsa/easyrsa3/openssl-easyrsa.cnf
================
# For use with Easy-RSA 3.0+ and OpenSSL or LibreSSL

####################################################################
[ ca ]
default_ca	= CA_default		# The default ca section

####################################################################
[ CA_default ]

dir		= $ENV::EASYRSA_PKI	# Where everything is kept
certs		= $dir			# Where the issued certs are kept
crl_dir		= $dir			# Where the issued crl are kept
database	= $dir/index.txt	# database index file.
new_certs_dir	= $dir/certs_by_serial	# default place for new certs.

certificate	= $dir/ca.crt		# The CA certificate
serial		= $dir/serial		# The current serial number
crl		= $dir/crl.pem		# The current CRL
private_key	= $dir/private/ca.key	# The private key
RANDFILE	= $dir/.rand		# private random number file

x509_extensions	= basic_exts		# The extensions to add to the cert

# A placeholder to handle the --copy-ext feature:
#%COPY_EXTS%	# Do NOT remove or change this line as --copy-ext support requires it

# This allows a V2 CRL. Ancient browsers don't like it, but anything Easy-RSA
# is designed for will. In return, we get the Issuer attached to CRLs.
crl_extensions	= crl_ext

default_days	= $ENV::EASYRSA_CERT_EXPIRE	# how long to certify for
default_crl_days	= $ENV::EASYRSA_CRL_DAYS	# how long before next CRL
default_md	= $ENV::EASYRSA_DIGEST		# use public key default MD

# Note: preserve=no|yes, does nothing for EasyRSA.
# Use sign-req command option 'preserve' instead.
preserve	= no			# keep passed DN ordering

# This allows to renew certificates which have not been revoked
unique_subject	= no

# A few different ways of specifying how similar the request should look
# For type CA, the listed attributes must be the same, and the optional
# and supplied fields are just that :-)
policy		= policy_anything

# For the 'anything' policy, which defines allowed DN fields
[ policy_anything ]
countryName		= optional
stateOrProvinceName	= optional
localityName		= optional
organizationName	= optional
organizationalUnitName	= optional
commonName		= supplied
emailAddress		= optional
serialNumber	= optional

####################################################################
# Easy-RSA request handling
# We key off $DN_MODE to determine how to format the DN
[ req ]
default_bits		= $ENV::EASYRSA_KEY_SIZE
default_keyfile	= privkey.pem
default_md		= $ENV::EASYRSA_DIGEST
distinguished_name	= $ENV::EASYRSA_DN
x509_extensions		= easyrsa_ca	# The extensions to add to the self signed cert

# A placeholder to handle the $EXTRA_EXTS feature:
#%EXTRA_EXTS%	# Do NOT remove or change this line as $EXTRA_EXTS support requires it

####################################################################
# Easy-RSA DN (Subject) handling

# Easy-RSA DN for cn_only support:
[ cn_only ]
commonName		= Common Name (eg: your user, host, or server name)
commonName_max		= 64
commonName_default	= $ENV::EASYRSA_REQ_CN

# Easy-RSA DN for org support:
[ org ]
countryName			= Country Name (2 letter code)
countryName_default		= $ENV::EASYRSA_REQ_COUNTRY
countryName_min			= 2
countryName_max			= 2

stateOrProvinceName		= State or Province Name (full name)
stateOrProvinceName_default	= $ENV::EASYRSA_REQ_PROVINCE

localityName			= Locality Name (eg, city)
localityName_default		= $ENV::EASYRSA_REQ_CITY

0.organizationName		= Organization Name (eg, company)
0.organizationName_default	= $ENV::EASYRSA_REQ_ORG

organizationalUnitName		= Organizational Unit Name (eg, section)
organizationalUnitName_default	= $ENV::EASYRSA_REQ_OU

commonName			= Common Name (eg: your user, host, or server name)
commonName_max			= 64
commonName_default		= $ENV::EASYRSA_REQ_CN

emailAddress			= Email Address
emailAddress_default		= $ENV::EASYRSA_REQ_EMAIL
emailAddress_max		= 64

serialNumber		= Serial-number (eg, device serial-number)
serialNumber_default	= $ENV::EASYRSA_REQ_SERIAL

####################################################################
# Easy-RSA cert extension handling

# This section is effectively unused as the main script sets extensions
# dynamically. This core section is left to support the odd usecase where
# a user calls openssl directly.
[ basic_exts ]
basicConstraints	= CA:FALSE
subjectKeyIdentifier	= hash
authorityKeyIdentifier	= keyid,issuer:always

# The Easy-RSA CA extensions
[ easyrsa_ca ]

# PKIX recommendations:

subjectKeyIdentifier=hash
authorityKeyIdentifier=keyid:always,issuer:always

# This could be marked critical, but it's nice to support reading by any
# broken clients who attempt to do so.
basicConstraints = CA:true

# Limit key usage to CA tasks. If you really want to use the generated pair as
# a self-signed cert, comment this out.
keyUsage = cRLSign, keyCertSign

# nsCertType omitted by default. Let's try to let the deprecated stuff die.
# nsCertType = sslCA

# A placeholder to handle the $X509_TYPES and CA extra extensions $EXTRA_EXTS:
#%CA_X509_TYPES_EXTRA_EXTS%	# Do NOT remove or change this line as $X509_TYPES and EXTRA_EXTS demands it

# CRL extensions.
[ crl_ext ]

# Only issuerAltName and authorityKeyIdentifier make any sense in a CRL.

# issuerAltName=issuer:copy
authorityKeyIdentifier=keyid:always,issuer:always

================
File: servidor/easy-rsa/easyrsa3/vars.example
================
# Easy-RSA 3 parameter settings

# NOTE: If you installed Easy-RSA from your package manager, do not edit
# this file in place -- instead, you should copy the entire easy-rsa directory
# to another location so future upgrades do not wipe out your changes.

# HOW TO USE THIS FILE
#
# vars.example contains built-in examples to Easy-RSA settings. You MUST name
# this file "vars" if you want it to be used as a configuration file. If you
# do not, it WILL NOT be automatically read when you call easyrsa commands.
#
# It is not necessary to use this config file unless you wish to change
# operational defaults. These defaults should be fine for many uses without
# the need to copy and edit the "vars" file.
#
# All of the editable settings are shown commented and start with the command
# "set_var" -- this means any set_var command that is uncommented has been
# modified by the user. If you are happy with a default, there is no need to
# define the value to its default.

# NOTES FOR WINDOWS USERS
#
# Paths for Windows  *MUST* use forward slashes, or optionally double-escaped
# backslashes (single forward slashes are recommended.) This means your path
# to the openssl binary might look like this:
# "C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# A little housekeeping: DO NOT EDIT THIS SECTION
#
# Easy-RSA 3.x does not source into the environment directly.
# Complain if a user tries to do this:
if [ -z "$EASYRSA_CALLER" ]; then
	echo "You appear to be sourcing an Easy-RSA *vars* file. This is" >&2
	echo "no longer necessary and is disallowed. See the section called" >&2
	echo "*How to use this file* near the top comments for more details." >&2
	return 1
fi

# DO YOUR EDITS BELOW THIS POINT

# This variable is used as the base location of configuration files needed by
# easyrsa.  More specific variables for specific files (eg: EASYRSA_SSL_CONF)
# may override this default.
#
# The default value of this variable is the location of the easyrsa script
# itself, which is also where the configuration files are located in the
# easy-rsa tree.
#
#set_var EASYRSA	"${0%/*}"

# If your OpenSSL command is not in the system PATH, you will need to define
# the path here. Normally this means a full path to the executable, otherwise
# you could have left it undefined here and the shown default would be used.
#
# Windows users, remember to use paths with forward-slashes (or escaped
# back-slashes.) Windows users should declare the full path to the openssl
# binary here if it is not in their system PATH.
#
#set_var EASYRSA_OPENSSL	"openssl"
#
# This sample is in Windows syntax -- edit it for your path if not using PATH:
#set_var EASYRSA_OPENSSL	"C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# Define X509 DN mode.
#
# This is used to adjust which elements are included in the Subject field
# as the DN ("Distinguished Name"). Note that in 'cn_only' mode the
# Organizational fields, listed further below, are not used.
#
# Choices are:
#   cn_only  - Use just a commonName value.
#   org      - Use the "traditional" format:
#              Country/Province/City/Org/Org.Unit/email/commonName
#
#set_var EASYRSA_DN	"cn_only"

# Organizational fields (used with "org" mode and ignored in "cn_only" mode).
# These are the default values for fields which will be placed in the
# certificate.  Do not leave any of these fields blank, although interactively
# you may omit any specific field by typing the "." symbol (not valid for
# email).
#
# NOTE: The following characters are not supported
#       in these "Organizational fields" by Easy-RSA:
#       back-tick (`)
#
#set_var EASYRSA_REQ_COUNTRY	"US"
#set_var EASYRSA_REQ_PROVINCE	"California"
#set_var EASYRSA_REQ_CITY	"San Francisco"
#set_var EASYRSA_REQ_ORG	"Copyleft Certificate Co"
#set_var EASYRSA_REQ_EMAIL	"me@example.net"
#set_var EASYRSA_REQ_OU		"My Organizational Unit"

# Preserve the Distinguished Name field order
# of the certificate signing request
# *Only* effective in --dn-mode=org
#
#set_var EASYRSA_PRESERVE_DN	1

# Set no password mode - This will create the entire PKI without passwords.
# This can be better managed by choosing which entity private keys should be
# encrypted with the following command line options:
# Global option '--no-pass' or command option 'nopass'.
#
#set_var EASYRSA_NO_PASS	1

# Choose a size in bits for your keypairs. The recommended value is 2048.
# Using 2048-bit keys is considered more than sufficient for many years into
# the future. Larger keysizes will slow down TLS negotiation and make key/DH
# param generation take much longer. Values up to 4096 should be accepted by
# most software. Only used when the crypto alg is rsa, see below.
#
#set_var EASYRSA_KEY_SIZE	2048

# The default crypto mode is rsa; ec can enable elliptic curve support.
# Note that not all software supports ECC, so use care when enabling it.
# Choices for crypto alg are: (each in lower-case)
#  * rsa
#  * ec
#  * ed
#
#set_var EASYRSA_ALGO		rsa

# Define the named curve, used in ec & ed modes:
#
#set_var EASYRSA_CURVE		secp384r1

# In how many days should the root CA key expire?
#
#set_var EASYRSA_CA_EXPIRE	3650

# In how many days should certificates expire?
#
#set_var EASYRSA_CERT_EXPIRE	825

# How many days until the Certificate Revokation List will expire.
#
# IMPORTANT: When the CRL expires, an OpenVPN Server which uses a
# CRL will reject ALL new connections, until the CRL is replaced.
#
#set_var EASYRSA_CRL_DAYS	180

# Random serial numbers by default.
# Set to 'no' for the old incremental serial numbers.
#
#set_var EASYRSA_RAND_SN	"yes"

# Cut-off window for checking expiring certificates.
#
#set_var EASYRSA_PRE_EXPIRY_WINDOW	90

# Generate automatic subjectAltName for certificates
#
#set_var	EASYRSA_AUTO_SAN	1

# Add critical attribute to X509 fields: basicConstraints (BC),
# keyUsage (KU), extendedKeyUsage (EKU) or SAN
#
#set_var	EASYRSA_BC_CRIT		1
#set_var	EASYRSA_KU_CRIT		1
#set_var	EASYRSA_EKU_CRIT	1
#set_var	EASYRSA_SAN_CRIT	1

# Disable automatic inline files
#
#set_var	EASYRSA_DISABLE_INLINE	1

# Support deprecated "Netscape" extensions? (choices "yes" or "no").
# The default is "no", to discourage use of deprecated extensions.
# If you require this feature to use with --ns-cert-type, set this to "yes".
# This support should be replaced with the more modern --remote-cert-tls
# feature.  If you do not use --ns-cert-type in your configs, it is safe,
# and recommended, to leave this defined to "no".
# When set to "yes", server-signed certs get the nsCertType=server attribute
# and also get any NS_COMMENT defined below in the nsComment field.
#
#set_var EASYRSA_NS_SUPPORT	"no"

# When NS_SUPPORT is set to "yes", this field is added as the nsComment field.
# Set this blank to omit it. With NS_SUPPORT set to "no" this field is ignored.
#
#set_var EASYRSA_NS_COMMENT	"Easy-RSA Generated Certificate"

# !!
# NOTE: ADVANCED OPTIONS BELOW THIS POINT
# PLAY WITH THEM AT YOUR OWN RISK
# !!

# Broken shell command aliases: If you have a largely broken shell that is
# missing any of these POSIX-required commands used by Easy-RSA, you will need
# to define an alias to the proper path for the command.  The symptom will be
# some form of a "command not found" error from your shell. This means your
# shell is BROKEN, but you can hack around it here if you really need. These
# shown values are not defaults: it is up to you to know what you are doing if
# you touch these.
#
#alias awk="/alt/bin/awk"
#alias cat="/alt/bin/cat"

# X509 extensions directory:
# If you want to customize the X509 extensions used, set the directory to look
# for extensions here. Each cert type you sign must have a matching filename,
# and an optional file named "COMMON" is included first when present. Note that
# when undefined here, default behaviour is to look in $EASYRSA_PKI first, then
# fallback to $EASYRSA for the "x509-types" dir.  You may override this
# detection with an explicit dir here.
#
#set_var EASYRSA_EXT_DIR	"$EASYRSA/x509-types"

# Non-functional
# If you want to generate KDC certificates, you need to set the realm here.
#
#set_var EASYRSA_KDC_REALM      "CHANGEME.EXAMPLE.COM"

# OpenSSL config file:
# If you need to use a specific openssl config file, you can reference it here.
# Normally this file is auto-detected from a file named openssl-easyrsa.cnf
# from the EASYRSA_PKI or EASYRSA dir, in that order. NOTE that this file is
# Easy-RSA specific and you cannot just use a standard config file, so this is
# an advanced feature.
#
#set_var EASYRSA_SSL_CONF	"$EASYRSA_PKI/openssl-easyrsa.cnf"

# Cryptographic digest to use.
# Do not change this default unless you understand the security implications.
# Valid choices include: md5, sha1, sha256, sha224, sha384, sha512
#
#set_var EASYRSA_DIGEST		"sha256"

# Batch mode. Leave this disabled unless you intend to call Easy-RSA explicitly
# in batch mode without any user input, confirmation on dangerous operations,
# or most output. Setting this to any non-blank string enables batch mode.
#
#set_var EASYRSA_BATCH		""

================
File: servidor/easy-rsa/Licensing/gpl-2.0.txt
================
GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

================
File: servidor/easy-rsa/pki/reqs/mqtt.example.tld.req
================
-----BEGIN CERTIFICATE REQUEST-----
MIICYDCCAUgCAQAwGzEZMBcGA1UEAwwQbXF0dC5leGFtcGxlLnRsZDCCASIwDQYJ
KoZIhvcNAQEBBQADggEPADCCAQoCggEBAKeBc0HOb2RS6mjElmuXljHhhg8wJjL3
CslHU3DsPtiW+ZktLo20swIFDkBjaURPjsYGb+Nls0uuFLM7vzYySF20B6+3EWsE
wgmLj2TRQu/R13AIjscjVc4//2ukvo0XbCTojwYvDH9D0YXo5VQtUdWoo1pV0k0r
BDMPVJOK1A5bG3DI26TZzUoXEhp3h2TbU7PCtydmhApI5bvYYPbFMsMfhhadCSBu
ey1P0ynA8DbVhIHqWbKnuIINV0kKCvcxuAJR5pQgN2J135PiEOyPo/KgRMcYKTTa
kaT2XAMHeFnjBf5Ybj3kQQfMKHzYkGvabuciG7rZjxM7WovCDLlQYlcCAwEAAaAA
MA0GCSqGSIb3DQEBCwUAA4IBAQAkVW00PaXwFyA5O0+TEM1ZwNrD4df9wMieOqEU
mEqrP/l76ZloZ/3KIfLZCHR4t7+DdSv8oTxR8dF1tCSYHJSONQe4hQ13SW0rBSe5
veUCPy2YrWPNE99Mi9I+RjV9hJFumE3S5b7znq9wV+pocDfmMMWjy+C+9bVU4ZGt
QP3cKnRj8oGM/Z5LEjhECYgb+oY5qBIFkz9vsOo2MloJzdSh8NLmKkxfzCUiBeND
cmW/au8SxiNBzrffWwHGipMZL40J4lg0tK/vpEtfDn25/bH44EhHtYxv7WG4OOq+
bB9rEKYbms+MWscHN8trz6p9QfDTqIJklkFpNM0vDQJmUMLu
-----END CERTIFICATE REQUEST-----

================
File: servidor/easy-rsa/pki/vars.example
================
# Easy-RSA 3 parameter settings

# NOTE: If you installed Easy-RSA from your package manager, do not edit
# this file in place -- instead, you should copy the entire easy-rsa directory
# to another location so future upgrades do not wipe out your changes.

# HOW TO USE THIS FILE
#
# vars.example contains built-in examples to Easy-RSA settings. You MUST name
# this file "vars" if you want it to be used as a configuration file. If you
# do not, it WILL NOT be automatically read when you call easyrsa commands.
#
# It is not necessary to use this config file unless you wish to change
# operational defaults. These defaults should be fine for many uses without
# the need to copy and edit the "vars" file.
#
# All of the editable settings are shown commented and start with the command
# "set_var" -- this means any set_var command that is uncommented has been
# modified by the user. If you are happy with a default, there is no need to
# define the value to its default.

# NOTES FOR WINDOWS USERS
#
# Paths for Windows  *MUST* use forward slashes, or optionally double-escaped
# backslashes (single forward slashes are recommended.) This means your path
# to the openssl binary might look like this:
# "C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# A little housekeeping: DO NOT EDIT THIS SECTION
#
# Easy-RSA 3.x does not source into the environment directly.
# Complain if a user tries to do this:
if [ -z "$EASYRSA_CALLER" ]; then
	echo "You appear to be sourcing an Easy-RSA *vars* file. This is" >&2
	echo "no longer necessary and is disallowed. See the section called" >&2
	echo "*How to use this file* near the top comments for more details." >&2
	return 1
fi

# DO YOUR EDITS BELOW THIS POINT

# If your OpenSSL command is not in the system PATH, you will need to define
# the path here. Normally this means a full path to the executable, otherwise
# you could have left it undefined here and the shown default would be used.
#
# Windows users, remember to use paths with forward-slashes (or escaped
# back-slashes.) Windows users should declare the full path to the openssl
# binary here if it is not in their system PATH.
#
#set_var EASYRSA_OPENSSL	"openssl"
#
# This sample is in Windows syntax -- edit it for your path if not using PATH:
#set_var EASYRSA_OPENSSL	"C:/Program Files/OpenSSL-Win32/bin/openssl.exe"

# Windows users, to generate OpenVPN TLS Keys the Openvpn binary must be
# defined here.
#
#set_var EASYRSA_OPENVPN "C:\\Program Files\\Openvpn\\bin\\openvpn.exe"

# Define X509 DN mode.
#
# This is used to adjust which elements are included in the Subject field
# as the DN ("Distinguished Name"). Note that in 'cn_only' mode the
# Organizational fields, listed further below, are not used.
#
# Choices are:
#   cn_only  - Use just a commonName value.
#   org      - Use the "traditional" format:
#              Country/Province/City/Org/Org.Unit/email/commonName
#
#set_var EASYRSA_DN	"cn_only"

# Organizational fields (used with "org" mode and ignored in "cn_only" mode).
# These are the default values for fields which will be placed in the
# certificate.  Do not leave any of these fields blank, although interactively
# you may omit any specific field by typing the "." symbol (not valid for
# email).
#
# NOTE: The following characters are not supported
#       in these "Organizational fields" by Easy-RSA:
#       back-tick (`)
#
#set_var EASYRSA_REQ_COUNTRY	"US"
#set_var EASYRSA_REQ_PROVINCE	"California"
#set_var EASYRSA_REQ_CITY	"San Francisco"
#set_var EASYRSA_REQ_ORG	"Copyleft Certificate Co"
#set_var EASYRSA_REQ_EMAIL	"me@example.net"
#set_var EASYRSA_REQ_OU		"My Organizational Unit"

# Preserve the Distinguished Name field order
# of the certificate signing request
# *Only* effective in --dn-mode=org
#
#set_var EASYRSA_PRESERVE_DN	1

# Set no password mode - This will create the entire PKI without passwords.
# This can be better managed by choosing which entity private keys should be
# encrypted with the following command line options:
# Global option '--no-pass' or command option 'nopass'.
#
#set_var EASYRSA_NO_PASS	1

# Choose a size in bits for your keypairs. The recommended value is 2048.
# Using 2048-bit keys is considered more than sufficient for many years into
# the future. Larger keysizes will slow down TLS negotiation and make key/DH
# param generation take much longer. Values up to 4096 should be accepted by
# most software. Only used when the crypto alg is rsa, see below.
#
#set_var EASYRSA_KEY_SIZE	2048

# The default crypto mode is rsa; ec can enable elliptic curve support.
# Note that not all software supports ECC, so use care when enabling it.
# Choices for crypto alg are: (each in lower-case)
#  * rsa
#  * ec
#  * ed
#
#set_var EASYRSA_ALGO		rsa

# Define the named curve, used in ec & ed modes:
#
#set_var EASYRSA_CURVE		secp384r1

# In how many days should the root CA key expire?
#
#set_var EASYRSA_CA_EXPIRE	3650

# In how many days should certificates expire?
#
#set_var EASYRSA_CERT_EXPIRE	825

# How many days until the Certificate Revokation List will expire.
#
# IMPORTANT: When the CRL expires, an OpenVPN Server which uses a
# CRL will reject ALL new connections, until the CRL is replaced.
#
#set_var EASYRSA_CRL_DAYS	180

# Random serial numbers by default.
# Set to 'no' for the old incremental serial numbers.
#
#set_var EASYRSA_RAND_SN	"yes"

# Cut-off window for checking expiring certificates.
#
#set_var EASYRSA_PRE_EXPIRY_WINDOW	90

# Generate automatic subjectAltName for certificates
#
#set_var	EASYRSA_AUTO_SAN	1

# Add critical attribute to X509 fields: basicConstraints (BC),
# keyUsage (KU), extendedKeyUsage (EKU) or SAN
#
#set_var	EASYRSA_BC_CRIT		1
#set_var	EASYRSA_KU_CRIT		1
#set_var	EASYRSA_EKU_CRIT	1
#set_var	EASYRSA_SAN_CRIT	1

# Disable automatic inline files
#
#set_var	EASYRSA_DISABLE_INLINE	1

================
File: servidor/easy-rsa/release-keys/README.md
================
Easy-RSA 3 release GPG keys
===

This document contains the GPG Key IDs used to sign official releases starting
with the 3.x series. These release-keys are available on public keyserver
mirrors, such as pgp.mit.edu.

Current keys
---

These keys are currently valid:

* Key ID [0x9D7367F3](https://keys.openpgp.org/vks/v1/by-fingerprint/6F4056821152F03B6B24F2FCF8489F839D7367F3)
  * Owner: Eric Crist <ecrist@secure-computing.net>
  * Key fingerprint: 6F40 5682 1152 F03B 6B24  F2FC F848 9F83 9D73 67F3

Former keys
---

These keys were once valid but are now expired or revoked:

* Key ID 0x606FD463
  * Owner: Josh Cepek <josh.cepek@usa.net>
  * Key fingerprint: 65FF 3F24 AA08 E882 CB44  4C94 D731 D97A 606F D463
  * Member is no longer active with EasyRSA.

Verifying Signatures
===
You can verify the signatures provided by downloading the public key for the current key (above) and adding it to your keychain. Then you can verify with the following command:
```
ecrist@marvin:~/Downloads-> gpg --verify EasyRSA-3.0.8.tgz.sig EasyRSA-3.0.8.tgz
gpg: Signature made Wed Sep  9 16:00:35 2020 CDT
gpg:                using RSA key C8FCA3E7F787072CDEB91D2F72964219390D0D0E
gpg: Good signature from "Eric F Crist <ecrist@secure-computing.net>"
```

================
File: servidor/easy-rsa/.gitignore
================
easyrsa3/pki
easyrsa3/vars
easyrsa3/safessl-easyrsa.cnf
easyrsa3/unit?tests
easyrsa-unit-tests.sh
easyrsa-unit-tests-help.sh
dist-staging
.DS_Store
test-deps/*
shellcheck

================
File: servidor/easy-rsa/ChangeLog
================
Easy-RSA 3 ChangeLog

3.3.0 (TBD)

   * Update OpenSSL to 3.4.0 (d020b66)

3.2.2 (2025-02-01)

   * Fold easyrsa-tools.lib into easyrsa (56cfa0c) (#1288)
   * Revert da3c249: Do not remove index.txt.attr (a236b97) (#1287)
   * Windows: Remove mktemp binary and text files (135f642) (#1285)
   * op-test.sh: Disable download ossl3 and shellcheck binaries (473c43b) (#1284)
   * Forbid self-signed certificate from being expired/renewed/revoked (ab45ae7) (#1274)
   * Rename global option --ssl-conf (DEPRECATED) to --ssl-cnf (c788423) (#1270)
   * bugfix: Save and Restore $EASYRSA_SSL_CONF for compound commands (7cdb14d) (#1270)
   * bugfix: Always use locate_support_files() after secure_session() (d530bc3) (#1270)
   * bugfix: easyrsa-tools.lib: renew, write full metadata to temp-file (b47d2af) (#1267)
   * Introduce new command 'revoke-issued' (38bf2d8) (#1266)
     Commands 'revoke' and 'revoke-issued' are identical.
     Command 'revoke' can ONLY be used in batch mode.
   * vars.example: Remove $EASYRSA_PKI (8ee8dcf) (#1262)
     There is no effect on existing 'vars' files.
   * easyrsa-tools.lib: Move to 'easyrsa3' directory (d30b688) (#1259)
     This now includes 'easyrsa-tools.lib' in the distribution tarballs.
   * Upgrade easyrsa-tools.lib to version 322 - As of command 'renew-ca'
   * easyrsa-tools.lib: Introduce new command 'renew-ca' (ba32b0d) (#1255)
   * easyrsa-tools.lib: show-expire, allow --days to be zero (a1033a5) (#1254)
   * Command 'help': Ignore EASYRSA_SILENT (8804d6b) (#1249)
   * bugfix: easyrsa-tools.lib: renew SAN, remove excess word 'Address' (af17492) (#1251)
   * New global variable 'EASYRSA_DISABLE_INLINE' (ad257ab) (#1245)
   * bugfix: revoke, renew: Remove pki/inline/private/$file.inline (febef85) (#1244)
     Initial bug report #1242 (Minor)
     Stop removing old credentials file pki/$file.creds (a871e9c)
   * Add LibreSSL version 4 to supported SSL Libraries (7df616b) (#1240)
   * sign-req: Allow custom X509 Types (2ee08cc) (#1238)
   * Remove redundant file index.txt.attr (da3c249) (#1233)

3.2.1 (2024-09-13)

   * inline: Add decimal value for cert. serial (Linux Only) (b33038e) (#1222)
   * Always exit with error for unknown command options (Except nopass) (#1221)
     (build-ca: b2f7912); (gen-req: 07f21d3); (build_full(): 0ff7f4c);
     (export_pkcs(): 2c51288); (set-pass: 1266d4e)
   * Integrate Easy-RSA TLS-Key for use with 'init-pki soft' (03d9dc2) (#1220)
     Note: Inline files that contain private key data are now created in sub-dir
     'pki/inline/private'.
   * easyrsa-tools.lib, show-expire: Add CA certificate to report (a36cd54) (#1215)
   * inline: OpenVPN TLS Keys inlining for TLS-AUTH, TLS-CRYPT-V1 (6e9e4a2) (#1185)
     Note: Command inline only writes directly to inline file not stdout.
   * easyrsa-tools.lib: OpenVPN TLS Key gen. TLS-AUTH, TLS-CRYPT-V1 (cf0da16) (#1185)
   * easyrsa-tools.lib: expire_status_v2() (show-expire version 2) (1e43bf5) (#1214)
   * sign-req: Require 128bit serial number (806ee19) (#1213)
   * Move command 'verify-cert' to Tools-lib; drop 'verify' shortcut (ddbf304) (#1209)
   * Windows secure_session(): Ensure $secured_session dir is created (d99b242) (#1203)
   * Switch to '-f' for file existence (6ab98c9..a02f545) (#1201)
   * inline: Move auto-inline from build_full() to sign_req() (823f70f) (#1201)
   * gen-crl: Create additional CRL in DER format (69df0d8) (#1198)
   * self-sign: Allow Edwards Curve based keys (81b749b) (#1197)
   * Re-enable command 'renew' (version 2): Requires EasyRSA Tools (30fe311) (#1195)
   * bug-fix: revoke: Pass the correct certificate location (24d5514)
   * vars.example: Add flags for auto-SAN and X509 critical attribute (a41dfcc)
   * Global option --eku-crit: Mark X509 extendedKeyUsage as critical (ca09211)
   * sign-req: Add critical and pathlen details to confirmation (deae705) (#1182)
   * export-p12: Automatically generate inline file (9d90370) (#1181)
   * Introduce global option --auto-san, use commonName as SAN (5c36d44) (#1180)
   * Introduce global option --san-crit, mark SAN critical (dd69f50) (#1179)
   * Introduce new global options: --ku-crit and --bc-crit (b79abee) (#1176)
   * gen-req: Always check for existing request file (7eab98e) (#1177)
   * revoke/revoke-expired/-renewed: Keep duplicate certificate (3da7f66) (#1177)
   * revoke-expired/-renewed: Keep req/key files for resigning (4537ae7) (#1177)
   * revoke: Add abbreviations for optional 'reason' (a88ccc7) (#1173)
   * build-ca: Allow use of --req-cn without batch mode (b77a0fb) (#1170)
   * gen-req: Re-enable use of --req-cn (5cf8c46) (#1170)
   * write: Change syntax, target as file, not directory (722ce54) (#1165)

3.2.0 (2024-05-18)

   * Revert ca76697: Restore escape_hazard() (b1e9d7a) (#1137)
   * New X509 Type: 'selfsign' Internal only (999533e) (#1135)
   * New commands: self-sign-server and self-sign-client (9f8a1d1) (#1127)
   * build-ca: Command 'req', remove SSL option '-keyout' (4e02c8a) (#1123)
   * Remove escape_hazard(), obsolete (ca76697)
   * Remove command and function display_cn(), unused (be8f400) (#1114)
   * Introduce Options to edit Request Subject during command 'sign-req'
     Global Option: --new-subject -- Command 'sign-req' option: 'newsubj'
     First proposed in: (#439) -- Completed: (83b81c7) (#1111)
   * docs: Update EasyRSA-Renew-and-Revoke.md (f6c2bf5) (#1109)
   * Remove all 'renew' code; replaced by 'expire' code (9d94207) (#1109)
   * Introduce commands: 'expire' and 'revoke-expired' (a1890fa) (#1109)
   * Keep request files [CSR] when revoking certificates (6d6e8d8) (#1109)
   * Restrict use of --req-cn to build-ca (0a46164) (#1098)
   * Remove command 'display-san' (Code removed in 5a06f94) (50e6002) (#1096)
   * help: Add 'copyext'; How to use --copy-ext and --san (5a06f94) (#1096)
   * Allow --san to be used multiple times (5a06f94) (#1096)
   * Remove default server subject alternative name (0b85a5d) (#576)
   * Move Status Reports to 'easyrsa-tools.lib' (214b909) (#1080)
   * export-p12, OpenSSL v1.x: Upgrade PBE and MAC options (60a508a)
     (#1084 - Based on #1081)
   * Windows: Introduce 'Non-Admin' mode (c2823c4) (#1073)
   * LibreSSL: Add fix for missing 'x509' option '-ext' (96dd959) (#1068)
   * Variable heredoc expansion for SSL/Safe Config file (9c5d423) (#1064)

   Branch-merge: v3.2.0-beta2 (#1055) 2024/01/13 Commit: d51d79b

   * Always use here-doc version of openssl-easyrsa.cnf (2a8c0de)
     Only use here-doc if the current version is recognised by sha256 hash.
     The current file is NEVER deleted (60216d5). Partially revert: 2a8c0de
   * export-p12: New command option 'legacy'. OpenSSL V3 Only (f8514de)
     Fallback to encryption algorithm RC2_CBC or 3DES_CBC
   * export-p12: Always set 'friendlyName' to file-name-base (da9e594)
   * Update OpenSSL to 3.2.0 (03e4829)

   Branch-merge: v3.2.0-beta1 (#1046) 2023/12/15 Commit: 7120876

   * Important note: As of Easy-RSA version 3.2.0-beta1, the configuration files
     `vars.example`, `openssl-easyrsa.cnf` and all files in `x509-types` directory
     are no longer required. Package maintainers can omit these files in the future.
     All files are created as required and deleted upon command completion.
     `vars.example` is created during `init-pki` and placed in the fresh PKI.
     These files will be retained for downstream packaging compatibility.

   * Rename X509-type file `code-signing` to `codeSigning` (1c6b31a)
     The original file will be retained as `code-signing`, however, the automatic
     X509-types creation will name the file `codeSigning`. This effectively means
     that both are valid X509-types, until `code-signing` is dropped.
   * init-pki: Always write vars.example file to fresh PKI (66a8f3e)
   * New command 'write': Write 'legacy' files to stdout or files (c814e0a)
   * Remove command 'make-safe-ssl': Replaced by command 'write safe-cnf' (c814e0a)
   * New Command 'rand': Expose easyrsa_random() to the command line (6131cbf)
   * Remove function 'set_pass_legacy()' (7470c2a)
   * Remove command 'rewind-renew' (72b4079)
   * Remove command 'rebuild' (d6953cc)
   * Remove command 'upgrade' (6a88edd)

   Branch-merge: v3.2.0-alpha2 (#1043) 2023/12/7 Commit: ed0dc46
   * Remove EASYRSA_NO_VARS; Allow graceful use without a vars file (3c0ca17)

   Branch-merge: v3.2.0-alpha1 (#1041) 2023/12/2 Commit: 42c2e95
   * New diagnostic command 'display-cn' (#1040)
   * Expand renewable certificate types to include code-signing (#1039)

3.1.7 (2023-10-13)
   * Rewrite vars-auto-detect, adhere to EasyRSA-Advanced.md (#1029)
     Under the hood, this is a considerable change but there are no user
     noticeable differences. With the exception of:
     Caveat: The default '$PWD/pki/vars' file is forbidden to change either
             EASYRSA or EASYRSA_PKI, which are both implied by default.
   * EasyRSA-Advanced.md: Correct vars-auto-detect hierarchy (#1029)
     Commit: ecd65065e3303da78811278a154ef7a969c2777b
             EASYRSA/vars is moved to a higher priority than a default PKI.
             vars-auto-detect no longer searches 'easyrsa' program directory.
   * gen-crl: preserve existing crl.pem ownership+mode (#1020)
   * New command: make-vars - Print vars.example (here-doc) to stdout (#1024)
   * show-expire: Calculate cert. expire seconds from DB date (#1023)
   * Update OpenSSL to 3.1.2

3.1.6 (2023-07-18)
   * New commands: 'inline' and 'x509-eku' (#993)
     inline: Build an inline file for a commonName
     x509-eku: Extract X509v3 extended key usage from a certificate
   * Expose serial-check, display-dn, display-san and default-san to
     command line. (#980) (Debugging functions, which remain undocumented)
   * Expand default status to include vars-file and CA status (#973)
   * sign-req: Allow the CSR DN-field order to be preserved (#970)

3.1.5 (2023-06-10)
   * Build Update: script now supports signing and verifying
   * Automate support-file creation (Free packaging) (#964)
   * build-ca: New command option 'raw-ca', abbreviation: 'raw' (#963)

     This 'raw' method, is the most reliable way to build a CA,
     with a password, without writing the CA password to a temp-file.

   This option completely replaces both methods below:

   * build-ca: New option --ca-via-stdin, use SSL -pass* argument 'stdin' (#959)
     Option '--ca-via-stdin' offers no more security than standard method.
     Easy-RSA version 3.1.4 ONLY.

   * build-ca: Replace password temp-files with file-descriptors (#955)
     Using file-descriptors does not work in Windows.
     Easy-RSA version 3.1.3 ONLY.

3.1.4 (2023-05-23)
   * build-ca: New option --ca-via-stdin, use SSL -pass* argument 'stdin' (#959)
   * build-ca: Revert manual CA password method to temp-files (#959)
     Supersedes #955

     Release v3.1.3 was fatally flawed, it would fail to build a CA under Windows.
     Release v3.1.4 is specifically a bugfix ONLY, to resolve the Windows problem.

     See the following commits for further details:
     5d7ad1306d5ebf1588aef77eb3445e70cf5b4ebc
         build-ca: Revert manual CA password method to temp-files
     c11135d19b2e7e7385d28abb1132978c849dfa74
         build-ca: Use OpenSSL password I/O argument 'stdin'
     27870d695a324e278854146afdac5d6bdade9bba
         build-ca: Replace password temp-file method with file-descriptors
         Superseded by 5d7ad13 above.

3.1.3 (2023-05-19)
   * build-ca: Replace password temp-files with file-descriptors (#955)
     Superseded by #959
   * Replace --fix-offset with --startdate, --enddate (#918)
   * Introduce option -S|--silent-ssl: Silence SSL output (#913)
   * Only create a random serial number file when expected (#896)
   * Always verify SSL lib, for all commands (#877)
   * Option --fix-offset: Adjust off-by-one day (#847) Superseded (#918)
   * Update OpenSSL to v3.0.8

3.1.2 (2023-01-13)
   * build-full: Always enable inline file creation (#834)
   * Make default Edwards curve ED25519 (#828)
   * Allow --fix-offset to create post-dated certificates (#804) Superseded (#918)
   * Introduce command 'set-pass' (#756)
   * Introduce global option '--nopass|--no-pass' (#752)
   * Introduce global option '--notext|--no-text' (#745)
   * Command 'help': For unknown command, exit with error (#737)
   * Find data-files in the correct order (#727 - Reported #725)
   * Update OpenSSL to 3.0.7 for Windows distribution

3.1.1 (2022-10-13)
   * Remove command 'renewable' (#715)
   * Expand 'show-renew', include 'renewed/certs_by_serial' (#700)
   * Resolve long-standing issue with --subca-len=N (#691)
   *  ++ NOTICE: Add EasyRSA-Renew-and-Revoke.md (#690)
   * Require 'openssl-easyrsa.cnf' is up to date (#695}
   * Introduce 'renew' (version 3). Only renew cert (#688)
   * Always ensure X509-types files exist (#581 #696)
   * Expand alias '--days' to all suitable options with a period (#674)
   * Introduce --keep-tmp, keep temp files for debugging (#667)
   * Add serialNumber (OID 2.5.4.5) to DN 'org' mode (#606)
   * Support ampersand and dollar-sign in vars file (#590)
   * Introduce 'rewind-renew' (#579)
   * Expand status reports to include checking a single cert (#577)
   * Introduce 'revoke-renewed' (#547)
   * update OpenSSL for Windows to 3.0.5

3.1.0 (2022-05-18)
   * Introduce basic support for OpenSSL version 3 (#492)
   * Update regex in grep to be POSIX compliant (#556)
   * Introduce status reporting tools (#555 & #557)
   * Display certificates using UTF8 (#551)
   * Allow certificates to be created with fixed date offset (#550)
   * Add 'verify' to verify certificate against CA (#549)
   * Add PKCS#12 alias 'friendlyName' (#544)
   * Support multiple IP-Addresses in SAN (#564)
   * Add option '--renew-days=NN', custom renew grace period (#557)
   * Add 'nopass' option to the 'export-pkcs' functions (#411)
   * Add support for 'busybox' (#543)
   * Add option '--tmp-dir=DIR' to declare Temp-dir (Commit f503a22)   

3.0.9 (2022-05-17)
   * Upgrade OpenSSL from 1.1.0j to 1.1.1o (#405, #407) 
      - We are building this ourselves now.
   * Fix --version so it uses EASYRSA_OPENSSL (#416)
   * Use openssl rand instead of non-POSIX mktemp (#478)
   * Fix paths with spaces (#443)
   * Correct OpenSSL version from Homebrew on macOs (#416)
   * Fix revoking a renewed certificate (Original PR #394)
     Follow-up commit: ef22701878bb10df567d60f2ac50dce52a82c9ee
   * Introduce 'show-crl' (d1993892178c5219f4a38d50db3b53d1a972b36c)
   * Support Windows-Git 'version of bash' (#533)
   * Disallow use of single quote (') in vars file, Warning (#530)
   * Creating a CA uses x509-types/ca and COMMON (#526)
   * Prefer 'PKI/vars' over all other locations (#528)
   * Introduce 'init-pki soft'  option (#197)
   * Warnings are no longer silenced by --batch (#523)
   * Improve packaging options (#510)
   * Update regex for POSIX compliance (#556)
   * Correct date format for Darwin/BSD (#559)

3.0.8 (2020-09-09)
   * Provide --version option (#372)
   * Version information now within generated certificates like on *nix
   * Fixed issue where gen-dh overwrote existing files without warning (#373)
   * Fixed issue with ED/EC certificates were still signed by RSA (#374)
   * Added support for export-p8 (#339)
   * Clarified error message (#384)
   * 2->3 upgrade now errors and prints message when vars isn't found (#377)

3.0.7 (2020-03-30)
   * Include OpenSSL libs and binary for Windows 1.1.0j
   * Remove RANDFILE environment variable (#261)
   * Workaround for bug in win32 mktemp (#247, #305, PR #312)
   * Handle IP address in SAN and renewals (#317)
   * Workaround for ash and no set -o echo (#319)
   * Shore up windows testing framework (#314)
   * Provide upgrade mechanism for older versions of EasyRSA (#349)
   * Add support for KDC certificates (#322)
   * Add support for Edward Curves (#354, #350)
   * Add support for EASYRSA_PASSIN and EASYRSA_PASSOUT env vars (#368)
   * Add support for RID to SAN (#362)

3.0.6 (2019-02-01)
   * Certificates that are revoked now move to a revoked subdirectory (#63)
   * EasyRSA no longer clobbers non-EASYRSA environment variables (#277)
   * More sane string checking, allowing for commas in CN (#267)
   * Support for reasonCode in CRL (#280)
   * Better handling for capturing passphrases (#230, others)
   * Improved LibreSSL/MacOS support
   * Adds support to renew certificates up to 30 days before expiration (#286)
     - This changes previous behavior allowing for certificate creation using
       duplicate CNs.

3.0.5 (2018-09-15)
   * Fix #17 & #58: use AES256 for CA key
   * Also, don't use read -s, use stty -echo
   * Fix broken "nopass" option
   * Add -r to read to stop errors reported by shellcheck (and to behave)
   * Remove overzealous quotes around $pkcs_opts (more SC errors)
   * Support for LibreSSL
   * EasyRSA version will be reported in certificate comments
   * Client certificates now expire in 3 year (1080 days) by default

3.0.4 (2018-01-21)
    * Remove use of egrep (#154)
    * Integrate with Travis-CI (#165)
    * Remove "local" from variable assignment (#165)
    * Other changes related to Travis-CI fixes
	* Assign values to variables defined previously w/local
    * Finally(?) fix the subjectAltName issues I presented earlier (really
      fixes #168)

3.0.3 (2017-08-22)
    * Include mktemp windows binary
    * copy CSR extensions into signed certificate


3.0.2 (2017-08-21)
    * Add missing windows binaries


3.0.1 (2015-10-25)
    * Correct some packaging errors


3.0.0 (2015-09-07)

    * cab4a07 Fix typo: Hellman
        (ljani: Github)

    * 171834d Fix typo: Default
        (allo-: Github)

    * 8b42eea Make aes256 default, replacing 3des
        (keros: Github)

    * f2f4ac8 Make -utf8 default
        (roubert: Github)


3.0.0-rc2 (2014/07/27)

    * 1551e5f docs: fix typo
        (Josh Cepek <josh.cepek@usa.net>)

    * 7ae44b3 Add KNOWN_ISSUES to stage next -rc release
        (Josh Cepek <josh.cepek@usa.net>)

    * a0d58b2 Update documentation
        (Josh Cepek <josh.cepek@usa.net>)

    * 5758825 Fix vars.example with proper path to extensions.temp
        (Josh Cepek <josh.cepek@usa.net>)

    * 89f369c Add support to change private key passphrases
        (Josh Cepek <josh.cepek@usa.net>)

    * 49d7c10 Improve docs: add Upgrade-Notes; add online support refs
        (Josh Cepek <josh.cepek@usa.net>)

    * fcc4547 Add build-dist packaging script; update Building docs
        (Josh Cepek <josh.cepek@usa.net>)

    * f74d08e docs: update Hacking.md with layout & git conventions
        (Josh Cepek <josh.cepek@usa.net>)

    * 0754f23 Offload temp file removal to a clean_temp() function
        (Josh Cepek <josh.cepek@usa.net>)

    * 1c90df9 Fix incorrect handling of invalid --use-algo option
        (Josh Cepek <josh.cepek@usa.net>)

    * c86289b Fix batch-mode handling with changes in e75ad75
        (Josh Cepek <josh.cepek@usa.net>)

    * e75ad75 refine how booleans are evaluated
        (Eric F Crist <ecrist@secure-computing.net>)

    * cc19823 Merge PKCS#7 feature from pull req #14
        (Author: Luiz Angelo Daros de Luca <luizluca@tre-sc.gov.br>)
        (Modified-By: Josh Cepek <josh.cepek@usa.net>)

    * 8b1fe01 Support OpenSSL-0.9.8 with the EXTRA_EXTS feature
        (Josh Cepek <josh.cepek@usa.net>)

    * d5516d5 Windows: make builds easier by using a matching dir structure
        (Josh Cepek <josh.cepek@usa.net>)

    * dc2e6dc Windows: improve external checks and env-var help
        (Josh Cepek <josh.cepek@usa.net>)

3.0.0-rc1 (2013/12/01)

    * The 3.x release is a nearly complete re-write of the 2.x codebase

    * Initial 3.x series code by Josh Cepek <josh.cepek@usa.net> -- continuing
    maintenance by the OpenVPN community development team and associated
    contributors

    * Add ECDSA (elliptic curve) support, thanks to Steffan Karger
    <steffan@karger.me>

================
File: servidor/easy-rsa/COPYING.md
================
Easy-RSA -- A Shell-based CA Utility
====================================

Copyright (C) 2013 by the Open-Source OpenVPN development community

Easy-RSA 3 license: GPLv2
-------------------------

All the Easy-RSA code contained in this project falls under a GPLv2 license with
full text available in the Licensing/ directory. Additional components used by
this project fall under additional licenses:

Additional licenses for external components
-------------------------------------------

The following components are under different licenses; while not part of the
Easy-RSA source code, these components are used by Easy-RSA or provided in
platform distributions as described below:

### OpenSSL

  OpenSSL is not linked by Easy-RSA, nor is it currently provided in any release
  package by Easy-RSA. However, Easy-RSA is tightly coupled with OpenSSL, so
  effective use of this code will require your acceptance and installation of
  OpenSSL.

### Additional Windows Components

  The Windows binary package includes mksh/Win32 and unxutils binary components,
  with full licensing details available in the distro/windows/Licensing/
  subdirectory of this project. mksh/Win32 is under a MirOS license (with some
  additional component licenses present there) and unxutils is under a GPLv2
  license.

================
File: servidor/easy-rsa/KNOWN_ISSUES
================
For a full list of issues, please visit the GitHub issue tracker at
https://github.com/OpenVPN/easy-rsa/issues

* EasyRSA tools, MKSH and mkdir.exe, *may* not work with Windows 11.
  Requires further investigation.

* OpenSSL 3.x does not appear to work on Windows 7.  Please use EasyRSA v3.0.9
  if you intend on using Windows 7.  Note that Windows 7 is no longer supported
  by Microsoft.

================
File: servidor/easy-rsa/op-test.sh
================
#!/bin/sh
#
# Downloads the run_unit_tests.sh file from easyrsa-unit-tests repo
# and executes that - allows for disconnected testing from the easy-rsa
# repo with TravisCI.

# log
log () {
	[ "$disable_log" ] && return
	if printf '%s\n' "* $*"; then
		return
	else
		echo "printf failed"
		exit 9
	fi
} # => log ()

# clean up
clean_up () {
	if [ "$no_delete" ]; then
		log "saved final state.."
	else
		log "op-test: clean_up"
		if [ "$EASYRSA_NIX" ]; then
			[ "$keep_eut" ] || rm -f "$utest_bin"
			[ "$keep_sc" ] || rm -f "$sc_bin"
			[ "$keep_ssl" ] || rm -f "$ssl_bin"
		fi
	fi
} # => clean_up ()

# curl download and openssl hash
# wing it ..
curl_it () {
	#log "BEGIN: curl_it"
	if [ "$#" -eq 2 ]; then
		file="$1"
		hash="$2"
	else
		log "> Usage: <file> <hash>"
		return 1
	fi

	if [ "$enable_curl" ]; then
		: # ok
	else
		log "> curl disabled"
		return 0
	fi

	# valid target
	case "$file" in
	easyrsa-unit-tests.sh|easyrsa-unit-tests-help.sh)
		unset -v require_hash
	;;
	shellcheck|openssl)
		require_hash=1
	;;
	*)
		log "> invalid target: $file"
		return 1
	esac

	# download
	if [ "$enable_curl" ]; then
		log "> download: ${gh_url}/${file}"
		curl -SO "${gh_url}/${file}" || \
			log "> download failed: ${file}"
	else
		log "> curl disabled"
	fi

	# hash download
	if [ "${require_hash}" ]; then
		if [ -e "${file}" ]; then
			log "> hash ${file}"
			temp_hash="$(openssl sha256 "${file}")"
			#log "temp_hash: $temp_hash"
			#log "hash     : $hash"
			if [ "$temp_hash" = "$hash" ]; then
				: # OK - hash is good
			else
				log "> hash failed: ${file}"
				return 1
			fi
		else
			log "> file missing: ${file}"
			return 1
		fi
	else
		if [ -e "${file}" ]; then
			: # ok - file is here
		else
			log "> file missing: ${file}"
			return 1
		fi
	fi
} # => curl_it ()

################################################################################

# RUN unit test
run_unit_test ()
{
	if [ "${utest_bin_ok}" ]; then

		# Start unit tests
		log ">>> BEGIN unit tests:"
		[ "$no_delete" ] && export SAVE_PKI=1

		if [ "${dry_run}" ]; then
			log "<<dry-run>> sh ${utest_bin} ${verb} $use_passwords"
			estat=1
		else
			log ">>>>>>: sh ${utest_bin} ${verb}"
			if sh "${utest_bin}" "${verb}" "$use_passwords"; then
				log "OK"
				estat=0
				if [ "$EASYRSA_BY_TINCANTECH" ]; then
					sh "${utest_help_bin}" "${help_verb}" "$use_passwords"
				fi
			else
				log "FAIL"
				estat=1
			fi
		fi
		log "<<< END unit tests:"
		unset SAVE_PKI
	else
		log "unit-test abandoned"
		estat=1
	fi
} # => run_unit_test ()

########################################

## DOWNLOAD unit-test
download_unit_test () {
	# if not present then download unit-test
	target_file="${utest_file}"
	target_hash="${utest_hash}"
	if [ "$enable_unit_test" ]; then
		if [ -e "${ERSA_UT}/${target_file}" ]; then
			[ -x "${ERSA_UT}/${target_file}" ] || \
				chmod +x "${ERSA_UT}/${target_file}"
			# version check
			if "${ERSA_UT}/${target_file}" version; then
				utest_bin="${ERSA_UT}/${target_file}"
				utest_bin_ok=1
				export ERSA_UTEST_CURL_TARGET=localhost
			else
				log "version check failed: ${ERSA_UT}/${target_file}"
			fi
		else
			# download and basic check
			log "curl_it ${target_file}"
			if curl_it "${target_file}" "${target_hash}"; then
				[ -x "${ERSA_UT}/${target_file}" ] || \
					chmod +x "${ERSA_UT}/${target_file}"
				# functional check - version check
				if "${ERSA_UT}/${target_file}" version; then
					utest_bin="${ERSA_UT}/${target_file}"
					utest_bin_ok=1
					export ERSA_UTEST_CURL_TARGET=online
					unset -v keep_eut
				else
					log "version check failed: ${target_file}"
				fi
			else
				log "curl_it ${target_file} - failed"
			fi
		fi
		[ "$utest_bin_ok" ] || log "undefined: utest_bin_ok"
		log "setup unit-test - ok"
	else
		log "unit-test disabled"
	fi # => shellcheck
}
## DOWNLOAD unit-test

## DOWNLOAD unit-test-help
download_unit_test_help () {
	# if not present then download unit-test-help
	target_file="${utest_help_file}"
	target_hash="${utest_hash}"
	if [ "$enable_unit_test" ]; then
		if [ -e "${ERSA_UT}/${target_file}" ]; then
			[ -x "${ERSA_UT}/${target_file}" ] || \
				chmod +x "${ERSA_UT}/${target_file}"
			# version check
			if "${ERSA_UT}/${target_file}" version; then
				utest_help_bin="${ERSA_UT}/${target_file}"
				utest_help_bin_ok=1
				export ERSA_UTEST_CURL_TARGET=localhost
			else
				log "version check failed: ${ERSA_UT}/${target_file}"
			fi
		else
			# download and basic check
			log "curl_it ${target_file}"
			if curl_it "${target_file}" "${target_hash}"; then
				[ -x "${ERSA_UT}/${target_file}" ] || \
					chmod +x "${ERSA_UT}/${target_file}"
				# functional check - version check
				if "${ERSA_UT}/${target_file}" version; then
					utest_help_bin="${ERSA_UT}/${target_file}"
					utest_help_bin_ok=1
					export ERSA_UTEST_CURL_TARGET=online
					unset -v keep_eut
				else
					log "version check failed: ${target_file}"
				fi
			else
				log "curl_it ${target_file} - failed"
			fi
		fi
		[ "$utest_help_bin_ok" ] || log "undefined: utest_help_bin_ok"
		log "setup unit-test-help - ok"
	else
		log "unit-test-help disabled"
	fi # => shellcheck
}
## DOWNLOAD unit-test-help

################################################################################

## USE shellcheck

# Run shellcheck
run_shellcheck () {
	sc_bin=shellcheck
	if [ "$enable_shellcheck" ] && [ "$EASYRSA_NIX" ]; then
		# shell-check easyrsa3/easyrsa
		if [ -e easyrsa3/easyrsa ]; then
			if "${sc_bin}" -s sh -S warning -x easyrsa3/easyrsa; then
				log "shellcheck easyrsa3/easyrsa completed - ok"
			else
				log "shellcheck easyrsa3/easyrsa completed - FAILED"
			fi
		else
			log "easyrsa binary not present, not using shellcheck"
		fi

		# shell-check dev/easyrsa-tools.lib
		if [ -e dev/easyrsa-tools.lib ]; then
			if "${sc_bin}" -s sh -S warning -x dev/easyrsa-tools.lib; then
				log "shellcheck dev/easyrsa-tools.lib completed - ok"
			else
				log "shellcheck dev/easyrsa-tools.lib completed - FAILED"
			fi
		else
			log "dev/easyrsa-tools.lib not present, not using shellcheck"
		fi

		# shell-check easyrsa-unit-tests.sh
		if [ -e easyrsa-unit-tests.sh ]; then
			if "${sc_bin}" -s sh -S warning -x easyrsa-unit-tests.sh; then
				log "shellcheck easyrsa-unit-tests.sh completed - ok"
			else
				log "shellcheck easyrsa-unit-tests.sh completed - FAILED"
			fi
		else
			log "easyrsa-unit-tests.sh binary not present, not using shellcheck"
		fi
	else
		log "shellcheck abandoned"
	fi
}
## USE shellcheck

########################################

## DOWNLOAD shellcheck
download_shellcheck () {
	# if not present then download shellcheck
	target_file="${sc_file}"
	target_hash="${sc_hash}"
	if [ "$enable_shellcheck" ] && [ "$EASYRSA_NIX" ]; then
		log "setup shellcheck"
		if [ -e "${ERSA_UT}/${target_file}" ]; then
			[ -x "${ERSA_UT}/${target_file}" ] || \
				chmod +x "${ERSA_UT}/${target_file}"
			"${ERSA_UT}/${target_file}" -V || \
				log "version check failed: ${ERSA_UT}/${target_file}"
			sc_bin="${ERSA_UT}/${target_file}"
			sc_bin_ok=1
			log "shellcheck enabled"
		else
			# download and basic check
			log "curl_it ${target_file}"
			if curl_it "${target_file}" "${target_hash}"; then
				log "curl_it ${target_file} - ok"
				[ -x "${ERSA_UT}/${target_file}" ] || \
					chmod +x "${ERSA_UT}/${target_file}"
				# functional check
				if "${ERSA_UT}/${target_file}" -V; then
					sc_bin="${ERSA_UT}/${target_file}"
					sc_bin_ok=1
					unset -v keep_sc
				else
					log "version check failed: ${ERSA_UT}/${target_file}"
				fi
				log "shellcheck enabled"
			else
				log "curl_it ${target_file} - failed"
			fi
		fi
	fi

	## DOWNLOAD shellcheck
}

################################################################################

## DOWNLOAD openssl-3
download_opensslv3 () {
	# if not present then download and then use openssl3
	target_file="${ssl_file}"
	target_hash="${ssl_hash}"
	if [ "$enable_openssl3" ] && [ "$EASYRSA_NIX" ]; then
		if [ -e "${ERSA_UT}/${target_file}" ]; then
			[ -x "${ERSA_UT}/${target_file}" ] || \
				chmod +x "${ERSA_UT}/${target_file}"
			# version check 'openssl version'
			"${ERSA_UT}/${target_file}" version || \
				log "version check failed: ${ERSA_UT}/${target_file}"
			ssl_bin="${ERSA_UT}/${target_file}"
			ssl_bin_ok=1
			# Set up Easy-RSA Unit-Test for OpenSSL-v3
			export EASYRSA_OPENSSL="${ssl_bin}"
		else
			# download and basic check
			log "curl_it ${target_file}"
			if curl_it "${target_file}" "${target_hash}"; then
				log "curl_it ${target_file} - ok"
				[ -x "${ERSA_UT}/${target_file}" ] || \
					chmod +x "${ERSA_UT}/${target_file}"
				# functional check - version check 'openssl version'
				if "${ERSA_UT}/${target_file}" version; then
					ssl_bin="${ERSA_UT}/${target_file}"
					ssl_bin_ok=1
					unset -v keep_ssl
					# Set up Easy-RSA Unit-Test for OpenSSL-v3
					export EASYRSA_OPENSSL="${ssl_bin}"
				else
					log "version check failed: ${ERSA_UT}/${target_file}"
				fi
			else
				log "curl_it ${target_file} - failed"
			fi
		fi

			log "OpenSSL-v3 enabled"

	else
		if [ "$EASYRSA_NIX" ]; then
			log "System SSL enabled"
			ssl_bin="openssl"
			ssl_bin_ok=1
		else
			log "Windows, no OpenSSL-v3"
			log "System SSL enabled"
			ssl_bin="openssl"
			ssl_bin_ok=1
		fi
	fi
} # => ## DOWNLOAD openssl-3

################################################################################

	# Register clean_up on EXIT
	#trap "exited 0" 0
	# When SIGHUP, SIGINT, SIGQUIT, SIGABRT and SIGTERM,
	# explicitly exit to signal EXIT (non-bash shells)
	trap "clean_up" 1
	trap "clean_up" 2
	trap "clean_up" 3
	trap "clean_up" 6
	trap "clean_up" 15


unset -v disable_log verb no_delete \
		enable_unit_test enable_shellcheck enable_openssl3

keep_sc=1
keep_ssl=1
keep_eut=1

# Set by default
enable_unit_test=1
enable_curl=1
EASYRSA_NIX=1

while [ -n "$1" ]; do
	case "$1" in
	--no-log)			disable_log=1 ;;
	'')					verb='-v' ;;
	-v)					verb='-v' ;;
	-vv)				verb='-vv' ;;
	-sc)				enable_shellcheck=1 ;;
	-o3)				: ;; # ignored
	-p)					use_passwords='-p' ;;
	-dr)				dry_run=1 ;;
	-nt|--no-test)		unset -v enable_unit_test ;;
	-nc|--no-curl)		unset -v enable_curl ;;
	-nd|--no-delete)	no_delete=1 ;;
	-w|--windows)		export EASYRSA_WIN=1; unset -v EASYRSA_NIX ;;
	*)
		log "Unknown option: $1"
		exit 9
	esac
	shift
done

log "Easy-RSA Unit Tests:"

# Layout
ERSA_UT="${PWD}"

# Sources
gh_url='https://raw.githubusercontent.com/OpenVPN/easyrsa-unit-tests/master'

utest_file='easyrsa-unit-tests.sh'
unset -v utest_bin utest_bin_ok
utest_hash='no-hash'

utest_help_file='easyrsa-unit-tests-help.sh'
unset -v utest_help_bin utest_help_bin_ok
#utest_hash='no-hash'
help_verb="-vv"

sc_file='shellcheck'
unset -v sc_bin sc_bin_ok
# v 0.8.0
#sc_hash='SHA256(shellcheck)= f4bce23c11c3919c1b20bcb0f206f6b44c44e26f2bc95f8aa708716095fa0651'

# v 0.9.0
sc_hash='SHA256(shellcheck)= 7087178d54de6652b404c306233264463cb9e7a9afeb259bb663cc4dbfd64149'

ssl_file='openssl'
unset -v ssl_bin ssl_bin_ok
# v 3.0.3
#ssl_hash='SHA256(openssl)= a0aed8b4aec1b72ca17c8a9ab04e10d829343a12cb5e7f8f6ae73e6f2ce026fd'

# v 3.0.5
#ssl_hash='SHA256(openssl)= 341d278423aeecbaa2b057b84b5501dd492c8f7e192c5bb9c66a260dbc022a4c'

# v 3.0.7
#ssl_hash='SHA256(openssl)= 606f8fb9d6ac7993c2f68efba8c4f022e128a8e9ab1a0921e4941d9f88a7bb5b'

# v 3.1.0
ssl_hash='SHA256(openssl)= 85b562891087d4c64868d8d1f0a381407d8e23fb66c37ce9baad55cf57edbc04'

# Here we go ..

#download_shellcheck
#download_opensslv3
download_unit_test
download_unit_test_help

run_shellcheck
run_unit_test

# No trap required..
clean_up

################################################################################

log "estat: $estat ${dry_run:+<<dry run>>}"
exit $estat

# vim: no

================
File: servidor/easy-rsa/README.md
================
[![CI](https://github.com/Openvpn/easy-rsa/actions/workflows/action.yml/badge.svg)](https://github.com/Openvpn/easy-rsa/actions/workflows/action.yml)
# Overview

easy-rsa is a CLI utility to build and manage a PKI CA. In layman's terms,
this means to create a root certificate authority, and request and sign
certificates, including intermediate CAs and certificate revocation lists (CRL).

# Downloads

If you are looking for release downloads, please see the releases section on
GitHub. Releases are also available as source checkouts using named tags.

# Documentation

For 3.x project documentation and usage, see the [README.quickstart.md](README.quickstart.md) file or
the more detailed docs under the [doc/](doc/) directory. The .md files are in Markdown
format and can be converted to html files as desired for release packages, or
read as-is in plaintext.

# Getting help using easy-rsa

Currently, Easy-RSA development co-exists with OpenVPN even though they are
separate projects. The following resources are good places as of this writing to
seek help using Easy-RSA:

The [openvpn-users mailing list](https://lists.sourceforge.net/lists/listinfo/openvpn-users)
is a good place to post usage or help questions.

Users of GitHub can report problems to the Easy-RSA `issues` list.

# Branch structure

The easy-rsa master branch is currently tracking development for the 3.x release
cycle. Please note that, at any given time, master may be broken. Feel free to
create issues against master, but have patience when using the master branch. It
is recommended to use a release, and priority will be given to bugs identified in
the most recent release.

The prior 2.x and 1.x versions are available as release branches for
tracking and possible back-porting of relevant fixes.

Branch layout is:

    master             <- Active: v3.2.x - Rolling.
    v3.<N>.<N>-<LABEL>    Active: Development branches.
    testing               Sandbox: Subject to change without notice.
    v3.1.8                Sunset: Bugfix only for v3.1.7

    The following are NOT compatible with OpenSSL version 3:

    v3.0.6                Inactive: Archived.
    v3.0.5                Inactive: Archived.
    v3.0.4                Inactive: Archived.
    release/3.0           Inactive: Archived.
    release/2.x           Inactive: Archived.
    release/1.x           Inactive: Unmaintained.

LICENSING info for 3.x is in the [COPYING.md](COPYING.md) file

## Contributing

Please refer to: [doc/EasyRSA-Contributing.md](doc/EasyRSA-Contributing.md)

# Code style, standards

We are attempting to adhere to the POSIX standard, which can be found here:

https://pubs.opengroup.org/onlinepubs/9699919799/

================
File: servidor/easy-rsa/README.quickstart.md
================
Easy-RSA 3 Quickstart README
============================

This is a quickstart guide to using Easy-RSA version 3. Detailed help on usage
and specific commands can be found by running ./easyrsa -h.  Additional
documentation can be found in the doc/ directory.

If you're upgrading from the Easy-RSA 2.x series, there are Upgrade-Notes
available, also under the doc/ path.

Setup and signing the first request
-----------------------------------

Here is a quick run-though of what needs to happen to start a new PKI and sign
your first entity certificate:

1. Choose a system to act as your CA and create a new PKI and CA:

        ./easyrsa init-pki
        ./easyrsa build-ca

2. On the system that is requesting a certificate, init its own PKI and generate
   a keypair/request. Note that init-pki is used _only_ when this is done on a
   separate system (or at least a separate PKI dir.) This is the recommended
   procedure. If you are not using this recommended procedure, skip the next
   import-req step.

        ./easyrsa init-pki
        ./easyrsa gen-req EntityName

3. Transport the request (.req file) to the CA system and import it. The name
   given here is arbitrary and only used to name the request file.

        ./easyrsa import-req /tmp/path/to/import.req EntityName

4. Sign the request as the correct type. This example uses a client type:

        ./easyrsa sign-req client EntityName

5. Transport the newly signed certificate to the requesting entity. This entity
   may also need the CA cert (ca.crt) unless it had a prior copy.

6. The entity now has its own keypair, signed cert, and the CA.

Signing subsequent requests
---------------------------

Follow steps 2-6 above to generate subsequent keypairs and have the CA return
signed certificates.

Revoking certs and creating CRLs
--------------------------------

This is a CA-specific task.

To permanently revoke an issued certificate, provide the short name used during
import:

        ./easyrsa revoke EntityName

To create an updated CRL that contains all revoked certs up to that point:

        ./easyrsa gen-crl

After generation, the CRL will need to be sent to systems that reference it.

Generating Diffie-Hellman (DH) params
-------------------------------------

After initializing a PKI, any entity can create DH params that needs them. This
is normally only used by a TLS server. While the CA PKI can generate this, it
makes more sense to do it on the server itself to avoid the need to send the
files to another system after generation.

DH params can be generated with:

        ./easyrsa gen-dh

Showing details of requests or certs
------------------------------------

To show the details of a request or certificate by referencing the short
EntityName, use one of the following commands. It is an error to call these
without a matching file.

        ./easyrsa show-req EntityName
        ./easyrsa show-cert EntityName

Changing private key passphrases
--------------------------------

RSA and EC private keys can be re-encrypted so a new passphrase can be supplied
with one of the following commands depending on the key type:

        ./easyrsa set-rsa-pass EntityName
        ./easyrsa set-ec-pass EntityName

Optionally, the passphrase can be removed completely with the 'nopass' flag.
Consult the command help for details.

================
File: servidor/easy-rsa/wop-test.bat
================
@echo off

IF "%1"=="/SL" (set SAVE_LAYOUT=1) ELSE set SAVE_LAYOUT=0

set SYS_ARCH=test
IF %PROCESSOR_ARCHITECTURE%==x86 set SYS_ARCH=win32
IF %PROCESSOR_ARCHITECTURE%==x86_64 set SYS_ARCH=win64
IF %PROCESSOR_ARCHITECTURE%==AMD64 set SYS_ARCH=win64
IF %SYS_ARCH%==test (
	echo Fatal Error: Unknown PROCESSOR_ARCHITECTURE
	set SYS_ARCH=
	exit /B 1 )

set WORK_DIR=%cd%
mkdir "%WORK_DIR%\easyrsa3\bin"
copy  "%WORK_DIR%\distro\windows\bin\*" "%WORK_DIR%\easyrsa3\bin"
copy  "%WORK_DIR%\distro\windows\%SYS_ARCH%\*" "%WORK_DIR%\easyrsa3\bin"
copy  "%WORK_DIR%\distro\windows\EasyRSA-Start.bat" "%WORK_DIR%\easyrsa3\EasyRSA-Start.bat"
PATH=%PATH%;%WORK_DIR%\easyrsa3\bin;C:\PROGRA~1\openssl

cmd /C "easyrsa3\bin\sh.exe wop-test.sh"
IF ERRORLEVEL 1 (
	echo Error occurred, Exit 1
	exit /B 1 )

REM Success ..
	IF %SAVE_LAYOUT% EQU 0 (
		echo rmdir /S /Q "%WORK_DIR%\easyrsa3\bin"
		rmdir /S /Q "%WORK_DIR%\easyrsa3\bin"
		echo del /Q "%WORK_DIR%\easyrsa3\EasyRSA-Start.bat"
		del /Q "%WORK_DIR%\easyrsa3\EasyRSA-Start.bat"
		REM echo del "%WORK_DIR%\easyrsa3\.rnd"
		REM del /Q "%WORK_DIR%\easyrsa3\.rnd"
	) ELSE echo NOTICE; Saved Layout

set SAVE_LAYOUT=
set SYS_ARCH=

================
File: servidor/easy-rsa/wop-test.sh
================
#!/bin/sh
# shellcheck disable=SC2161,SC1091

# This script is a frontend designed to create & launch a POSIX shell
# environment suitable for use with Easy-RSA. mksh/Win32 is used with this
# project; use with other POSIX shells for Windows may require modification to
# this wrapper script.

cd easyrsa3 || { echo "ERROR: Cannot find easyrsa3 directory"; exit 1; }

setup_path="${EASYRSA:-$PWD}"
export PATH="$setup_path;$setup_path/bin;$PATH"
export HOME="$setup_path"

# This prevents reading from a user's .mkshrc if they have one.
# A user who runs mksh for other purposes might have it
export ENV="/disable-env"

# Verify required externals are present
extern_list="which awk cat cp mkdir printf rm"
for f in $extern_list; do
	if ! which "${f}.exe" >/dev/null 2>&1; then
		echo ""
		echo "FATAL: EasyRSA Shell init is missing a required external file:"
		echo "  ${f}.exe"
		echo "  Your installation is incomplete and cannot function without the required"
		echo "  files."
		echo ""
		echo "  Press enter to exit."
		#shellcheck disable=SC2162
		read
		exit 1
	fi
done

# set_var is defined as any vars file needs it.
# This is the same as in easyrsa, but we _don't_ export
set_var() {
        var="$1"
        shift
        value="$*"
        eval "$var=\"\${$var-$value}\""
} #=> set_var()

# Check for a usable openssl bin, referencing vars if present
[ -r "vars" ] && EASYRSA_CALLER=1 . "vars" 2>/dev/null
if [ -z "$EASYRSA_OPENSSL" ] && ! which openssl.exe >/dev/null 2>&1; then
	echo "WARNING: openssl isn't in your system PATH. The openssl binary must be"
	echo "  available in the PATH, defined in the 'vars' file, or defined in a"
	echo "  named environment variable. See README-Windows.txt for more info."
fi

[ -f "$setup_path/easyrsa" ] || {
	echo "Missing easyrsa script. Expected to find it at: $setup_path/easyrsa"
	exit 2
}

# Set prompt and welcome message
export PS1='
EasyRSA Shell
# '
echo ""
echo "Welcome to the EasyRSA 3 Shell for Windows."
echo "Easy-RSA 3 is available under a GNU GPLv2 license."
echo ""
echo "Invoke './easyrsa' to call the program. Without commands, help is displayed."

cd ..

./op-test.sh -w -p -v

================
File: .gitignore
================
# Python-generated files
__pycache__/
*.py[oc]
build/
dist/
wheels/
*.egg-info

# Virtual environments
.venv

================
File: .python-version
================
3.13

================
File: Justfile
================
# Load environment variables from .env file
set dotenv-load

ssl_client:
  openssl s_client ${MQTT_HOST}:${MQTT_PORT}

ssl_client_with_cacert:
  openssl s_client \
      -CAfile ${CA_FILE} \
      ${MQTT_HOST}:${MQTT_PORT}

pub_with_cacert +ARGS:
  mosquitto_pub \
      --cafile ${CA_FILE} \
      -d -h ${MQTT_HOST} -p ${MQTT_PORT} \
      -t hello -m "moquitto clients" {{ ARGS }}

sub_with_cacert +ARGS:
  mosquitto_sub \
      --cafile ${CA_FILE} \
      -d -h ${MQTT_HOST} -p ${MQTT_PORT} \
      -v -t hello {{ ARGS }}

install_uv:
  curl -LsSf https://astral.sh/uv/install.sh | sh

sync:
  uv sync
  
py_pub:
  uv run python_client/mqtt_pub.py

py_sub:
  uv run python_client/mqtt_sub.py

================
File: LICENSE
================
MIT License
Copyright (c) [2025] [Oriol Rius Canals]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: pyproject.toml
================
[project]
name = "kiss-mqtt-client-private-pki"
version = "0.1.0"
description = "Proof of concept MQTT server with self-signed certificates"
readme = "README.md"
requires-python = ">=3.13"
dependencies = [
    "paho-mqtt>=2.1.0",
    "python-dotenv>=1.0.1",
]
authors = [
    { name = "Oriol Rius", email = "oriol@joor.net" },
]
keywords = ["mqtt", "ssl", "tls", "iot"]
license = "MIT"

================
File: README.md
================
# Mosquitto MQTT Broker with Websockets and Self-Signed Certificates

More information about the proof of concept at []().

================
File: uv.lock
================
version = 1
requires-python = ">=3.13"

[[package]]
name = "kiss-mqtt-client-private-pki"
version = "0.1.0"
source = { virtual = "." }
dependencies = [
    { name = "paho-mqtt" },
    { name = "python-dotenv" },
]

[package.metadata]
requires-dist = [
    { name = "paho-mqtt", specifier = ">=2.1.0" },
    { name = "python-dotenv", specifier = ">=1.0.1" },
]

[[package]]
name = "paho-mqtt"
version = "2.1.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/39/15/0a6214e76d4d32e7f663b109cf71fb22561c2be0f701d67f93950cd40542/paho_mqtt-2.1.0.tar.gz", hash = "sha256:12d6e7511d4137555a3f6ea167ae846af2c7357b10bc6fa4f7c3968fc1723834", size = 148848 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/c4/cb/00451c3cf31790287768bb12c6bec834f5d292eaf3022afc88e14b8afc94/paho_mqtt-2.1.0-py3-none-any.whl", hash = "sha256:6db9ba9b34ed5bc6b6e3812718c7e06e2fd7444540df2455d2c51bd58808feee", size = 67219 },
]

[[package]]
name = "python-dotenv"
version = "1.0.1"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/bc/57/e84d88dfe0aec03b7a2d4327012c1627ab5f03652216c63d49846d7a6c58/python-dotenv-1.0.1.tar.gz", hash = "sha256:e324ee90a023d808f1959c46bcbc04446a10ced277783dc6ee09987c37ec10ca", size = 39115 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/6a/3e/b68c118422ec867fa7ab88444e1274aa40681c606d59ac27de5a5588f082/python_dotenv-1.0.1-py3-none-any.whl", hash = "sha256:f7b63ef50f1b690dddf550d03497b66d609393b40b564ed0d674909a68ebf16a", size = 19863 },
]
